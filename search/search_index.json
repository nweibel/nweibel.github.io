{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur Carnets.info Ce site pr\u00e9sente quelques documents utilis\u00e9s dans le cadre de : - l'enseignement de NSI 1 , en 1\u00e8re g\u00e9n\u00e9rale, - l'enseignement de SNT 2 en 2nde, - ou en formation. Num\u00e9rique et sciences informatiques \u21a9 Sciences du num\u00e9rique et technologie \u21a9","title":"Accueil"},{"location":"#bienvenue-sur-carnetsinfo","text":"Ce site pr\u00e9sente quelques documents utilis\u00e9s dans le cadre de : - l'enseignement de NSI 1 , en 1\u00e8re g\u00e9n\u00e9rale, - l'enseignement de SNT 2 en 2nde, - ou en formation. Num\u00e9rique et sciences informatiques \u21a9 Sciences du num\u00e9rique et technologie \u21a9","title":"Bienvenue sur Carnets.info"},{"location":"about/","text":"\u00c0 propos Site r\u00e9alis\u00e9 par Nathalie Weibel, enseignante dans l'acad\u00e9mie de Normandie","title":"\u00c0 propos"},{"location":"about/#a-propos","text":"Site r\u00e9alis\u00e9 par Nathalie Weibel, enseignante dans l'acad\u00e9mie de Normandie","title":"\u00c0 propos"},{"location":"jupyter/calepyn/","text":"Acc\u00e8s \u00e0 mes calepyns , par ordre chronologique.","title":"Calepyn"},{"location":"jupyter/doctest/","text":"Effectuer des tests automatis\u00e9s avec doctest dans un notebook Jupyter On peut r\u00e9aliser des tests automatis\u00e9s dans un fichier python gr\u00e2ce \u00e0 la biblioth\u00e8que doctest . La biblioth\u00e8que doctest permet de d\u00e9tecter automatiquement les tests \u00e9crits dans la docstring , ou chaine de documentation, de les lancer et d\u2019afficher un rapport. Les valeurs \u00e0 tester doivent \u00eatre pr\u00e9c\u00e9d\u00e9es de >>> , et le r\u00e9sultat attendu doit \u00eatre en d\u00e9but de ligne suivante. Voici un exemple pour la fonction est_parfait : def est_parfait ( n ) : '''n est un entier strictement positif parfait(n) vaut True si l'entier n est parfait ou False sinon. Un nombre parfait est tel que la somme de ses diviseurs est \u00e9gale \u00e0 son double. >>> est_parfait(2) False >>> est_parfait(6) True >>> est_parfait(27) False >>> est_parfait(28) True ''' assert ( n > 0 and type ( n ) == int ), \"l'argument doit \u00eatre un entier strictement positif\" diviseurs = [ i for i in range ( 1 , n + 1 ) if n % i == 0 ] return sum ( diviseurs ) == 2 * n On ex\u00e9cute dans une cellule du notebook les instructions suivantes : import doctest doctest . testmod () Un rapport concis des tests est alors affich\u00e9 (attention, les tests sont lanc\u00e9s sur l\u2019ensemble du notebook) : TestResults(failed=0, attempted=4) ce qui signifie ici que les 4 tests n'ont donn\u00e9 lieu \u00e0 aucun \u00e9chec. On peut ajouter l\u2019argument verbose=True en \u00e9crivant doctest.testmod(verbose=True) : le rapport produit est alors plus explicite. Trying : est_parfait ( 2 ) Expecting : False ok Trying : est_parfait ( 6 ) Expecting : True ok Trying : est_parfait ( 27 ) Expecting : False ok Trying : est_parfait ( 28 ) Expecting : True ok 1 items had no tests : __main__ 1 items passed all tests : 4 tests in __main__ . est_parfait 4 tests in 2 items . 4 passed and 0 failed . Test passed . TestResults ( failed = 0 , attempted = 4 )","title":"Doctest"},{"location":"jupyter/doctest/#effectuer-des-tests-automatises-avec-doctest-dans-un-notebook-jupyter","text":"On peut r\u00e9aliser des tests automatis\u00e9s dans un fichier python gr\u00e2ce \u00e0 la biblioth\u00e8que doctest . La biblioth\u00e8que doctest permet de d\u00e9tecter automatiquement les tests \u00e9crits dans la docstring , ou chaine de documentation, de les lancer et d\u2019afficher un rapport. Les valeurs \u00e0 tester doivent \u00eatre pr\u00e9c\u00e9d\u00e9es de >>> , et le r\u00e9sultat attendu doit \u00eatre en d\u00e9but de ligne suivante. Voici un exemple pour la fonction est_parfait : def est_parfait ( n ) : '''n est un entier strictement positif parfait(n) vaut True si l'entier n est parfait ou False sinon. Un nombre parfait est tel que la somme de ses diviseurs est \u00e9gale \u00e0 son double. >>> est_parfait(2) False >>> est_parfait(6) True >>> est_parfait(27) False >>> est_parfait(28) True ''' assert ( n > 0 and type ( n ) == int ), \"l'argument doit \u00eatre un entier strictement positif\" diviseurs = [ i for i in range ( 1 , n + 1 ) if n % i == 0 ] return sum ( diviseurs ) == 2 * n On ex\u00e9cute dans une cellule du notebook les instructions suivantes : import doctest doctest . testmod () Un rapport concis des tests est alors affich\u00e9 (attention, les tests sont lanc\u00e9s sur l\u2019ensemble du notebook) : TestResults(failed=0, attempted=4) ce qui signifie ici que les 4 tests n'ont donn\u00e9 lieu \u00e0 aucun \u00e9chec. On peut ajouter l\u2019argument verbose=True en \u00e9crivant doctest.testmod(verbose=True) : le rapport produit est alors plus explicite. Trying : est_parfait ( 2 ) Expecting : False ok Trying : est_parfait ( 6 ) Expecting : True ok Trying : est_parfait ( 27 ) Expecting : False ok Trying : est_parfait ( 28 ) Expecting : True ok 1 items had no tests : __main__ 1 items passed all tests : 4 tests in __main__ . est_parfait 4 tests in 2 items . 4 passed and 0 failed . Test passed . TestResults ( failed = 0 , attempted = 4 )","title":"Effectuer des tests automatis\u00e9s avec doctest dans un notebook Jupyter"},{"location":"jupyter/ipythonblocks/","text":"ipythonblocks : pr\u00e9sentation ipythonblocks est un outil p\u00e9dagogique qui propose de cr\u00e9er des grilles de cases color\u00e9es. Il permet d'exp\u00e9rimenter les concepts de contr\u00f4le de flux Python et de voir imm\u00e9diatement les effets du code repr\u00e9sent\u00e9s de mani\u00e8re color\u00e9e et attrayante. 0. G\u00e9n\u00e9ralit\u00e9s - ipythonbocks sur PyPI Pour retrouver la derni\u00e8re version, les conseils d'installation : https://pypi.org/project/ipythonblocks/ - Le site ipythonblocks.org Le site ipythonblocks.org propose de publier ses images et de consulter des exemples de grilles. 1. Grille : classe BlockGrid ipythonblocks fournit une classe BlockGrid dont la repr\u00e9sentation est une grille. Pour cr\u00e9er (instancier) une grille, on appelle la m\u00e9thode BlockGrid(width, height) o\u00f9 : width est un entier : nombre de blocs par ligne height est un entier : nombre de blocs par colonne Des param\u00e8tres optionnels peuvent \u00eatre pr\u00e9cis\u00e9s : fill est un triplet d'entiers, repr\u00e9sentant les niveaux de (rouge, vert, bleu) entre 0 et 255. Sa valeur par d\u00e9faut est (0, 0, 0), ce qui d\u00e9finit des blocs de couleur noire. block_size est un entier, repr\u00e9sentant la longueur des c\u00f4t\u00e9s des blocs de la grille en pixels. Sa valeur par d\u00e9faut est 20, et sa valeur minimale et 1. lines_on est un bool\u00e9en, pr\u00e9cisant si les lignes ente les blocs doivent \u00eatre affich\u00e9s ou non. Sa valeur par d\u00e9faut est =True from ipythonblocks import BlockGrid Exemple 1 grille_A = BlockGrid ( 12 , 4 ) grille_A table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blockse7ee1f4f-7358-4a09-b91a-7a73493b7496 td {border: 1px solid white;} Exemple 2 grille_B = BlockGrid ( 5 , 6 , fill = ( 230 , 92 , 92 )) grille_B table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks1c6769e2-2558-42e4-8848-bc7ed9236800 td {border: 1px solid white;} Exemple 3 grille_C = BlockGrid ( 30 , 10 , block_size = 8 , fill = ( 52 , 52 , 150 )) grille_C table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks3e79c60d-745d-4ee3-ab62-2d2cd8daf985 td {border: 1px solid white;} 2. Cellule : classe Block Les cellules de la grille sont repr\u00e9sent\u00e9es par des objets de la classe Block . On acc\u00e8de \u00e0 une cellule de la grille en pr\u00e9cisant ses coordonn\u00e9es dans la grille entre crochets. La premi\u00e8re coordonn\u00e9e est l'indice de ligne, la seconde l'indice de colonne. Les indices d\u00e9butent \u00e0 0. cellule = grille_C [ 0 , 29 ] # cellule en haut \u00e0 droite cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks34adc965-b75a-4d22-a59a-f03c22f690ee td {border: 0px solid white;} Chaque cellule est dot\u00e9e d'attributs gr\u00e2ce auxquels on peut lire et modifier les propri\u00e9t\u00e9s de cette cellule : red , green et blue : entier indiquant le niveau de chaque couleur rgb : triplet d'entiers indiquant les niveaux de (rouge, vert, bleu) size : entier indiquant la dimension de la cellule La position de la cellule dans la grille est donn\u00e9e par des attributs qu'on ne peut pas modifier : row : indice de ligne de la cellule col : indice de colonne de la cellule La m\u00e9thode set_colors permet de modifier les niveaux de (rouge, vert, bleu). Au survol de la souris, les coordonn\u00e9es et la couleur de la cellule sont affich\u00e9es. cellule . red = 240 cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks93944bdf-ee7e-48a3-9f23-fac58851a3c4 td {border: 0px solid white;} grille_C table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks12cda116-309d-4727-bf26-24f8bcb7f68c td {border: 1px solid white;} couleurs = [ 'rouge' , 'vert' , 'bleu' ] valeurs = cellule . rgb for couleur , valeur in zip ( couleurs , valeurs ): print ( couleur , valeur ) rouge 240 vert 52 bleu 150 Exemples grille_D = BlockGrid ( 10 , 10 ) for cellule in grille_D : if ( cellule . row + cellule . col ) % 2 == 0 : cellule . set_colors ( 255 , 255 , 255 ) grille_D table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksf8f1676d-ff13-4774-9454-9f9ebc358877 td {border: 1px solid white;} grille_E = BlockGrid ( 10 , 10 ) for cellule in grille_E : if ( cellule . row * cellule . col ) % 2 == 0 : cellule . set_colors ( 225 , 225 , 225 ) grille_E table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksa5928b11-c2e2-49b9-a320-23ebfcebb83a td {border: 1px solid white;} grille_F = BlockGrid ( 10 , 10 ) for cellule in grille_F : if ( cellule . row == 7 or cellule . col == 3 ): cellule . set_colors ( 235 , 235 , 235 ) grille_F table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2076d2a3-efe9-4d71-8355-4e5f50659c7d td {border: 1px solid white;} grille_G = BlockGrid ( 10 , 10 ) for cellule in grille_G : if ( cellule . row > 7 or cellule . col <= 3 ): cellule . set_colors ( 205 , 90 , 90 ) grille_G table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd945c1bb-a7d9-4d70-835f-2a63a04fc86b td {border: 1px solid white;} grille_H = BlockGrid ( 10 , 10 ) for cellule in grille_H : k = cellule . row + cellule . col cellule . set_colors ( 20 * k , 8 * k , 10 * k ) grille_H table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks81ee9dd6-b9ce-4ad8-89bc-f45ce8cb4d0d td {border: 1px solid white;} 3. Animation Exemples M\u00e9thode 1 import time from IPython.display import clear_output grille = BlockGrid ( 4 , 3 , block_size = 30 , fill = ( 52 , 52 , 100 )) prec_cellule = None for i in range ( 3 ): for cellule in grille : clear_output () cellule . blue = 255 if prec_cellule is not None : prec_cellule . blue = 100 grille . show () time . sleep ( 0.3 ) prec_cellule = cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksb327b587-46e4-448d-82c4-d478a48cd8a7 td {border: 1px solid white;} M\u00e9thode 2 grille = BlockGrid ( 4 , 3 , block_size = 30 , fill = ( 52 , 52 , 100 )) prec_cellule = None for i in range ( 3 ): for cellule in grille : clear_output () cellule . blue = 255 if prec_cellule is not None : prec_cellule . blue = 100 grille . flash ( display_time = 0.5 ) prec_cellule = cellule grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks76c241e1-f542-49c2-b6f3-fcf62ded2271 td {border: 1px solid white;}","title":"ipythonblocks"},{"location":"jupyter/ipythonblocks/#ipythonblocks-presentation","text":"ipythonblocks est un outil p\u00e9dagogique qui propose de cr\u00e9er des grilles de cases color\u00e9es. Il permet d'exp\u00e9rimenter les concepts de contr\u00f4le de flux Python et de voir imm\u00e9diatement les effets du code repr\u00e9sent\u00e9s de mani\u00e8re color\u00e9e et attrayante.","title":"ipythonblocks : pr\u00e9sentation"},{"location":"jupyter/ipythonblocks/#0-generalites","text":"","title":"0. G\u00e9n\u00e9ralit\u00e9s"},{"location":"jupyter/ipythonblocks/#-ipythonbocks-sur-pypi","text":"Pour retrouver la derni\u00e8re version, les conseils d'installation : https://pypi.org/project/ipythonblocks/","title":"- ipythonbocks sur PyPI"},{"location":"jupyter/ipythonblocks/#-le-site-ipythonblocksorg","text":"Le site ipythonblocks.org propose de publier ses images et de consulter des exemples de grilles.","title":"- Le site ipythonblocks.org"},{"location":"jupyter/ipythonblocks/#1-grille-classe-blockgrid","text":"ipythonblocks fournit une classe BlockGrid dont la repr\u00e9sentation est une grille. Pour cr\u00e9er (instancier) une grille, on appelle la m\u00e9thode BlockGrid(width, height) o\u00f9 : width est un entier : nombre de blocs par ligne height est un entier : nombre de blocs par colonne Des param\u00e8tres optionnels peuvent \u00eatre pr\u00e9cis\u00e9s : fill est un triplet d'entiers, repr\u00e9sentant les niveaux de (rouge, vert, bleu) entre 0 et 255. Sa valeur par d\u00e9faut est (0, 0, 0), ce qui d\u00e9finit des blocs de couleur noire. block_size est un entier, repr\u00e9sentant la longueur des c\u00f4t\u00e9s des blocs de la grille en pixels. Sa valeur par d\u00e9faut est 20, et sa valeur minimale et 1. lines_on est un bool\u00e9en, pr\u00e9cisant si les lignes ente les blocs doivent \u00eatre affich\u00e9s ou non. Sa valeur par d\u00e9faut est =True from ipythonblocks import BlockGrid","title":"1. Grille : classe BlockGrid"},{"location":"jupyter/ipythonblocks/#exemple-1","text":"grille_A = BlockGrid ( 12 , 4 ) grille_A table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blockse7ee1f4f-7358-4a09-b91a-7a73493b7496 td {border: 1px solid white;}","title":"Exemple 1"},{"location":"jupyter/ipythonblocks/#exemple-2","text":"grille_B = BlockGrid ( 5 , 6 , fill = ( 230 , 92 , 92 )) grille_B table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks1c6769e2-2558-42e4-8848-bc7ed9236800 td {border: 1px solid white;}","title":"Exemple 2"},{"location":"jupyter/ipythonblocks/#exemple-3","text":"grille_C = BlockGrid ( 30 , 10 , block_size = 8 , fill = ( 52 , 52 , 150 )) grille_C table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks3e79c60d-745d-4ee3-ab62-2d2cd8daf985 td {border: 1px solid white;}","title":"Exemple 3"},{"location":"jupyter/ipythonblocks/#2-cellule-classe-block","text":"Les cellules de la grille sont repr\u00e9sent\u00e9es par des objets de la classe Block . On acc\u00e8de \u00e0 une cellule de la grille en pr\u00e9cisant ses coordonn\u00e9es dans la grille entre crochets. La premi\u00e8re coordonn\u00e9e est l'indice de ligne, la seconde l'indice de colonne. Les indices d\u00e9butent \u00e0 0. cellule = grille_C [ 0 , 29 ] # cellule en haut \u00e0 droite cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks34adc965-b75a-4d22-a59a-f03c22f690ee td {border: 0px solid white;} Chaque cellule est dot\u00e9e d'attributs gr\u00e2ce auxquels on peut lire et modifier les propri\u00e9t\u00e9s de cette cellule : red , green et blue : entier indiquant le niveau de chaque couleur rgb : triplet d'entiers indiquant les niveaux de (rouge, vert, bleu) size : entier indiquant la dimension de la cellule La position de la cellule dans la grille est donn\u00e9e par des attributs qu'on ne peut pas modifier : row : indice de ligne de la cellule col : indice de colonne de la cellule La m\u00e9thode set_colors permet de modifier les niveaux de (rouge, vert, bleu). Au survol de la souris, les coordonn\u00e9es et la couleur de la cellule sont affich\u00e9es. cellule . red = 240 cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks93944bdf-ee7e-48a3-9f23-fac58851a3c4 td {border: 0px solid white;} grille_C table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks12cda116-309d-4727-bf26-24f8bcb7f68c td {border: 1px solid white;} couleurs = [ 'rouge' , 'vert' , 'bleu' ] valeurs = cellule . rgb for couleur , valeur in zip ( couleurs , valeurs ): print ( couleur , valeur ) rouge 240 vert 52 bleu 150","title":"2. Cellule : classe Block"},{"location":"jupyter/ipythonblocks/#exemples","text":"grille_D = BlockGrid ( 10 , 10 ) for cellule in grille_D : if ( cellule . row + cellule . col ) % 2 == 0 : cellule . set_colors ( 255 , 255 , 255 ) grille_D table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksf8f1676d-ff13-4774-9454-9f9ebc358877 td {border: 1px solid white;} grille_E = BlockGrid ( 10 , 10 ) for cellule in grille_E : if ( cellule . row * cellule . col ) % 2 == 0 : cellule . set_colors ( 225 , 225 , 225 ) grille_E table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksa5928b11-c2e2-49b9-a320-23ebfcebb83a td {border: 1px solid white;} grille_F = BlockGrid ( 10 , 10 ) for cellule in grille_F : if ( cellule . row == 7 or cellule . col == 3 ): cellule . set_colors ( 235 , 235 , 235 ) grille_F table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2076d2a3-efe9-4d71-8355-4e5f50659c7d td {border: 1px solid white;} grille_G = BlockGrid ( 10 , 10 ) for cellule in grille_G : if ( cellule . row > 7 or cellule . col <= 3 ): cellule . set_colors ( 205 , 90 , 90 ) grille_G table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd945c1bb-a7d9-4d70-835f-2a63a04fc86b td {border: 1px solid white;} grille_H = BlockGrid ( 10 , 10 ) for cellule in grille_H : k = cellule . row + cellule . col cellule . set_colors ( 20 * k , 8 * k , 10 * k ) grille_H table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks81ee9dd6-b9ce-4ad8-89bc-f45ce8cb4d0d td {border: 1px solid white;}","title":"Exemples"},{"location":"jupyter/ipythonblocks/#3-animation","text":"","title":"3. Animation"},{"location":"jupyter/ipythonblocks/#exemples_1","text":"","title":"Exemples"},{"location":"jupyter/ipythonblocks/#methode-1","text":"import time from IPython.display import clear_output grille = BlockGrid ( 4 , 3 , block_size = 30 , fill = ( 52 , 52 , 100 )) prec_cellule = None for i in range ( 3 ): for cellule in grille : clear_output () cellule . blue = 255 if prec_cellule is not None : prec_cellule . blue = 100 grille . show () time . sleep ( 0.3 ) prec_cellule = cellule table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksb327b587-46e4-448d-82c4-d478a48cd8a7 td {border: 1px solid white;}","title":"M\u00e9thode 1"},{"location":"jupyter/ipythonblocks/#methode-2","text":"grille = BlockGrid ( 4 , 3 , block_size = 30 , fill = ( 52 , 52 , 100 )) prec_cellule = None for i in range ( 3 ): for cellule in grille : clear_output () cellule . blue = 255 if prec_cellule is not None : prec_cellule . blue = 100 grille . flash ( display_time = 0.5 ) prec_cellule = cellule grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks76c241e1-f542-49c2-b6f3-fcf62ded2271 td {border: 1px solid white;}","title":"M\u00e9thode 2"},{"location":"jupyter/memomd/","text":"M\u00e9mo Markdown Markdown a \u00e9t\u00e9 cr\u00e9\u00e9 par John Gruber en 2004. Markdown est con\u00e7u pour \u00eatre aussi facile \u00e0 lire et \u00e0 \u00e9crire que possible. Il est ais\u00e9ment convertible en HTML. Les fichiers Markdown poss\u00e8dent l\u2019extension .md . Markdown est \u00e9galement le langage des cellules de texte d'un notebook Jupyter. Voici la plupart des \u00e9l\u00e9ments de la syntaxe Markdown et leur \u00e9quivalent en HTML. Titres Markdown # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 #### Titre de niveau 4 ##### Titre de niveau 5 ###### Titre de niveau 6 HTML < h1 > Titre de niveau 1 </ h1 > < h2 > Titre de niveau 2 </ h2 > < h3 > Titre de niveau 3 </ h3 > < h4 > Titre de niveau 4 </ h4 > < h5 > Titre de niveau 5 </ h5 > < h6 > Titre de niveau 6 </ h6 > Emphase Markdown *Texte en italique* **Texte en gras** ~~Texte barr\u00e9~~ HTML < p >< em > Texte en italique </ em ></ p > < p >< strong > Texte en gras </ strong > </ p > < p >< s > Texte barr\u00e9 </ s ></ p > Aper\u00e7u Texte en italique Texte en gras Texte barr\u00e9 Listes Listes \u00e0 puces Markdown * \u00c9l\u00e9ment 1 * \u00c9l\u00e9ment 2 * Sous-\u00e9l\u00e9ment 1 * Sous \u00e9l\u00e9ment 2 * \u00c9l\u00e9ment 3 HTML < ul > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ul > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ul > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Listes ordonn\u00e9es Markdown 1. \u00c9l\u00e9ment 1 2. \u00c9l\u00e9ment 2 1. Sous-\u00e9l\u00e9ment 1 2. Sous \u00e9l\u00e9ment 2 3. \u00c9l\u00e9ment 3 HTML < ol > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ol > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ol > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ol > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Remarque : la valeur num\u00e9rique des entr\u00e9es des \u00e9l\u00e9ments n'a pas d'importance : Markdown 1. \u00c9l\u00e9ment 1 1. \u00c9l\u00e9ment 2 4. \u00c9l\u00e9ment 3 Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 \u00c9l\u00e9ment 3 Listes \u00e0 cocher Markdown - [x] \u00c9l\u00e9ment 1, coch\u00e9 - [ ] \u00c9l\u00e9ment 2, non-coch\u00e9 - [x] Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 - [ ] Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 - [ ] \u00c9l\u00e9ment 3, non-coch\u00e9 HTML < ul > < li > < label > < input type = \"checkbox\" checked > \u00c9l\u00e9ment 1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 2, non-coch\u00e9 </ label > </ li > < ul > < li > < label > < input type = \"checkbox\" checked > Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 </ label > </ li > </ ul > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 3, non-coch\u00e9 </ label > </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1, coch\u00e9 \u00c9l\u00e9ment 2, non-coch\u00e9 Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 \u00c9l\u00e9ment 3, non-coch\u00e9 Citations Markdown > Voici une citation > sur plusieurs lignes HTML < blockquote > < p > Voici une citation </ p > < p > sur plusieurs lignes </ p > </ blockquote > Aper\u00e7u Voici une citation sur plusieurs lignes S\u00e9parateurs horizontaux Markdown --- ou *** ou ___ HTML < hr /> Aper\u00e7u Liens Markdown [ Ceci est le texte du lien ]( https://www.carnets.info ) [ Ceci est un lien avec un titre au survol ]( https://www.carnets.info \"Le titre du lien\" ) Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : <https://www.carnets.info> HTML < p >< a href = \"https://www.carnets.info\" > Ceci est le texte du lien </ a ></ p > < p >< a href = \"https://www.carnets.info\" title = \"Le titre du lien\" > Ceci est un lien avec un titre au survol </ a ></ p > < p > Ceci est un lien automatique : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > < p > On rencontre aussi cette syntaxe : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > Aper\u00e7u Ceci est le texte du lien Ceci est un lien avec un titre au survol Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : https://www.carnets.info Images Markdown ![ logo Markdown ]( https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Markdown\" ) HTML < img src = \"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt = \"logo Markdown\" title = \"Logo Markdown\" > Aper\u00e7u Tableaux Markdown Titre colonne 1 (gauche) | Titre colonne 2 (centr\u00e9) | Titre colonne 3 (centr\u00e9) :--- | :---: | :---: Celule 1.1 | Celule 1.2 | Celule 1.3 Celule 2.1 | Celule 2.2 | Celule 2.3 HTML < table > < thead > < tr > < th > Titre colonne 1 </ th > < th > Titre colonne 2 </ th > < th > Titre colonne 3 </ th > </ tr > </ thead > < tbody > < tr > < td > Celule 1.1 </ td > < td > Celule 1.2 </ td > < td > Celule 1.3 </ td > </ tr > < tr > < td > Celule 2.1 </ td > < td > Celule 2.2 </ td > < td > Celule 2.3 </ td > </ tr > </ tbody > </ table > Aper\u00e7u Titre colonne 1 (gauche) Titre colonne 2 (centr\u00e9) Titre colonne 3 (centr\u00e9) Celule 1.1 Celule 1.2 Celule 1.3 Celule 2.1 Celule 2.2 Celule 2.3 Code Code en ligne Markdown insertion de code en ligne : `print(\"Hello World!\")` HTML < p > insertion de code en ligne : < code > print(\"Hello World!\") </ code ></ p > Aper\u00e7u insertion de code en ligne : print(\"Hello World!\") Bloc de code Markdown ```python print ( \"Hello World!\" ) ``` HTML < pre > print(\"Hello World!\") </ pre > Aper\u00e7u print ( \"Hello World!\" ) Boites color\u00e9es dans un notebook Jupyter Markdown/HTML < div class = \"alert alert-block alert-info\" > Boite bleue </ div > < div class = \"alert alert-block alert-success\" > Boite verte </ div > < div class = \"alert alert-block alert-warning\" > Boite jaune </ div > < div class = \"alert alert-block alert-danger\" > Boite rouge </ div > Aper\u00e7u Formules LaTeX (MathJax) Markdown Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : $x^2 + 3x -7 = 0$ Mode bloc (display) : On trouve : $$x = \\frac{-3 \\pm \\sqrt{37}}{2}$$ Aper\u00e7u Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : x^2 + 3x -7 = 0 x^2 + 3x -7 = 0 Mode bloc (display) : On trouve : x = \\frac{-3 \\pm \\sqrt{37}}{2} x = \\frac{-3 \\pm \\sqrt{37}}{2} Caract\u00e8res sp\u00e9cifiques Tirets Il n'y a pas de balise Markdown sp\u00e9cifique pour r\u00e9aliser des tirets cadratins ou demi-cadratins. On utilise des balises HTML pour cr\u00e9er ces tirets. tiret long ou tiret cadratin : HTML &mdash; Aper\u00e7u \u2014 tiret moyen ou tiret demi-cadratin HTML &ndash; Aper\u00e7u \u2013 Touches clavier Markdown <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> Aper\u00e7u Ctrl + Alt + Del Notes de bas de page Markdown Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page[^a]. Et une autre[^b]. On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois[^b]. [ ^a ]: Les notes de bas de page peuvent \u00eatre **mises en forme**, et sur plusieurs lignes. [ ^b ]: Autre note de bas de page. Aper\u00e7u : Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page 1 . Et une autre 2 . On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois 2 . Les notes de bas de page peuvent \u00eatre mises en forme , et sur plusieurs lignes. \u21a9 Autre note de bas de page. \u21a9 \u21a9","title":"M\u00e9mo Markdown"},{"location":"jupyter/memomd/#memo-markdown","text":"Markdown a \u00e9t\u00e9 cr\u00e9\u00e9 par John Gruber en 2004. Markdown est con\u00e7u pour \u00eatre aussi facile \u00e0 lire et \u00e0 \u00e9crire que possible. Il est ais\u00e9ment convertible en HTML. Les fichiers Markdown poss\u00e8dent l\u2019extension .md . Markdown est \u00e9galement le langage des cellules de texte d'un notebook Jupyter. Voici la plupart des \u00e9l\u00e9ments de la syntaxe Markdown et leur \u00e9quivalent en HTML.","title":" M\u00e9mo Markdown"},{"location":"jupyter/memomd/#titres","text":"Markdown # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 #### Titre de niveau 4 ##### Titre de niveau 5 ###### Titre de niveau 6 HTML < h1 > Titre de niveau 1 </ h1 > < h2 > Titre de niveau 2 </ h2 > < h3 > Titre de niveau 3 </ h3 > < h4 > Titre de niveau 4 </ h4 > < h5 > Titre de niveau 5 </ h5 > < h6 > Titre de niveau 6 </ h6 >","title":" Titres"},{"location":"jupyter/memomd/#emphase","text":"Markdown *Texte en italique* **Texte en gras** ~~Texte barr\u00e9~~ HTML < p >< em > Texte en italique </ em ></ p > < p >< strong > Texte en gras </ strong > </ p > < p >< s > Texte barr\u00e9 </ s ></ p > Aper\u00e7u Texte en italique Texte en gras Texte barr\u00e9","title":" Emphase"},{"location":"jupyter/memomd/#listes","text":"","title":" Listes"},{"location":"jupyter/memomd/#listes-a-puces","text":"Markdown * \u00c9l\u00e9ment 1 * \u00c9l\u00e9ment 2 * Sous-\u00e9l\u00e9ment 1 * Sous \u00e9l\u00e9ment 2 * \u00c9l\u00e9ment 3 HTML < ul > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ul > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ul > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3","title":" Listes \u00e0 puces"},{"location":"jupyter/memomd/#listes-ordonnees","text":"Markdown 1. \u00c9l\u00e9ment 1 2. \u00c9l\u00e9ment 2 1. Sous-\u00e9l\u00e9ment 1 2. Sous \u00e9l\u00e9ment 2 3. \u00c9l\u00e9ment 3 HTML < ol > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ol > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ol > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ol > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Remarque : la valeur num\u00e9rique des entr\u00e9es des \u00e9l\u00e9ments n'a pas d'importance : Markdown 1. \u00c9l\u00e9ment 1 1. \u00c9l\u00e9ment 2 4. \u00c9l\u00e9ment 3 Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 \u00c9l\u00e9ment 3","title":" Listes ordonn\u00e9es"},{"location":"jupyter/memomd/#listes-a-cocher","text":"Markdown - [x] \u00c9l\u00e9ment 1, coch\u00e9 - [ ] \u00c9l\u00e9ment 2, non-coch\u00e9 - [x] Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 - [ ] Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 - [ ] \u00c9l\u00e9ment 3, non-coch\u00e9 HTML < ul > < li > < label > < input type = \"checkbox\" checked > \u00c9l\u00e9ment 1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 2, non-coch\u00e9 </ label > </ li > < ul > < li > < label > < input type = \"checkbox\" checked > Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 </ label > </ li > </ ul > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 3, non-coch\u00e9 </ label > </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1, coch\u00e9 \u00c9l\u00e9ment 2, non-coch\u00e9 Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 \u00c9l\u00e9ment 3, non-coch\u00e9","title":" Listes \u00e0 cocher"},{"location":"jupyter/memomd/#citations","text":"Markdown > Voici une citation > sur plusieurs lignes HTML < blockquote > < p > Voici une citation </ p > < p > sur plusieurs lignes </ p > </ blockquote > Aper\u00e7u Voici une citation sur plusieurs lignes","title":" Citations"},{"location":"jupyter/memomd/#separateurs-horizontaux","text":"Markdown --- ou *** ou ___ HTML < hr /> Aper\u00e7u","title":" S\u00e9parateurs horizontaux"},{"location":"jupyter/memomd/#liens","text":"Markdown [ Ceci est le texte du lien ]( https://www.carnets.info ) [ Ceci est un lien avec un titre au survol ]( https://www.carnets.info \"Le titre du lien\" ) Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : <https://www.carnets.info> HTML < p >< a href = \"https://www.carnets.info\" > Ceci est le texte du lien </ a ></ p > < p >< a href = \"https://www.carnets.info\" title = \"Le titre du lien\" > Ceci est un lien avec un titre au survol </ a ></ p > < p > Ceci est un lien automatique : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > < p > On rencontre aussi cette syntaxe : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > Aper\u00e7u Ceci est le texte du lien Ceci est un lien avec un titre au survol Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : https://www.carnets.info","title":" Liens"},{"location":"jupyter/memomd/#images","text":"Markdown ![ logo Markdown ]( https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Markdown\" ) HTML < img src = \"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt = \"logo Markdown\" title = \"Logo Markdown\" > Aper\u00e7u","title":" Images"},{"location":"jupyter/memomd/#tableaux","text":"Markdown Titre colonne 1 (gauche) | Titre colonne 2 (centr\u00e9) | Titre colonne 3 (centr\u00e9) :--- | :---: | :---: Celule 1.1 | Celule 1.2 | Celule 1.3 Celule 2.1 | Celule 2.2 | Celule 2.3 HTML < table > < thead > < tr > < th > Titre colonne 1 </ th > < th > Titre colonne 2 </ th > < th > Titre colonne 3 </ th > </ tr > </ thead > < tbody > < tr > < td > Celule 1.1 </ td > < td > Celule 1.2 </ td > < td > Celule 1.3 </ td > </ tr > < tr > < td > Celule 2.1 </ td > < td > Celule 2.2 </ td > < td > Celule 2.3 </ td > </ tr > </ tbody > </ table > Aper\u00e7u Titre colonne 1 (gauche) Titre colonne 2 (centr\u00e9) Titre colonne 3 (centr\u00e9) Celule 1.1 Celule 1.2 Celule 1.3 Celule 2.1 Celule 2.2 Celule 2.3","title":" Tableaux"},{"location":"jupyter/memomd/#code","text":"","title":" Code"},{"location":"jupyter/memomd/#code-en-ligne","text":"Markdown insertion de code en ligne : `print(\"Hello World!\")` HTML < p > insertion de code en ligne : < code > print(\"Hello World!\") </ code ></ p > Aper\u00e7u insertion de code en ligne : print(\"Hello World!\")","title":" Code en ligne"},{"location":"jupyter/memomd/#bloc-de-code","text":"Markdown ```python print ( \"Hello World!\" ) ``` HTML < pre > print(\"Hello World!\") </ pre > Aper\u00e7u print ( \"Hello World!\" )","title":" Bloc de code"},{"location":"jupyter/memomd/#boites-colorees-dans-un-notebook-jupyter","text":"Markdown/HTML < div class = \"alert alert-block alert-info\" > Boite bleue </ div > < div class = \"alert alert-block alert-success\" > Boite verte </ div > < div class = \"alert alert-block alert-warning\" > Boite jaune </ div > < div class = \"alert alert-block alert-danger\" > Boite rouge </ div > Aper\u00e7u","title":" Boites color\u00e9es dans un notebook Jupyter"},{"location":"jupyter/memomd/#formules-latex-mathjax","text":"Markdown Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : $x^2 + 3x -7 = 0$ Mode bloc (display) : On trouve : $$x = \\frac{-3 \\pm \\sqrt{37}}{2}$$ Aper\u00e7u Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : x^2 + 3x -7 = 0 x^2 + 3x -7 = 0 Mode bloc (display) : On trouve : x = \\frac{-3 \\pm \\sqrt{37}}{2} x = \\frac{-3 \\pm \\sqrt{37}}{2}","title":" Formules LaTeX (MathJax)"},{"location":"jupyter/memomd/#caracteres-specifiques","text":"","title":" Caract\u00e8res sp\u00e9cifiques"},{"location":"jupyter/memomd/#tirets","text":"Il n'y a pas de balise Markdown sp\u00e9cifique pour r\u00e9aliser des tirets cadratins ou demi-cadratins. On utilise des balises HTML pour cr\u00e9er ces tirets. tiret long ou tiret cadratin : HTML &mdash; Aper\u00e7u \u2014 tiret moyen ou tiret demi-cadratin HTML &ndash; Aper\u00e7u \u2013","title":" Tirets"},{"location":"jupyter/memomd/#touches-clavier","text":"Markdown <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> Aper\u00e7u Ctrl + Alt + Del","title":" Touches clavier"},{"location":"jupyter/memomd/#notes-de-bas-de-page","text":"Markdown Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page[^a]. Et une autre[^b]. On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois[^b]. [ ^a ]: Les notes de bas de page peuvent \u00eatre **mises en forme**, et sur plusieurs lignes. [ ^b ]: Autre note de bas de page. Aper\u00e7u : Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page 1 . Et une autre 2 . On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois 2 . Les notes de bas de page peuvent \u00eatre mises en forme , et sur plusieurs lignes. \u21a9 Autre note de bas de page. \u21a9 \u21a9","title":" Notes de bas de page"},{"location":"jupyter/notebooks/","text":"Quelques notebooks Les liens suivants ouvriront les notebooks vis\u00e9s dans basthon.fr . Positionner des milieux Positionner des centres de gravit\u00e9 Lumi\u00e8re !","title":"Notebooks"},{"location":"jupyter/notebooks/#quelques-notebooks","text":"Les liens suivants ouvriront les notebooks vis\u00e9s dans basthon.fr . Positionner des milieux Positionner des centres de gravit\u00e9 Lumi\u00e8re !","title":"Quelques notebooks"},{"location":"jupyter/p5/","text":"Utiliser la biblioth\u00e8que p5 dans un notebook Jupyter Lien vers un m\u00e9mo p5 qui donne quelques instructions utilisables dans p5 sur basthon.fr.","title":"p5"},{"location":"jupyter/p5/#utiliser-la-bibliotheque-p5-dans-un-notebook-jupyter","text":"Lien vers un m\u00e9mo p5 qui donne quelques instructions utilisables dans p5 sur basthon.fr.","title":"Utiliser la biblioth\u00e8que p5 dans un notebook Jupyter"},{"location":"microbit/decouvrir_microbit/","text":"La carte micro:bit Qu'est-ce qu'une carte micro:bit ? La carte BBC micro:bit est une carte micro-contr\u00f4leur de 5 cm sur 4 cm, qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Description des composants Elle comporte \u00e0 l'avant: 25 LEDs rouges, programmables pour afficher du texte qui d\u00e9file ou des images ; elles sont aussi des capteurs de lumi\u00e8re deux boutons poussoirs A et B programmables, des broches de connexion. Et \u00e0 l'arri\u00e8re : une antenne radio et bluetooth, un micro-processeur et capteur de temp\u00e9rature, un magn\u00e9tom\u00e8tre (boussole) permettant de mesurer des champs magn\u00e9tiques, un acc\u00e9l\u00e9rom\u00e8tre permettant de capter des mouvements en trois dimensions. Il d\u00e9termine le tangage, le roulis et le lacet. des broches de connexion pour contr\u00f4ler des composants externes un port micro-USB permettant d'alimenter la carte et de transf\u00e9rer des programmes, une led qui sert de t\u00e9moin lumineux pour l'alimentation de la carte ou le t\u00e9l\u00e9chargement de programme, un bouton de r\u00e9initialisation, un connecteur d'alimentation (2 piles AAA - 3V), une puce d'interface USB. La version 2, distribu\u00e9e \u00e0 partir de fin 2020, comporte \u00e9galement un micro et un haut-parleur. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles. Calibrer la boussole Lors de l'usage de certaines fonctionnalit\u00e9s de la carte comme la boussole, un calibrage est n\u00e9cessaire. Le message TILT TO FILL SCREEN d\u00e9file \u00e0 l'\u00e9cran et le pixel central clignote. En inclinant la carte, ce pixel semble se d\u00e9placer comme sous l'effet de la pesanteur, en allumant toutes les leds rencontr\u00e9es sur son chemin. Incliner la micro:bit dans tous les sens jusqu\u2019\u00e0 ce que les leds du panneau d'affichage soient toutes allum\u00e9es. D\u00e9monstration en vid\u00e9o Programmer la carte micro:bit Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages, dans un navigateur ou \u00e0 l'aide d'un logiciel install\u00e9. Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Ce site propose des exemples : - de programmation par blocs avec MakeCode - de programmation par blocs avec Scratch - de programmation Python avec l'\u00e9diteur Python en ligne ou Mu Mettre \u00e0 jour le firmware de la carte micro:bit Le firmware est un logiciel qui est physiquement stock\u00e9 dans la puce de la carte micro:bit mais qui n'est pas modifi\u00e9 lors de l'\u00e9criture de programmes ou lorsque la carte micro:bit est \u00e9teinte. Il est possible de mettre \u00e0 jour le firmware pour utiliser de nouvelles fonctionnalit\u00e9s telles que WebUSB. Conna\u00eetre la version du firmware install\u00e9 Pour conna\u00eetre la version du firmware install\u00e9 sur une carte micro:bit, connecter la carte \u00e0 l'aide du c\u00e2ble USB \u00e0 un ordianateur : elle appara\u00eet dans le gestionnaire de fichiers sous le nom MICROBIT. Ouvrir le fichier DETAILS.TXT du lecteur MICROBIT et rechercher le num\u00e9ro sur la ligne qui commence par \u00ab Interface Version \u00bb. Comment mettre \u00e0 jour le firmware ? D\u00e9connecter le c\u00e2ble USB et la batterie de la carte micro:bit. Maintenir le bouton de r\u00e9initialisation \u00e0 l'arri\u00e8re la carte tout en connectant la carte \u00e0 un ordinateur \u00e0 l'aide du c\u00e2ble USB. Un lecteur devrait appara\u00eetre dans le gestionnaire de fichiers appel\u00e9 MAINTENANCE (au lieu de MICROBIT). T\u00e9l\u00e9charger le fichier .hex de cette page sur votre ordinateur. Faire glisser et d\u00e9poser le nouveau fichier .hex du firmware sur le lecteur MAINTENANCE et attendre que le voyant orange \u00e0 l'arri\u00e8re de la carte cesse de clignoter. Lorsque la mise \u00e0 niveau est termin\u00e9e, la carte micro:bit se r\u00e9initialise, s\u2019\u00e9jecte de l\u2019ordinateur et r\u00e9appara\u00eet sous le nom MICROBIT habituel. En consultant le fichier DETAILS.TXT qui se trouve sur le lecteur MICROBIT on peut s'assurer que le firmware a le m\u00eame num\u00e9ro de version que celle qui a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9e. Utiliser la fonctionnalit\u00e9 WebUSB Le transfert de programme se fait g\u00e9n\u00e9ralement en t\u00e9l\u00e9chargeant le fichier .hex du programme, puis en le copiant sur la carte. Avec un navigateur Web r\u00e9cent, on peut envoyer ses programmes directement \u00e0 la carte micro:bit \u00e0 partir des \u00e9diteurs MakeCode et Python sans avoir \u00e0 t\u00e9l\u00e9charger, faire glisser et d\u00e9poser des fichiers .hex . Le t\u00e9l\u00e9chargement direct fait gagner du temps et simplifie la mise \u00e0 jour du code sur la carte. Il utilise un processus appel\u00e9 WebUSB, qui \u00e9tablit une connexion entre le navigateur ou l'application et la carte micro:bit via le c\u00e2ble USB. Pour utiliser cette fonctionnalit\u00e9, utiliser un navigateur bas\u00e9 sur Chrome, et une carte micro:bit dont la version de firmware est au moins 243 (si besoin, mettre \u00e0 jour le firmware de la carte). Lorsque cette fonctionnalit\u00e9 est disponible, le navigateur vous proposer de connecter (ou appairer) la carte. Une fois la connexion \u00e9tablie, le t\u00e9l\u00e9chargement direct en un clic est possible. R\u00e9f\u00e9rences R\u00e9f\u00e9rences le site de la fondation micro:bit le site de documentation technique de la carte l'article micro:bit sur wikipedia la page d\u00e9di\u00e9e \u00e0 micro:bit sur le site de la C2ITice","title":"La carte micro:bit"},{"location":"microbit/decouvrir_microbit/#la-carte-microbit","text":"","title":"La carte micro:bit"},{"location":"microbit/decouvrir_microbit/#quest-ce-quune-carte-microbit","text":"La carte BBC micro:bit est une carte micro-contr\u00f4leur de 5 cm sur 4 cm, qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el.","title":"Qu'est-ce qu'une carte micro:bit ?"},{"location":"microbit/decouvrir_microbit/#description-des-composants","text":"Elle comporte \u00e0 l'avant: 25 LEDs rouges, programmables pour afficher du texte qui d\u00e9file ou des images ; elles sont aussi des capteurs de lumi\u00e8re deux boutons poussoirs A et B programmables, des broches de connexion. Et \u00e0 l'arri\u00e8re : une antenne radio et bluetooth, un micro-processeur et capteur de temp\u00e9rature, un magn\u00e9tom\u00e8tre (boussole) permettant de mesurer des champs magn\u00e9tiques, un acc\u00e9l\u00e9rom\u00e8tre permettant de capter des mouvements en trois dimensions. Il d\u00e9termine le tangage, le roulis et le lacet. des broches de connexion pour contr\u00f4ler des composants externes un port micro-USB permettant d'alimenter la carte et de transf\u00e9rer des programmes, une led qui sert de t\u00e9moin lumineux pour l'alimentation de la carte ou le t\u00e9l\u00e9chargement de programme, un bouton de r\u00e9initialisation, un connecteur d'alimentation (2 piles AAA - 3V), une puce d'interface USB. La version 2, distribu\u00e9e \u00e0 partir de fin 2020, comporte \u00e9galement un micro et un haut-parleur. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles.","title":"Description des composants"},{"location":"microbit/decouvrir_microbit/#calibrer-la-boussole","text":"Lors de l'usage de certaines fonctionnalit\u00e9s de la carte comme la boussole, un calibrage est n\u00e9cessaire. Le message TILT TO FILL SCREEN d\u00e9file \u00e0 l'\u00e9cran et le pixel central clignote. En inclinant la carte, ce pixel semble se d\u00e9placer comme sous l'effet de la pesanteur, en allumant toutes les leds rencontr\u00e9es sur son chemin. Incliner la micro:bit dans tous les sens jusqu\u2019\u00e0 ce que les leds du panneau d'affichage soient toutes allum\u00e9es. D\u00e9monstration en vid\u00e9o","title":"Calibrer la boussole"},{"location":"microbit/decouvrir_microbit/#programmer-la-carte-microbit","text":"Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages, dans un navigateur ou \u00e0 l'aide d'un logiciel install\u00e9. Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Ce site propose des exemples : - de programmation par blocs avec MakeCode - de programmation par blocs avec Scratch - de programmation Python avec l'\u00e9diteur Python en ligne ou Mu","title":"Programmer la carte micro:bit"},{"location":"microbit/decouvrir_microbit/#mettre-a-jour-le-firmware-de-la-carte-microbit","text":"Le firmware est un logiciel qui est physiquement stock\u00e9 dans la puce de la carte micro:bit mais qui n'est pas modifi\u00e9 lors de l'\u00e9criture de programmes ou lorsque la carte micro:bit est \u00e9teinte. Il est possible de mettre \u00e0 jour le firmware pour utiliser de nouvelles fonctionnalit\u00e9s telles que WebUSB.","title":"Mettre \u00e0 jour le firmware de la carte micro:bit"},{"location":"microbit/decouvrir_microbit/#connaitre-la-version-du-firmware-installe","text":"Pour conna\u00eetre la version du firmware install\u00e9 sur une carte micro:bit, connecter la carte \u00e0 l'aide du c\u00e2ble USB \u00e0 un ordianateur : elle appara\u00eet dans le gestionnaire de fichiers sous le nom MICROBIT. Ouvrir le fichier DETAILS.TXT du lecteur MICROBIT et rechercher le num\u00e9ro sur la ligne qui commence par \u00ab Interface Version \u00bb.","title":"Conna\u00eetre la version du firmware install\u00e9"},{"location":"microbit/decouvrir_microbit/#comment-mettre-a-jour-le-firmware","text":"D\u00e9connecter le c\u00e2ble USB et la batterie de la carte micro:bit. Maintenir le bouton de r\u00e9initialisation \u00e0 l'arri\u00e8re la carte tout en connectant la carte \u00e0 un ordinateur \u00e0 l'aide du c\u00e2ble USB. Un lecteur devrait appara\u00eetre dans le gestionnaire de fichiers appel\u00e9 MAINTENANCE (au lieu de MICROBIT). T\u00e9l\u00e9charger le fichier .hex de cette page sur votre ordinateur. Faire glisser et d\u00e9poser le nouveau fichier .hex du firmware sur le lecteur MAINTENANCE et attendre que le voyant orange \u00e0 l'arri\u00e8re de la carte cesse de clignoter. Lorsque la mise \u00e0 niveau est termin\u00e9e, la carte micro:bit se r\u00e9initialise, s\u2019\u00e9jecte de l\u2019ordinateur et r\u00e9appara\u00eet sous le nom MICROBIT habituel. En consultant le fichier DETAILS.TXT qui se trouve sur le lecteur MICROBIT on peut s'assurer que le firmware a le m\u00eame num\u00e9ro de version que celle qui a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9e.","title":"Comment mettre \u00e0 jour le firmware ?"},{"location":"microbit/decouvrir_microbit/#utiliser-la-fonctionnalite-webusb","text":"Le transfert de programme se fait g\u00e9n\u00e9ralement en t\u00e9l\u00e9chargeant le fichier .hex du programme, puis en le copiant sur la carte. Avec un navigateur Web r\u00e9cent, on peut envoyer ses programmes directement \u00e0 la carte micro:bit \u00e0 partir des \u00e9diteurs MakeCode et Python sans avoir \u00e0 t\u00e9l\u00e9charger, faire glisser et d\u00e9poser des fichiers .hex . Le t\u00e9l\u00e9chargement direct fait gagner du temps et simplifie la mise \u00e0 jour du code sur la carte. Il utilise un processus appel\u00e9 WebUSB, qui \u00e9tablit une connexion entre le navigateur ou l'application et la carte micro:bit via le c\u00e2ble USB. Pour utiliser cette fonctionnalit\u00e9, utiliser un navigateur bas\u00e9 sur Chrome, et une carte micro:bit dont la version de firmware est au moins 243 (si besoin, mettre \u00e0 jour le firmware de la carte). Lorsque cette fonctionnalit\u00e9 est disponible, le navigateur vous proposer de connecter (ou appairer) la carte. Une fois la connexion \u00e9tablie, le t\u00e9l\u00e9chargement direct en un clic est possible.","title":"Utiliser la fonctionnalit\u00e9 WebUSB"},{"location":"microbit/decouvrir_microbit/#references","text":"R\u00e9f\u00e9rences le site de la fondation micro:bit le site de documentation technique de la carte l'article micro:bit sur wikipedia la page d\u00e9di\u00e9e \u00e0 micro:bit sur le site de la C2ITice","title":"R\u00e9f\u00e9rences"},{"location":"microbit/makecode/","text":"Programmer la carte avec l'\u00e9diteur Blocs de MakeCode pour micro:bit Interface de programmation par blocs Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Le simulateur affiche le fonctionnement du programme. Le simulateur L'interface MakeCode dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et d'effectuer les premi\u00e8res corrections. Les donn\u00e9es des capteurs peuvent \u00eatre simul\u00e9es \u00e9galement, avec des curseurs manipulables \u00e0 la souris, et on peut simuler le fait de secouer la carte. Sauvegarder son programme Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. M\u00e9thode classique Le programme r\u00e9alis\u00e9 est \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Lui donner un nom puis cliquer sur T\u00e9l\u00e9charger . Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder dans ses documents personnels pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Lorsque la carte est connect\u00e9e \u00e0 l'ordinateur par port USB elle appara\u00eet sous le nom MICROBIT. Aucun pilote n'est n\u00e9cessaire. Copier-coller le programme .hex t\u00e9l\u00e9charg\u00e9 sur la carte : une led orange clignote pendant le chargement. Apr\u00e8s le transfert, la carte micro:bit s\u2019\u00e9jecte de l\u2019ordinateur puis se reconnecte. Le fichier t\u00e9l\u00e9charg\u00e9 n'apparait pas sur la carte dans le gestionnaire de fichiers comme sur une cl\u00e9 USB, mais le programme doit s'ex\u00e9cuter directement sur la carte apr\u00e8s le transfert. M\u00e9thode WebUSB Depuis la version 243 du firmware , les navigateurs bas\u00e9s sur Chrome (versions 65 et +) proposent d' appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB . Le mode Debug Ce mode s'active en cliquant sur l'ic\u00f4ne . Il permet : - d'ex\u00e9cuter le programme pas \u00e0 pas ou au ralenti, en mettant en \u00e9vidence l'instruction ex\u00e9cut\u00e9e - de placer des points d'arr\u00eat dans le programme : lorsqu'une instruction marqu\u00e9e d'un point est sur le point d'\u00eatre ex\u00e9cut\u00e9e, le programme s'interrompt -d'afficher les valeurs des variables. Il est tr\u00e8s utile pour d\u00e9celer les bugs d'un programme ou pour expliquer le fonctionnement d'un programme correct. Le mode Multi Ce mode permet l'affichage de deux interfaces de programmation : il est tr\u00e8s utile pour connecter et programmer deux cartes avec des programmes diff\u00e9rents. Par exemple, si une carte doit \u00e9mettre un signal radio et une autre le r\u00e9ceptionner. Lors de l'appairage des cartes, les identifiants complets des cartes sont affich\u00e9s pour les diff\u00e9rencier. R\u00e9f\u00e9rences Cliquer sur les logos pour acc\u00e9der \u00e0 la documentation micro:bit sur chaque type de blocs. Type de blocs Exemple de blocs montrer nombre , montrer LEDs , montrer l'ic\u00f4ne , afficher texte , effacer l'\u00e9cran , toujours , au d\u00e9marrage , pause , montrer la fl\u00e8che . lorsque le bouton A est press\u00e9 , lorsque secouer , lorsque la broche P0 est activ\u00e9e , bouton A press\u00e9 , acc\u00e9l\u00e9ration , niveau d'intensit\u00e9 lumineuse , direction de la boussole , temp\u00e9rature , etc. jouer la m\u00e9lodie , jouer ton , buzz , etc. allumer x y , activer/d\u00e9sactiver x y , \u00e9teindre , tracer le graphe , etc. d\u00e9finir radio groupe , envoyer le nombre par radio , envoyer la chaine par radio , envoyer la valeur par radio , quand une donn\u00e9e est re\u00e7ue par radio , etc. r\u00e9p\u00e9ter n fois , tant que , pour index variant de 0 \u00e0 4 , pour l'\u00e9l\u00e9ment valeur de list , etc. si \u2026 alors \u2026 , si \u2026 alors \u2026 sinon , comparaisons, et , ou , non , etc. cr\u00e9er une variable , etc. + , \u2014 , x , \u00f7 , reste , min , max , choisir au hasard , etc.","title":"G\u00e9n\u00e9ralit\u00e9s"},{"location":"microbit/makecode/#programmer-la-carte-avec-lediteur-blocs-de-makecode-pour-microbit","text":"","title":"Programmer la carte avec l'\u00e9diteur Blocs de MakeCode pour micro:bit"},{"location":"microbit/makecode/#interface-de-programmation-par-blocs","text":"Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Le simulateur affiche le fonctionnement du programme.","title":"Interface de programmation par blocs"},{"location":"microbit/makecode/#le-simulateur","text":"L'interface MakeCode dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et d'effectuer les premi\u00e8res corrections. Les donn\u00e9es des capteurs peuvent \u00eatre simul\u00e9es \u00e9galement, avec des curseurs manipulables \u00e0 la souris, et on peut simuler le fait de secouer la carte.","title":"Le simulateur"},{"location":"microbit/makecode/#sauvegarder-son-programme","text":"Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut.","title":"Sauvegarder son programme"},{"location":"microbit/makecode/#methode-classique","text":"Le programme r\u00e9alis\u00e9 est \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Lui donner un nom puis cliquer sur T\u00e9l\u00e9charger . Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder dans ses documents personnels pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Lorsque la carte est connect\u00e9e \u00e0 l'ordinateur par port USB elle appara\u00eet sous le nom MICROBIT. Aucun pilote n'est n\u00e9cessaire. Copier-coller le programme .hex t\u00e9l\u00e9charg\u00e9 sur la carte : une led orange clignote pendant le chargement. Apr\u00e8s le transfert, la carte micro:bit s\u2019\u00e9jecte de l\u2019ordinateur puis se reconnecte. Le fichier t\u00e9l\u00e9charg\u00e9 n'apparait pas sur la carte dans le gestionnaire de fichiers comme sur une cl\u00e9 USB, mais le programme doit s'ex\u00e9cuter directement sur la carte apr\u00e8s le transfert.","title":"M\u00e9thode classique"},{"location":"microbit/makecode/#methode-webusb","text":"Depuis la version 243 du firmware , les navigateurs bas\u00e9s sur Chrome (versions 65 et +) proposent d' appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB .","title":"M\u00e9thode WebUSB"},{"location":"microbit/makecode/#le-mode-debug","text":"Ce mode s'active en cliquant sur l'ic\u00f4ne . Il permet : - d'ex\u00e9cuter le programme pas \u00e0 pas ou au ralenti, en mettant en \u00e9vidence l'instruction ex\u00e9cut\u00e9e - de placer des points d'arr\u00eat dans le programme : lorsqu'une instruction marqu\u00e9e d'un point est sur le point d'\u00eatre ex\u00e9cut\u00e9e, le programme s'interrompt -d'afficher les valeurs des variables. Il est tr\u00e8s utile pour d\u00e9celer les bugs d'un programme ou pour expliquer le fonctionnement d'un programme correct.","title":"Le mode Debug"},{"location":"microbit/makecode/#le-mode-multi","text":"Ce mode permet l'affichage de deux interfaces de programmation : il est tr\u00e8s utile pour connecter et programmer deux cartes avec des programmes diff\u00e9rents. Par exemple, si une carte doit \u00e9mettre un signal radio et une autre le r\u00e9ceptionner. Lors de l'appairage des cartes, les identifiants complets des cartes sont affich\u00e9s pour les diff\u00e9rencier.","title":"Le mode Multi"},{"location":"microbit/makecode/#references","text":"Cliquer sur les logos pour acc\u00e9der \u00e0 la documentation micro:bit sur chaque type de blocs. Type de blocs Exemple de blocs montrer nombre , montrer LEDs , montrer l'ic\u00f4ne , afficher texte , effacer l'\u00e9cran , toujours , au d\u00e9marrage , pause , montrer la fl\u00e8che . lorsque le bouton A est press\u00e9 , lorsque secouer , lorsque la broche P0 est activ\u00e9e , bouton A press\u00e9 , acc\u00e9l\u00e9ration , niveau d'intensit\u00e9 lumineuse , direction de la boussole , temp\u00e9rature , etc. jouer la m\u00e9lodie , jouer ton , buzz , etc. allumer x y , activer/d\u00e9sactiver x y , \u00e9teindre , tracer le graphe , etc. d\u00e9finir radio groupe , envoyer le nombre par radio , envoyer la chaine par radio , envoyer la valeur par radio , quand une donn\u00e9e est re\u00e7ue par radio , etc. r\u00e9p\u00e9ter n fois , tant que , pour index variant de 0 \u00e0 4 , pour l'\u00e9l\u00e9ment valeur de list , etc. si \u2026 alors \u2026 , si \u2026 alors \u2026 sinon , comparaisons, et , ou , non , etc. cr\u00e9er une variable , etc. + , \u2014 , x , \u00f7 , reste , min , max , choisir au hasard , etc.","title":"R\u00e9f\u00e9rences"},{"location":"microbit/mc_radio/","text":"Un parcours pour d\u00e9couvrir la fonctionnalit\u00e9 radio Le mode Multi Ce mode permet l'affichage de deux interfaces de programmation : il est tr\u00e8s utile pour connecter et programmer deux cartes avec des programmes diff\u00e9rents. Par exemple, si une carte doit \u00e9mettre un signal radio et une autre le r\u00e9ceptionner.","title":"Parcours Radio"},{"location":"microbit/mc_radio/#un-parcours-pour-decouvrir-la-fonctionnalite-radio","text":"","title":"Un parcours pour d\u00e9couvrir la fonctionnalit\u00e9 radio"},{"location":"microbit/mc_radio/#le-mode-multi","text":"Ce mode permet l'affichage de deux interfaces de programmation : il est tr\u00e8s utile pour connecter et programmer deux cartes avec des programmes diff\u00e9rents. Par exemple, si une carte doit \u00e9mettre un signal radio et une autre le r\u00e9ceptionner.","title":"Le mode Multi"},{"location":"microbit/python_accelerometre/","text":"L'acc\u00e9l\u00e9rom\u00e8tre L'acc\u00e9lerom\u00e8tre La carte micro:bit comporte un acc\u00e9l\u00e9rom\u00e8tre, d\u00e9sign\u00e9 par accelerometer . Il permet de conna\u00eetre l'orientation de la carte selon 3 axes : x , l\u2019inclinaison de gauche \u00e0 droite (roulis), y , l\u2019inclinaison d\u2019avant en arri\u00e8re (tangage), z , le mouvement haut et bas. Instructions Effet accelerometer.get_x() affiche une valeur d'inclinaison gauche - droite accelerometer.get_y() affiche une valeur d'inclinaison avant - arri\u00e8re accelerometer.get_z() affiche la mesure de l'acc\u00e9l\u00e9ration selon l'axe z accelerometer.get_values() affiche un triplet ( tuple ) des 3 mesures selon x , y , et z . Les gestes Gr\u00e2ce \u00e0 l'acc\u00e9l\u00e9rom\u00e8tre, la carte micro:bit reconna\u00eet les mouvements qu'elle subit ainsi que son orientation. Elle peut d\u00e9tecter les gestes suivants : up, down, left, right, face up, face down, freefall, 3g, 6g, 8g, shake Instructions Effet accelerometer.current_gesture() Renvoie le nom du geste actuel accelerometer.is_gesture(nom) Vaut True si nom correspond au geste actuel accelerometer.was_gesture(nom) Vaut True si le geste nom a \u00e9t\u00e9 activ\u00e9 depuis le dernier appel accelerometer.get_gestures() Renvoie un p-uplet ( tuple ) contenant l'historique des gestes activ\u00e9s depuis le dernier appel Exemple from microbit import * while True : if ( accelerometer . current_gesture () == 'up' ): display . show ( Image . ARROW_N ) elif ( accelerometer . current_gesture () == 'down' ): display . show ( Image . ARROW_S ) elif ( accelerometer . current_gesture () == 'left' ): display . show ( Image . ARROW_E ) elif ( accelerometer . current_gesture () == 'right' ): display . show ( Image . ARROW_W ) else : display . clear () sleep ( 100 ) Lorsqu'on ex\u00e9cute ce programme, une fl\u00e8che d\u00e9signe le c\u00f4t\u00e9 de la carte tourn\u00e9 vers le haut. Si la carte est pos\u00e9e \"\u00e0 plat\" aucun affichage n'est r\u00e9alis\u00e9. R\u00e9f\u00e9rences Gestes La classe Accelerometer","title":"L'acc\u00e9l\u00e9rom\u00e8tre"},{"location":"microbit/python_accelerometre/#laccelerometre","text":"","title":"L'acc\u00e9l\u00e9rom\u00e8tre"},{"location":"microbit/python_accelerometre/#laccelerometre_1","text":"La carte micro:bit comporte un acc\u00e9l\u00e9rom\u00e8tre, d\u00e9sign\u00e9 par accelerometer . Il permet de conna\u00eetre l'orientation de la carte selon 3 axes : x , l\u2019inclinaison de gauche \u00e0 droite (roulis), y , l\u2019inclinaison d\u2019avant en arri\u00e8re (tangage), z , le mouvement haut et bas. Instructions Effet accelerometer.get_x() affiche une valeur d'inclinaison gauche - droite accelerometer.get_y() affiche une valeur d'inclinaison avant - arri\u00e8re accelerometer.get_z() affiche la mesure de l'acc\u00e9l\u00e9ration selon l'axe z accelerometer.get_values() affiche un triplet ( tuple ) des 3 mesures selon x , y , et z .","title":"L'acc\u00e9lerom\u00e8tre"},{"location":"microbit/python_accelerometre/#les-gestes","text":"Gr\u00e2ce \u00e0 l'acc\u00e9l\u00e9rom\u00e8tre, la carte micro:bit reconna\u00eet les mouvements qu'elle subit ainsi que son orientation. Elle peut d\u00e9tecter les gestes suivants : up, down, left, right, face up, face down, freefall, 3g, 6g, 8g, shake Instructions Effet accelerometer.current_gesture() Renvoie le nom du geste actuel accelerometer.is_gesture(nom) Vaut True si nom correspond au geste actuel accelerometer.was_gesture(nom) Vaut True si le geste nom a \u00e9t\u00e9 activ\u00e9 depuis le dernier appel accelerometer.get_gestures() Renvoie un p-uplet ( tuple ) contenant l'historique des gestes activ\u00e9s depuis le dernier appel","title":"Les gestes"},{"location":"microbit/python_accelerometre/#exemple","text":"from microbit import * while True : if ( accelerometer . current_gesture () == 'up' ): display . show ( Image . ARROW_N ) elif ( accelerometer . current_gesture () == 'down' ): display . show ( Image . ARROW_S ) elif ( accelerometer . current_gesture () == 'left' ): display . show ( Image . ARROW_E ) elif ( accelerometer . current_gesture () == 'right' ): display . show ( Image . ARROW_W ) else : display . clear () sleep ( 100 ) Lorsqu'on ex\u00e9cute ce programme, une fl\u00e8che d\u00e9signe le c\u00f4t\u00e9 de la carte tourn\u00e9 vers le haut. Si la carte est pos\u00e9e \"\u00e0 plat\" aucun affichage n'est r\u00e9alis\u00e9.","title":"Exemple"},{"location":"microbit/python_accelerometre/#references","text":"Gestes La classe Accelerometer","title":"R\u00e9f\u00e9rences"},{"location":"microbit/python_boutons/","text":"Les boutons Les boutons La carte micro:bit comporte deux boutons, nomm\u00e9s button_a et button_b . D\u00e9tecter l'appui sur un bouton La m\u00e9thode is_pressed() permet de savoir si un bouton est press\u00e9 au moment o\u00f9 la m\u00e9thode est invoqu\u00e9e. Instructions Effet button_a.is_pressed() Vaut True si le bouton A est appuy\u00e9, False sinon D\u00e9tecter si un bouton a \u00e9t\u00e9 appuy\u00e9 Il est utile d'avoir recours \u00e0 la m\u00e9thode was_pressed() pour savoir si un bouton a \u00e9t\u00e9 actionn\u00e9 pendant que le programme \u00e9tait occup\u00e9 \u00e0 une autre t\u00e2che. Instructions Effet button_a.was_pressed() Vaut True si le bouton A a \u00e9t\u00e9 appuy\u00e9, False sinon Compter les appuis Instructions Effet button_a.get_presses() Renvoie le nombre d'appuis sur le bouton A et remet \u00e0 z\u00e9ro le compteur d'appuis Exemple from microbit import * while True : if button_a . is_pressed (): display . show ( Image . YES ) elif button_b . is_pressed (): display . show ( Image . NO ) else : display . clear () Lorsqu'on ex\u00e9cute ce programme : l'image YES s'affiche lorsque l'on appuie sur le bouton A mais dispara\u00eet si on le rel\u00e2che l'image NO s'affiche lorsque l'on appuie sur le bouton B mais dispara\u00eet si on le rel\u00e2che les pixels sont tous \u00e9teints si l'on n'appuie sur aucun bouton. R\u00e9f\u00e9rences La classe Button","title":"Les boutons"},{"location":"microbit/python_boutons/#les-boutons","text":"","title":"Les boutons"},{"location":"microbit/python_boutons/#les-boutons_1","text":"La carte micro:bit comporte deux boutons, nomm\u00e9s button_a et button_b .","title":"Les boutons"},{"location":"microbit/python_boutons/#detecter-lappui-sur-un-bouton","text":"La m\u00e9thode is_pressed() permet de savoir si un bouton est press\u00e9 au moment o\u00f9 la m\u00e9thode est invoqu\u00e9e. Instructions Effet button_a.is_pressed() Vaut True si le bouton A est appuy\u00e9, False sinon","title":"D\u00e9tecter l'appui sur un bouton"},{"location":"microbit/python_boutons/#detecter-si-un-bouton-a-ete-appuye","text":"Il est utile d'avoir recours \u00e0 la m\u00e9thode was_pressed() pour savoir si un bouton a \u00e9t\u00e9 actionn\u00e9 pendant que le programme \u00e9tait occup\u00e9 \u00e0 une autre t\u00e2che. Instructions Effet button_a.was_pressed() Vaut True si le bouton A a \u00e9t\u00e9 appuy\u00e9, False sinon","title":"D\u00e9tecter si un bouton a \u00e9t\u00e9 appuy\u00e9"},{"location":"microbit/python_boutons/#compter-les-appuis","text":"Instructions Effet button_a.get_presses() Renvoie le nombre d'appuis sur le bouton A et remet \u00e0 z\u00e9ro le compteur d'appuis","title":"Compter les appuis"},{"location":"microbit/python_boutons/#exemple","text":"from microbit import * while True : if button_a . is_pressed (): display . show ( Image . YES ) elif button_b . is_pressed (): display . show ( Image . NO ) else : display . clear () Lorsqu'on ex\u00e9cute ce programme : l'image YES s'affiche lorsque l'on appuie sur le bouton A mais dispara\u00eet si on le rel\u00e2che l'image NO s'affiche lorsque l'on appuie sur le bouton B mais dispara\u00eet si on le rel\u00e2che les pixels sont tous \u00e9teints si l'on n'appuie sur aucun bouton.","title":"Exemple"},{"location":"microbit/python_boutons/#references","text":"La classe Button","title":"R\u00e9f\u00e9rences"},{"location":"microbit/python_decouverte/","text":"Parcours de d\u00e9couverte : atteindre le niveau ! led acc\u00e9l\u00e9rom\u00e8tre Objectif Ce parcours combine des instructions d'affichage d'images, de mesure du niveau de lumi\u00e8re, de d\u00e9tection de mouvements. L'objectif est de d\u00e9couvrir diff\u00e9rents capteurs de la carte et de comprendre et modifier des programmes permettant de d\u00e9tecter une valeur ou un seuil fix\u00e9 pour l'information mesur\u00e9e. Mat\u00e9riel n\u00e9cessaire : une carte micro:bit, une lampe (par exemple celle d'un smartphone), le boitier de piles \u00e0 connecter \u00e0 la carte, un \u00e9lastique en option : capteur de lumi\u00e8re du kit Grove De la lumi\u00e8re ! 1 Afficher une image pr\u00e9d\u00e9finie Voici un premier programme : from microbit import * display . show ( Image . YES ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que constate-t-on ? Remplacer dans le programme le mot YES par l'un des mots suivants : CHESSBOARD - DIAMOND - HAPPY - HEART - NO - SAD - SQUARE Choisir l'une des images et la reproduire sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5. 2 Afficher une image personnalis\u00e9e Saisir ce programme et le flasher sur la carte. Que constate-t-on ? \u00c0 quoi correspondent les 0 et les 9 ? from microbit import * mon_image = Image ( \"90909:\" \"09990:\" \"99999:\" \"09990:\" \"90909\" ) display . show ( Image . mon_image ) Dessiner sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5 une image personnelle et modifier le programme pr\u00e9c\u00e9dent pour la faire appara\u00eetre sur la carte micro:bit. 3 D\u00e9tecter l'intensit\u00e9 lumineuse Les LED de la carte peuvent d\u00e9tecter le niveau de lumi\u00e8re ambiante : la fonction display.read_light_level() renvoie une valeur comprise entre 0 et 255 : plus la valeur est \u00e9lev\u00e9e, plus l'environnement est lumineux. from microbit import * while True : niveau = display . read_light_level () if niveau > 220 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 200 ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que faut-il faire pour que l'image Image.YES s'affiche ? Modifier ce programme pour que la carte affiche un carr\u00e9 en luminosit\u00e9 \"normale\" et un diamant dans la p\u00e9nombre. 4 Option : avec un d\u00e9tecteur de lumi\u00e8re Grove Placer la carte micro-bit sur le shield Grove et connecter le d\u00e9tecteur de lumi\u00e8re sur la broche P0-P14. Ce capteur renvoie sur la broche sur laquelle il est connect\u00e9 une tension proportionnelle \u00e0 l'intensit\u00e9 lumineuse. Par exemple, si le capteur est connect\u00e9 sur la broche P0, la fonction pin0.read_analog() renvoie une valeur enti\u00e8re d'autant plus \u00e9lev\u00e9e que l'environnement est lumineux. Saisir et flasher le programme suivant : from microbit import * while True : mesure = pin0 . read_analog () if mesure > 600 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 100 ) Que peut-on faire pour que l'image Image.NO s'affiche sur la carte micro:bit ? Emballer le capteur (connect\u00e9 \u00e0 la carte) dans une feuille de papier. Modifier le programme pour que la carte affiche l'image Image.YES tant que le capteur reste emball\u00e9 et l'image Image.NO d\u00e8s que l'emballage est ouvert. Du mouvement ! 1 D\u00e9tecter une secousse Gr\u00e2ce \u00e0 un acc\u00e9l\u00e9rom\u00e8tre, la carte micro:bit est capable de d\u00e9tecter des gestes, et notamment lorsqu'on la secoue. L'expression accelerometer.is_gesture('shake') vaut True (vrai) lorsque la carte est secou\u00e9e et False (faux) sinon. Lire le programme suivant et d\u00e9crire le comportement que devrait avoir la carte apr\u00e8s l'ex\u00e9cution de ce programme. from microbit import * while True : secoue = accelerometer . is_gesture ( 'shake' ) if secoue : display . show ( Image . YES ) sleep ( 50 ) display . clear () Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. En utilisant les gestes face up et face down d\u00e9tect\u00e9s par l'acc\u00e9l\u00e9rom\u00e8tre, modifier le programme pr\u00e9c\u00e9dent pour que la carte affiche l'image Image.YES lorsqu'elle est tourn\u00e9e vers le plafond, l'image Image.NO lorsqu'elle est tourn\u00e9e vers le sol, et rien dans les autres cas. 2 D\u00e9tecter l'inclinaison de la carte On souhaite d\u00e9placer un pixel sur l'\u00e9cran en fonction des valeurs des inclinaisons gauche-droite et avant-arri\u00e8re de la carte, comme une bille qui se d\u00e9placerait sur un plan inclin\u00e9. On utilise la valeur d\u00e9tect\u00e9e pour accelerometer.get_x() (inclinaison gauche-droite) et accelerometer.get_y() (inclinaison avant-arri\u00e8re) et selon leur valeur, on donne \u00e0 l'abscisse x et \u00e0 l'ordonn\u00e9e y d'un pixel allum\u00e9 la valeur 0, 1, 2, 3 ou 4. Par exemple, voici la valeur donn\u00e9e \u00e0 x selon la valeur de accelerometer.get_x() : Compl\u00e9ter le programme suivant pour qu'il respecte les indications pr\u00e9c\u00e9dentes pour d\u00e9terminer la valeur de x . from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) acc_x = accelerometer . get_x () if acc_x > ... : x = 4 elif acc_x > 200 : x = ... elif acc_x < - 400 : x = ... elif acc_x < ... : x = 1 else : x = ... display . set_pixel ( x , y , 9 ) sleep ( 100 ) Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. Compl\u00e9ter le programme en proc\u00e9dant de fa\u00e7on analogue pour d\u00e9terminer la valeur que doit en prendre l'ordonn\u00e9e du pixel y selon les valeurs de accelerometer.get_y()","title":"Parcours de d\u00e9couverte : atteindre le niveau !"},{"location":"microbit/python_decouverte/#parcours-de-decouverte-atteindre-le-niveau","text":"led acc\u00e9l\u00e9rom\u00e8tre","title":"Parcours de d\u00e9couverte : atteindre le niveau !"},{"location":"microbit/python_decouverte/#objectif","text":"Ce parcours combine des instructions d'affichage d'images, de mesure du niveau de lumi\u00e8re, de d\u00e9tection de mouvements. L'objectif est de d\u00e9couvrir diff\u00e9rents capteurs de la carte et de comprendre et modifier des programmes permettant de d\u00e9tecter une valeur ou un seuil fix\u00e9 pour l'information mesur\u00e9e.","title":" Objectif"},{"location":"microbit/python_decouverte/#materiel-necessaire","text":"une carte micro:bit, une lampe (par exemple celle d'un smartphone), le boitier de piles \u00e0 connecter \u00e0 la carte, un \u00e9lastique en option : capteur de lumi\u00e8re du kit Grove","title":"   Mat\u00e9riel n\u00e9cessaire :"},{"location":"microbit/python_decouverte/#de-la-lumiere","text":"","title":" De la lumi\u00e8re !"},{"location":"microbit/python_decouverte/#1-afficher-une-image-predefinie","text":"Voici un premier programme : from microbit import * display . show ( Image . YES ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que constate-t-on ? Remplacer dans le programme le mot YES par l'un des mots suivants : CHESSBOARD - DIAMOND - HAPPY - HEART - NO - SAD - SQUARE Choisir l'une des images et la reproduire sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5.","title":"  1 Afficher une image pr\u00e9d\u00e9finie"},{"location":"microbit/python_decouverte/#2-afficher-une-image-personnalisee","text":"Saisir ce programme et le flasher sur la carte. Que constate-t-on ? \u00c0 quoi correspondent les 0 et les 9 ? from microbit import * mon_image = Image ( \"90909:\" \"09990:\" \"99999:\" \"09990:\" \"90909\" ) display . show ( Image . mon_image ) Dessiner sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5 une image personnelle et modifier le programme pr\u00e9c\u00e9dent pour la faire appara\u00eetre sur la carte micro:bit.","title":"  2 Afficher une image personnalis\u00e9e"},{"location":"microbit/python_decouverte/#3-detecter-lintensite-lumineuse","text":"Les LED de la carte peuvent d\u00e9tecter le niveau de lumi\u00e8re ambiante : la fonction display.read_light_level() renvoie une valeur comprise entre 0 et 255 : plus la valeur est \u00e9lev\u00e9e, plus l'environnement est lumineux. from microbit import * while True : niveau = display . read_light_level () if niveau > 220 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 200 ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que faut-il faire pour que l'image Image.YES s'affiche ? Modifier ce programme pour que la carte affiche un carr\u00e9 en luminosit\u00e9 \"normale\" et un diamant dans la p\u00e9nombre.","title":"  3 D\u00e9tecter l'intensit\u00e9 lumineuse"},{"location":"microbit/python_decouverte/#4-option-avec-un-detecteur-de-lumiere-grove","text":"Placer la carte micro-bit sur le shield Grove et connecter le d\u00e9tecteur de lumi\u00e8re sur la broche P0-P14. Ce capteur renvoie sur la broche sur laquelle il est connect\u00e9 une tension proportionnelle \u00e0 l'intensit\u00e9 lumineuse. Par exemple, si le capteur est connect\u00e9 sur la broche P0, la fonction pin0.read_analog() renvoie une valeur enti\u00e8re d'autant plus \u00e9lev\u00e9e que l'environnement est lumineux. Saisir et flasher le programme suivant : from microbit import * while True : mesure = pin0 . read_analog () if mesure > 600 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 100 ) Que peut-on faire pour que l'image Image.NO s'affiche sur la carte micro:bit ? Emballer le capteur (connect\u00e9 \u00e0 la carte) dans une feuille de papier. Modifier le programme pour que la carte affiche l'image Image.YES tant que le capteur reste emball\u00e9 et l'image Image.NO d\u00e8s que l'emballage est ouvert.","title":"  4 Option : avec un d\u00e9tecteur de lumi\u00e8re Grove"},{"location":"microbit/python_decouverte/#du-mouvement","text":"","title":" Du mouvement !"},{"location":"microbit/python_decouverte/#1-detecter-une-secousse","text":"Gr\u00e2ce \u00e0 un acc\u00e9l\u00e9rom\u00e8tre, la carte micro:bit est capable de d\u00e9tecter des gestes, et notamment lorsqu'on la secoue. L'expression accelerometer.is_gesture('shake') vaut True (vrai) lorsque la carte est secou\u00e9e et False (faux) sinon. Lire le programme suivant et d\u00e9crire le comportement que devrait avoir la carte apr\u00e8s l'ex\u00e9cution de ce programme. from microbit import * while True : secoue = accelerometer . is_gesture ( 'shake' ) if secoue : display . show ( Image . YES ) sleep ( 50 ) display . clear () Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. En utilisant les gestes face up et face down d\u00e9tect\u00e9s par l'acc\u00e9l\u00e9rom\u00e8tre, modifier le programme pr\u00e9c\u00e9dent pour que la carte affiche l'image Image.YES lorsqu'elle est tourn\u00e9e vers le plafond, l'image Image.NO lorsqu'elle est tourn\u00e9e vers le sol, et rien dans les autres cas.","title":" 1 D\u00e9tecter une secousse"},{"location":"microbit/python_decouverte/#2-detecter-linclinaison-de-la-carte","text":"On souhaite d\u00e9placer un pixel sur l'\u00e9cran en fonction des valeurs des inclinaisons gauche-droite et avant-arri\u00e8re de la carte, comme une bille qui se d\u00e9placerait sur un plan inclin\u00e9. On utilise la valeur d\u00e9tect\u00e9e pour accelerometer.get_x() (inclinaison gauche-droite) et accelerometer.get_y() (inclinaison avant-arri\u00e8re) et selon leur valeur, on donne \u00e0 l'abscisse x et \u00e0 l'ordonn\u00e9e y d'un pixel allum\u00e9 la valeur 0, 1, 2, 3 ou 4. Par exemple, voici la valeur donn\u00e9e \u00e0 x selon la valeur de accelerometer.get_x() : Compl\u00e9ter le programme suivant pour qu'il respecte les indications pr\u00e9c\u00e9dentes pour d\u00e9terminer la valeur de x . from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) acc_x = accelerometer . get_x () if acc_x > ... : x = 4 elif acc_x > 200 : x = ... elif acc_x < - 400 : x = ... elif acc_x < ... : x = 1 else : x = ... display . set_pixel ( x , y , 9 ) sleep ( 100 ) Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. Compl\u00e9ter le programme en proc\u00e9dant de fa\u00e7on analogue pour d\u00e9terminer la valeur que doit en prendre l'ordonn\u00e9e du pixel y selon les valeurs de accelerometer.get_y()","title":" 2 D\u00e9tecter l'inclinaison de la carte"},{"location":"microbit/python_defis/","text":"D\u00e9fis Cible sur plan inclin\u00e9 led acc\u00e9l\u00e9rom\u00e8tre Fonctionnement attendu : Un pixel cible, d\u00e9termin\u00e9 al\u00e9atoirement, clignote sur l'\u00e9cran de 25 led de la micro:bit. Le joueur \"d\u00e9place\" un pixel positionn\u00e9 initialement au centre de la carte en inclinant la carte micro:bit (avant-arri\u00e8re, gauche-droite) Lorsque les 2 pixels se superposent, la partie est gagn\u00e9e : un c\u0153ur s'affiche et le jeu s'arr\u00eate. Info Pour cr\u00e9er un pixel al\u00e9atoire, voir la page Les LED Pour d\u00e9placer un pixel selon l'inclinaison de la carte, voir l' exercice 3.5 Jeu de Nim sur un ruban NeoPixel led bouton radio neopixel Mat\u00e9riel : 3 cartes micro:bit, 1 ruban neopixel Fonctionnement attendu : Deux joueurs s'affrontent au jeu de Nim. Chacun joue \u00e0 l'aide d'une carte micro:bit. L'un des joueurs a la couleur rouge, l'autre la couleur bleu. Le ruban NeoPixel est pilot\u00e9 par une 3e carte : il est totalement allum\u00e9 et toutes ses leds sont \u00e9clair\u00e9es en blanc. Les joueurs doivent s'approprier tour \u00e0 tour entre une et trois led qui s'afficheront en rouge ou bleu selon le joueur. Celui qui s'empare de la derni\u00e8re led du ruban gagne la partie. Chacun leur tour, les joueurs appuient 1, 2 ou 3 fois sur le bouton A, et valident leur choix avec le bouton B. La carte affiche les chiffres 1, 2 ou 3 lors des appuis sur le bouton A et l'image Image.YES lors de la validation avec le bouton B. La valeur choisie est envoy\u00e9e par radio \u00e0 la carte qui pilote le ruban de led. Le nombre correspondant de led s'allume en couleur sur le ruban, en rouge ou bleu selon le joueur. Lorsque la derni\u00e8re led est atteinte, le ruban fait clignoter ses led de la couleur du joueur gagnant.","title":"D\u00e9fis"},{"location":"microbit/python_defis/#defis","text":"","title":"D\u00e9fis"},{"location":"microbit/python_defis/#cible-sur-plan-incline","text":"led acc\u00e9l\u00e9rom\u00e8tre Fonctionnement attendu : Un pixel cible, d\u00e9termin\u00e9 al\u00e9atoirement, clignote sur l'\u00e9cran de 25 led de la micro:bit. Le joueur \"d\u00e9place\" un pixel positionn\u00e9 initialement au centre de la carte en inclinant la carte micro:bit (avant-arri\u00e8re, gauche-droite) Lorsque les 2 pixels se superposent, la partie est gagn\u00e9e : un c\u0153ur s'affiche et le jeu s'arr\u00eate. Info Pour cr\u00e9er un pixel al\u00e9atoire, voir la page Les LED Pour d\u00e9placer un pixel selon l'inclinaison de la carte, voir l' exercice 3.5","title":"Cible sur plan inclin\u00e9"},{"location":"microbit/python_defis/#jeu-de-nim-sur-un-ruban-neopixel","text":"led bouton radio neopixel Mat\u00e9riel : 3 cartes micro:bit, 1 ruban neopixel Fonctionnement attendu : Deux joueurs s'affrontent au jeu de Nim. Chacun joue \u00e0 l'aide d'une carte micro:bit. L'un des joueurs a la couleur rouge, l'autre la couleur bleu. Le ruban NeoPixel est pilot\u00e9 par une 3e carte : il est totalement allum\u00e9 et toutes ses leds sont \u00e9clair\u00e9es en blanc. Les joueurs doivent s'approprier tour \u00e0 tour entre une et trois led qui s'afficheront en rouge ou bleu selon le joueur. Celui qui s'empare de la derni\u00e8re led du ruban gagne la partie. Chacun leur tour, les joueurs appuient 1, 2 ou 3 fois sur le bouton A, et valident leur choix avec le bouton B. La carte affiche les chiffres 1, 2 ou 3 lors des appuis sur le bouton A et l'image Image.YES lors de la validation avec le bouton B. La valeur choisie est envoy\u00e9e par radio \u00e0 la carte qui pilote le ruban de led. Le nombre correspondant de led s'allume en couleur sur le ruban, en rouge ou bleu selon le joueur. Lorsque la derni\u00e8re led est atteinte, le ruban fait clignoter ses led de la couleur du joueur gagnant.","title":"Jeu de Nim sur un ruban NeoPixel"},{"location":"microbit/python_editeur/","text":"Quel \u00e9diteur ? MicroPython La carte micro:bit peut \u00eatre programm\u00e9e en Python. La version de Python qui s'ex\u00e9cute sur la carte micro:bit s'appelle MicroPython . C'est une impl\u00e9mentation l\u00e9g\u00e8re et efficace du langage de programmation Python 3 qui comprend un sous-ensemble de la biblioth\u00e8que standard Python et qui est optimis\u00e9e pour s'ex\u00e9cuter sur des microcontr\u00f4leurs. Le site microbit-micropython.readthedocs.io pr\u00e9sente les instructions de r\u00e9f\u00e9rence et propose quelques projets. Quel \u00e9diteur Python utiliser ? Pour \u00e9crire des programmes et les t\u00e9l\u00e9charger sur la carte micro:bit, plusieurs \u00e9diteurs existent. Attention Le code python obtenu via les diff\u00e9rentes interfaces n'est pas interchangeable car les modules import\u00e9s peuvent diff\u00e9rer. Voici une s\u00e9lection parmi les interfaces disponibles : - L'\u00e9diteur Python en ligne du site microbit.org L' \u00e9diteur Python en ligne ne n\u00e9cessite pas d'installation, mais ne dispose ni de l'auto-compl\u00e9tion ni de version en fran\u00e7ais. - le logiciel Mu Mu est un \u00e9diteur de code simple, multiplateforme. Cette interface dispose de l'auto-compl\u00e9tion et d'une indentation automatique, ainsi que d'une version en fran\u00e7ais. Mu propose diff\u00e9rents modes dont l'un est destin\u00e9 \u00e0 la carte micro:bit. Ce mode propose l'affichage graphique des donn\u00e9es envoy\u00e9es sur le port s\u00e9rie et une console interactive REPL (read, evaluate, print, loop). - l'\u00e9diteur en ligne Vittascience L' \u00e9diteur fran\u00e7ais Vittascience propose l'\u00e9criture de programmes \u00e0 l'aide de blocs de programmation en fran\u00e7ais, ou de code en python. Un mode hybride permet une transition de l'un vers l'autre en affichant les 2 simultan\u00e9ment. Cet \u00e9diteur dispose de plus d'un simulateur de carte, permettant de tester son programme, m\u00eame en l'absence de connexion \u00e0 une carte micro:bit. On trouve aussi l'affichage graphique des donn\u00e9es envoy\u00e9es sur le port s\u00e9rie et l'export des donn\u00e9es. Enfin, les instructions n\u00e9cessaires au fonctionnement des capteurs et actionneurs du kit Grove sont pr\u00e9sents. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, etc. - l'\u00e9diteur en ligne Edublocks L'\u00e9diteur Edublocks est un projet d\u00e9velopp\u00e9 par Joshua Lowe, jeune britannique. L\u2019interface permet de programmer en Python en s\u00e9lectionnant et imbriquant des blocs. On alterne d\u2019un clic entre la version blocs et la version textuelle, mais le contenu lisible est identique dans les 2 cas. Des extensions sont disponibles pour quelques kits, mais pas pour le kit Grove. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, de les int\u00e9grer, etc. - l'\u00e9diteur en ligne Create with code L'interface create with code propose un \u00e9diteur en ligne de scripts en python et comporte un simulateur de carte micro:bit. Il suffit d\u2019ajouter l\u2019instruction from microbit import * en d\u00e9but de script et de l\u2019ex\u00e9cuter pour voir appara\u00eetre une fen\u00eatre simulant la carte et ses diff\u00e9rents capteurs et actionneurs. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, de les int\u00e9grer, etc. Synth\u00e8se (janvier 2021) \u00e9diteur micro:bit Mu Vittascience Edublocks Create with code En ligne Auto-compl\u00e9tion version fran\u00e7aise : transfert rapide sur la carte (WebUSB, flash) Affichage de graphiques Simulateur","title":"Quel \u00e9diteur ?"},{"location":"microbit/python_editeur/#quel-editeur","text":"","title":"Quel \u00e9diteur ?"},{"location":"microbit/python_editeur/#micropython","text":"La carte micro:bit peut \u00eatre programm\u00e9e en Python. La version de Python qui s'ex\u00e9cute sur la carte micro:bit s'appelle MicroPython . C'est une impl\u00e9mentation l\u00e9g\u00e8re et efficace du langage de programmation Python 3 qui comprend un sous-ensemble de la biblioth\u00e8que standard Python et qui est optimis\u00e9e pour s'ex\u00e9cuter sur des microcontr\u00f4leurs. Le site microbit-micropython.readthedocs.io pr\u00e9sente les instructions de r\u00e9f\u00e9rence et propose quelques projets.","title":"MicroPython"},{"location":"microbit/python_editeur/#quel-editeur-python-utiliser","text":"Pour \u00e9crire des programmes et les t\u00e9l\u00e9charger sur la carte micro:bit, plusieurs \u00e9diteurs existent. Attention Le code python obtenu via les diff\u00e9rentes interfaces n'est pas interchangeable car les modules import\u00e9s peuvent diff\u00e9rer. Voici une s\u00e9lection parmi les interfaces disponibles :","title":"Quel \u00e9diteur Python utiliser ?"},{"location":"microbit/python_editeur/#-lediteur-python-en-ligne-du-site-microbitorg","text":"L' \u00e9diteur Python en ligne ne n\u00e9cessite pas d'installation, mais ne dispose ni de l'auto-compl\u00e9tion ni de version en fran\u00e7ais.","title":"- L'\u00e9diteur Python en ligne du site microbit.org"},{"location":"microbit/python_editeur/#-le-logiciel-mu","text":"Mu est un \u00e9diteur de code simple, multiplateforme. Cette interface dispose de l'auto-compl\u00e9tion et d'une indentation automatique, ainsi que d'une version en fran\u00e7ais. Mu propose diff\u00e9rents modes dont l'un est destin\u00e9 \u00e0 la carte micro:bit. Ce mode propose l'affichage graphique des donn\u00e9es envoy\u00e9es sur le port s\u00e9rie et une console interactive REPL (read, evaluate, print, loop).","title":"- le logiciel Mu"},{"location":"microbit/python_editeur/#-lediteur-en-ligne-vittascience","text":"L' \u00e9diteur fran\u00e7ais Vittascience propose l'\u00e9criture de programmes \u00e0 l'aide de blocs de programmation en fran\u00e7ais, ou de code en python. Un mode hybride permet une transition de l'un vers l'autre en affichant les 2 simultan\u00e9ment. Cet \u00e9diteur dispose de plus d'un simulateur de carte, permettant de tester son programme, m\u00eame en l'absence de connexion \u00e0 une carte micro:bit. On trouve aussi l'affichage graphique des donn\u00e9es envoy\u00e9es sur le port s\u00e9rie et l'export des donn\u00e9es. Enfin, les instructions n\u00e9cessaires au fonctionnement des capteurs et actionneurs du kit Grove sont pr\u00e9sents. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, etc.","title":"- l'\u00e9diteur en ligne Vittascience"},{"location":"microbit/python_editeur/#-lediteur-en-ligne-edublocks","text":"L'\u00e9diteur Edublocks est un projet d\u00e9velopp\u00e9 par Joshua Lowe, jeune britannique. L\u2019interface permet de programmer en Python en s\u00e9lectionnant et imbriquant des blocs. On alterne d\u2019un clic entre la version blocs et la version textuelle, mais le contenu lisible est identique dans les 2 cas. Des extensions sont disponibles pour quelques kits, mais pas pour le kit Grove. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, de les int\u00e9grer, etc.","title":"- l'\u00e9diteur en ligne Edublocks"},{"location":"microbit/python_editeur/#-lediteur-en-ligne-create-with-code","text":"L'interface create with code propose un \u00e9diteur en ligne de scripts en python et comporte un simulateur de carte micro:bit. Il suffit d\u2019ajouter l\u2019instruction from microbit import * en d\u00e9but de script et de l\u2019ex\u00e9cuter pour voir appara\u00eetre une fen\u00eatre simulant la carte et ses diff\u00e9rents capteurs et actionneurs. Il est possible de se cr\u00e9er un compte et de sauvegarder ses programmes en ligne, de les partager, de les int\u00e9grer, etc.","title":"- l'\u00e9diteur en ligne Create with code"},{"location":"microbit/python_editeur/#synthese-janvier-2021","text":"\u00e9diteur micro:bit Mu Vittascience Edublocks Create with code En ligne Auto-compl\u00e9tion version fran\u00e7aise : transfert rapide sur la carte (WebUSB, flash) Affichage de graphiques Simulateur","title":"Synth\u00e8se (janvier 2021)"},{"location":"microbit/python_exercices/","text":"Exercices 1. Afficher une image 1.1 Afficher une image pr\u00e9d\u00e9finie led Voici un premier programme : from microbit import * display . show ( Image . YES ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que constate-t-on ? Remplacer dans le programme le mot YES par l'un des mots suivants : CHESSBOARD - DIAMOND - HAPPY - HEART - NO - SAD - SQUARE Choisir l'une des images et la reproduire sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5. 1.2 Afficher une image personnalis\u00e9e led Saisir le programme suivant et le flasher sur la carte. Que constate-t-on ? \u00c0 quoi correspondent les 0 et les 9 ? from microbit import * mon_image = Image ( \"90909:\" \"09990:\" \"99999:\" \"09990:\" \"90909\" ) display . show ( Image . mon_image ) Dessiner sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5 une image personnelle et modifier le programme pr\u00e9c\u00e9dent pour la faire appara\u00eetre sur la carte micro:bit. 1.3 Faire alterner deux images led Cr\u00e9er une animation affichant successivement et en boucle deux images pr\u00e9d\u00e9finies, par exemple Image.SQUARE et Image.SQUARE_SMALL. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 from microbit import * mes_images = [ Image . SQUARE , Image . SQUARE_SMALL ] display . show ( ... , delay =... , loop =... ) Une solution 1 2 3 from microbit import * mes_images = [ Image . SQUARE , Image . SQUARE_SMALL ] display . show ( mes_images , delay = 500 , loop = True ) 2. Faire clignoter une LED 2.1 Faire clignoter une LED de la carte led Choisir l'une des LED de la carte et la faire clignoter. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 from microbit import * while True : # choisir un pixel \u00e0 allumer display . set_pixel ( ... , ... , 9 ) sleep ( 500 ) # \u00e9teindre le m\u00eame pixel display . set_pixel ( ... , ... , ... ) sleep ( 500 ) Une solution 1 2 3 4 5 6 from microbit import * while True : display . set_pixel ( 1 , 1 , 9 ) sleep ( 500 ) display . set_pixel ( 1 , 1 , 0 ) sleep ( 500 ) 2.2 Faire varier le rythme avec un potentiom\u00e8tre led potentiom\u00e8tre Placer la carte micro-bit sur le shield Grove et connecter le potentiom\u00e8tre sur la broche P0-P14. La fonction pin0.read_analog() renvoie une valeur qui d\u00e9pend de l'angle de rotation de l'axe du potentiom\u00e8tre. Modifier le programme pr\u00e9c\u00e9dent en ajoutant au d\u00e9but de la boucle while l'intruction : mesure = pin0.read_analog() puis en rempla\u00e7ant les temps durant lesquels la LED est allum\u00e9e ou \u00e9teinte par mesure . Quel effet observe-t-on sur le clignotement lorsque l'on tourne l'axe du potentiom\u00e8tre ? Une solution 1 2 3 4 5 6 7 from microbit import * while True : mesure = pin0 . read_analog () display . set_pixel ( 1 , 1 , 9 ) sleep ( mesure ) display . set_pixel ( 1 , 1 , 0 ) sleep ( mesure ) 2.3 Faire clignoter la LED du kit Grove led grove potentiom\u00e8tre Connecter la LED sur le shield Grove sur la broche P1-P15 ( en plus du potentiom\u00e8tre d\u00e9j\u00e0 connect\u00e9 sur la broche P0-P14). L'instruction pin1.write_digital(1) permet d'allumer la LED lorsqu'elle est sur la broche P1, et l'instruction pin1.write_digital(0) permet de l'\u00e9teindre. Modifier le programme pr\u00e9c\u00e9dent pour faire clignoter la LED Grove, au lieu d'une LED de la carte. Le potentiom\u00e8tre conserve-t-il son effet ? Une solution 1 2 3 4 5 6 7 from microbit import * while True : mesure = pin0 . read_analog () pin1 . write_digital ( 1 ) sleep ( mesure ) pin1 . write_digital ( 0 ) sleep ( mesure ) 3. D\u00e9placer un point lumineux 3.1 Programmer le d\u00e9placement d'un point lumineux sur la carte led Lire le programme suivant et anticiper l'effet produit sur la carte micro:bit : 1 2 3 4 5 6 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () Saisir ce programme et le flasher sur une carte micro:bit. V\u00e9rifier si l'effet constat\u00e9 correspond \u00e0 celui anticip\u00e9. Indenter l'instruction display.clear() pour qu'elle soit align\u00e9e avec le sleep(300) de la ligne 5. Quel effet cela a-t-il sur l'affichage produit sur la carte ? Pourquoi ? Poursuivre le programme pr\u00e9c\u00e9dent pour que le point lumineux allum\u00e9 fasse le tour du carr\u00e9 de 25 LED. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () for y in range ( 1 , 5 ): # y prend les valeurs 1 \u00e0 4 display . set_pixel ( ... , y , 9 ) sleep ( 300 ) display . clear () for x in range ( 3 , - 1 , - 1 ): # x prend les valeurs 3 \u00e0 0 display . set_pixel ( x , ... , 9 ) sleep ( 300 ) display . clear () for y in range ( 3 , - 1 , - 1 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( ... , y , 9 ) sleep ( 300 ) display . clear () Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () for y in range ( 1 , 5 ): # y prend les valeurs 1 \u00e0 4 display . set_pixel ( 4 , y , 9 ) sleep ( 300 ) display . clear () for x in range ( 3 , - 1 , - 1 ): # x prend les valeurs 3 \u00e0 0 display . set_pixel ( x , 4 , 9 ) sleep ( 300 ) display . clear () for y in range ( 3 , - 1 , - 1 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( 0 , y , 9 ) sleep ( 300 ) display . clear () 3.2 Programmer le d\u00e9placement d'un point lumineux sur le ruban NeoPixel neopixel Placer la carte micro-bit sur le shield Grove et connecter le ruban de led NeoPixel sur le connecteur P0-P14. Lire le programme suivant et anticiper l'effet produit sur le ruban NeoPixel : quels pixels sont allum\u00e9s, dans quel ordre, de quelle(s) couleurs(s) ? 1 2 3 4 5 6 7 8 9 10 11 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) while True : for x in range ( 30 ): # x prend les valeurs 0 \u00e0 29 np [ x ] = ( 255 , 0 , 0 ) sleep ( 200 ) np . show () np . clear () Saisir ce programme et le flasher sur une carte micro:bit, connect\u00e9e. V\u00e9rifier si l'effet constat\u00e9 correspond \u00e0 celui anticip\u00e9. Indenter l'instruction np.clear() pour qu'elle soit align\u00e9e avec le np.show() de la ligne 10. Quel effet cela a-t-il sur l'affichage produit sur le ruban ? Pourquoi ? Modifier une valeur du programme pour augmenter la \"vitesse\" du point lumineux. Modifier une ou plusieurs valeurs pour que le pixel allum\u00e9 soit jaune. Poursuivre le programme pr\u00e9c\u00e9dent pour que le point lumineux fasse des allers-retours entre les deux extr\u00e9mit\u00e9s du ruban. 3.3 D\u00e9placer un pixel sur la carte avec les boutons led boutons Fonctionnement attendu : Une led est allum\u00e9e au centre de l'\u00e9cran. En appuyant sur le bouton A, elle se \"d\u00e9place\" d'un pixel vers la gauche, et en appuyant sur le bouton B, elle se \"d\u00e9place\" d'un pixel vers la droite. Lorsqu'elle atteint un bord (gauche ou droit), l'appui sur le bouton correspondant \u00e0 ce bord n'a plus d'effet. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from microbit import * #positionnement initial au centre x = ... y = ... while True : display . set_pixel ( x , y , 0 ) # on \u00e9teint le pixel if button_a . was_pressed (): if x ... : # si le pixel n'est pas d\u00e9j\u00e0 au bord gauche x = x ... # on le d\u00e9place d'une unit\u00e9 vers la gauche if button_b . was_pressed (): if x ... : # si le pixel n'est pas d\u00e9j\u00e0 au bord droit x = x ... # on le d\u00e9place d'une unit\u00e9 vers la droite display . set_pixel ( x , y , 9 ) # on allume le pixel sleep ( 20 ) Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) if button_a . was_pressed (): if x > 0 : x = x - 1 if button_b . was_pressed (): if x < 4 : x = x + 1 display . set_pixel ( x , y , 9 ) sleep ( 20 ) 3.4 D\u00e9placer un point lumineux sur un ruban NeoPixel avec les boutons boutons neopixel Fonctionnement attendu : Une led NeoPixel est allum\u00e9e au d\u00e9but du ruban de led NeoPixel. En appuyant sur le bouton A, un point lumineux se \"d\u00e9place\" d'un pixel vers la fin du ruban, et en appuyant sur le bouton B, elle revient d'un pixel vers le d\u00e9but du ruban. Lorsque le point lumineux atteint une extr\u00e9mit\u00e9, l'appui sur le bouton correspondant \u00e0 cette extr\u00e9mit\u00e9 n'a plus d'effet. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) position = 0 while True : np . clear () if button_a . was_pressed (): if position ... : # si le pixel n'est pas d\u00e9j\u00e0 au d\u00e9but du ruban position = position ... # on le d\u00e9place d'une unit\u00e9 vers le d\u00e9but if button_b . was_pressed (): if position ... : # si le pixel n'est pas d\u00e9j\u00e0 \u00e0 la fin du ruban position = position ... # on le d\u00e9place d'une unit\u00e9 vers la fin np [ position ] = ( ... , 0 , 0 ) # on allume le pixel en rouge np . show () sleep ( 20 ) Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) position = 0 while True : np . clear () if button_a . was_pressed (): if position > 0 : # si le pixel n'est pas d\u00e9j\u00e0 au d\u00e9but du ruban position = position - 1 # on le d\u00e9place d'une unit\u00e9 vers le d\u00e9but if button_b . was_pressed (): if position < 29 : # si le pixel n'est pas d\u00e9j\u00e0 \u00e0 la fin du ruban position = position + 1 # on le d\u00e9place d'une unit\u00e9 vers la fin np [ position ] = ( 255 , 0 , 0 ) # on allume le pixel en rouge np . show () sleep ( 20 ) 3.5 D\u00e9placer un point lumineux avec l'inclinaison de la carte led acc\u00e9l\u00e9rom\u00e8tre On souhaite d\u00e9placer un point lumineux sur l'\u00e9cran en fonction des valeurs des inclinaisons gauche-droite et avant-arri\u00e8re de la carte, comme une bille qui se d\u00e9placerait sur un plan inclin\u00e9. On utilise la valeur d\u00e9tect\u00e9e pour accelerometer.get_x() (inclinaison gauche-droite) et accelerometer.get_y() (inclinaison avant-arri\u00e8re) et selon leur valeur, on donne \u00e0 l'abscisse x et \u00e0 l'ordonn\u00e9e y d'un pixel allum\u00e9 la valeur 0, 1, 2, 3 ou 4. Par exemple, voici la valeur que l'on peut donner \u00e0 x selon la valeur de accelerometer.get_x() : Compl\u00e9ter le programme suivant pour qu'il respecte les indications pr\u00e9c\u00e9dentes pour d\u00e9terminer la valeur de x . from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) acc_x = accelerometer . get_x () if acc_x > ... : x = 4 elif acc_x > 200 : x = ... elif acc_x < - 400 : x = ... elif acc_x < ... : x = 1 else : x = ... display . set_pixel ( x , y , 9 ) sleep ( 100 ) Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. Compl\u00e9ter le programme en proc\u00e9dant de fa\u00e7on analogue pour d\u00e9terminer la valeur que doit en prendre l'ordonn\u00e9e du pixel y selon les valeurs de accelerometer.get_y() 4. D\u00e9tecter l'intensit\u00e9 lumineuse 4.1 Avec les leds de la carte micro:bit led Les LED de la carte peuvent d\u00e9tecter le niveau de lumi\u00e8re ambiante : la fonction display.read_light_level() renvoie une valeur comprise entre 0 et 255 : plus la valeur est \u00e9lev\u00e9e, plus l'environnement est lumineux. from microbit import * while True : niveau = display . read_light_level () if niveau > 220 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 200 ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que faut-il faire pour que l'image Image.YES s'affiche ? Modifier ce programme pour que la carte affiche un carr\u00e9 en luminosit\u00e9 \"normale\" et un diamant dans la p\u00e9nombre. 4.2 Avec un capteur de lumi\u00e8re Grove led capteur de lumi\u00e8re Placer la carte micro-bit sur le shield Grove et connecter le capteur de lumi\u00e8re sur la broche P0-P14. La fonction pin0.read_analog() renvoie une valeur enti\u00e8re d'autant plus \u00e9lev\u00e9e que l'environnement est lumineux. Saisir et flasher le programme suivant : from microbit import * while True : mesure = pin0 . read_analog () if mesure > 600 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 100 ) Que peut-on faire pour que l'image Image.NO s'affiche sur la carte micro:bit ? Emballer le capteur (connect\u00e9 \u00e0 la carte) dans une feuille de papier. Modifier le programme pour que la carte affiche l'image Image.YES tant que le capteur reste emball\u00e9 et l'image Image.NO d\u00e8s que l'emballage est ouvert. 5. Envoyer des messages par radio 5.1 Envoyer une valeur led boutons radio Cet exercice n\u00e9cessite deux cartes : une carte mesure la temp\u00e9rature et envoie par radio la valeur mesur\u00e9e. Une autre carte re\u00e7oit les valeurs et les affiche. Programme sur la carte \u00e9mettrice from microbit import * import radio radio . on () while True : temperature = temperature () radio . send ( temperature ) sleep ( 1000 ) Programme sur la carte r\u00e9ceptrice from microbit import * import radio radio . on () while True : valeur = radio . receive () display . scroll ( valeur ) sleep ( 1000 ) Modifier le programme de la carte r\u00e9ceptrice pour qu'elle n'affiche plus la temp\u00e9rature mais affiche (Image.HAPPY) si la temp\u00e9rature est sup\u00e9rieure \u00e0 20\u00b0C et (Image.SAD) sinon. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 from microbit import * import radio radio . on () while True : valeur = radio . receive () if ... > 20 : display . show ( ... ) ... : display . show ( ... ) sleep ( 1000 ) Compl\u00e9ter le programme de la question pr\u00e9c\u00e9dente pour que la carte r\u00e9ceptrice affiche la temp\u00e9rature lorsqu'on appuie sur le bouton A. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 from microbit import * import radio radio . on () while True : valeur = radio . receive () if ... > 20 : display . show ( ... ) ... : display . show ( ... ) if button_a . is_pressed (): ... sleep ( 1000 )","title":"Exercices"},{"location":"microbit/python_exercices/#exercices","text":"","title":"Exercices"},{"location":"microbit/python_exercices/#1-afficher-une-image","text":"","title":"1. Afficher une image"},{"location":"microbit/python_exercices/#11-afficher-une-image-predefinie","text":"led Voici un premier programme : from microbit import * display . show ( Image . YES ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que constate-t-on ? Remplacer dans le programme le mot YES par l'un des mots suivants : CHESSBOARD - DIAMOND - HAPPY - HEART - NO - SAD - SQUARE Choisir l'une des images et la reproduire sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5.","title":"1.1 Afficher une image pr\u00e9d\u00e9finie"},{"location":"microbit/python_exercices/#12-afficher-une-image-personnalisee","text":"led Saisir le programme suivant et le flasher sur la carte. Que constate-t-on ? \u00c0 quoi correspondent les 0 et les 9 ? from microbit import * mon_image = Image ( \"90909:\" \"09990:\" \"99999:\" \"09990:\" \"90909\" ) display . show ( Image . mon_image ) Dessiner sur une feuille \u00e0 l'aide d'un quadrillage de 5 carreaux sur 5 une image personnelle et modifier le programme pr\u00e9c\u00e9dent pour la faire appara\u00eetre sur la carte micro:bit.","title":"1.2 Afficher une image personnalis\u00e9e"},{"location":"microbit/python_exercices/#13-faire-alterner-deux-images","text":"led Cr\u00e9er une animation affichant successivement et en boucle deux images pr\u00e9d\u00e9finies, par exemple Image.SQUARE et Image.SQUARE_SMALL. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 from microbit import * mes_images = [ Image . SQUARE , Image . SQUARE_SMALL ] display . show ( ... , delay =... , loop =... ) Une solution 1 2 3 from microbit import * mes_images = [ Image . SQUARE , Image . SQUARE_SMALL ] display . show ( mes_images , delay = 500 , loop = True )","title":"1.3 Faire alterner deux images"},{"location":"microbit/python_exercices/#2-faire-clignoter-une-led","text":"","title":"2. Faire clignoter une LED"},{"location":"microbit/python_exercices/#21-faire-clignoter-une-led-de-la-carte","text":"led Choisir l'une des LED de la carte et la faire clignoter. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 from microbit import * while True : # choisir un pixel \u00e0 allumer display . set_pixel ( ... , ... , 9 ) sleep ( 500 ) # \u00e9teindre le m\u00eame pixel display . set_pixel ( ... , ... , ... ) sleep ( 500 ) Une solution 1 2 3 4 5 6 from microbit import * while True : display . set_pixel ( 1 , 1 , 9 ) sleep ( 500 ) display . set_pixel ( 1 , 1 , 0 ) sleep ( 500 )","title":"2.1 Faire clignoter une LED de la carte"},{"location":"microbit/python_exercices/#22-faire-varier-le-rythme-avec-un-potentiometre","text":"led potentiom\u00e8tre Placer la carte micro-bit sur le shield Grove et connecter le potentiom\u00e8tre sur la broche P0-P14. La fonction pin0.read_analog() renvoie une valeur qui d\u00e9pend de l'angle de rotation de l'axe du potentiom\u00e8tre. Modifier le programme pr\u00e9c\u00e9dent en ajoutant au d\u00e9but de la boucle while l'intruction : mesure = pin0.read_analog() puis en rempla\u00e7ant les temps durant lesquels la LED est allum\u00e9e ou \u00e9teinte par mesure . Quel effet observe-t-on sur le clignotement lorsque l'on tourne l'axe du potentiom\u00e8tre ? Une solution 1 2 3 4 5 6 7 from microbit import * while True : mesure = pin0 . read_analog () display . set_pixel ( 1 , 1 , 9 ) sleep ( mesure ) display . set_pixel ( 1 , 1 , 0 ) sleep ( mesure )","title":"2.2 Faire varier le rythme avec un potentiom\u00e8tre"},{"location":"microbit/python_exercices/#23-faire-clignoter-la-led-du-kit-grove","text":"led grove potentiom\u00e8tre Connecter la LED sur le shield Grove sur la broche P1-P15 ( en plus du potentiom\u00e8tre d\u00e9j\u00e0 connect\u00e9 sur la broche P0-P14). L'instruction pin1.write_digital(1) permet d'allumer la LED lorsqu'elle est sur la broche P1, et l'instruction pin1.write_digital(0) permet de l'\u00e9teindre. Modifier le programme pr\u00e9c\u00e9dent pour faire clignoter la LED Grove, au lieu d'une LED de la carte. Le potentiom\u00e8tre conserve-t-il son effet ? Une solution 1 2 3 4 5 6 7 from microbit import * while True : mesure = pin0 . read_analog () pin1 . write_digital ( 1 ) sleep ( mesure ) pin1 . write_digital ( 0 ) sleep ( mesure )","title":"2.3 Faire clignoter la LED du kit Grove"},{"location":"microbit/python_exercices/#3-deplacer-un-point-lumineux","text":"","title":"3. D\u00e9placer un point lumineux"},{"location":"microbit/python_exercices/#31-programmer-le-deplacement-dun-point-lumineux-sur-la-carte","text":"led Lire le programme suivant et anticiper l'effet produit sur la carte micro:bit : 1 2 3 4 5 6 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () Saisir ce programme et le flasher sur une carte micro:bit. V\u00e9rifier si l'effet constat\u00e9 correspond \u00e0 celui anticip\u00e9. Indenter l'instruction display.clear() pour qu'elle soit align\u00e9e avec le sleep(300) de la ligne 5. Quel effet cela a-t-il sur l'affichage produit sur la carte ? Pourquoi ? Poursuivre le programme pr\u00e9c\u00e9dent pour que le point lumineux allum\u00e9 fasse le tour du carr\u00e9 de 25 LED. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () for y in range ( 1 , 5 ): # y prend les valeurs 1 \u00e0 4 display . set_pixel ( ... , y , 9 ) sleep ( 300 ) display . clear () for x in range ( 3 , - 1 , - 1 ): # x prend les valeurs 3 \u00e0 0 display . set_pixel ( x , ... , 9 ) sleep ( 300 ) display . clear () for y in range ( 3 , - 1 , - 1 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( ... , y , 9 ) sleep ( 300 ) display . clear () Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * while True : for x in range ( 5 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( x , 0 , 9 ) sleep ( 300 ) display . clear () for y in range ( 1 , 5 ): # y prend les valeurs 1 \u00e0 4 display . set_pixel ( 4 , y , 9 ) sleep ( 300 ) display . clear () for x in range ( 3 , - 1 , - 1 ): # x prend les valeurs 3 \u00e0 0 display . set_pixel ( x , 4 , 9 ) sleep ( 300 ) display . clear () for y in range ( 3 , - 1 , - 1 ): # x prend les valeurs 0 \u00e0 4 display . set_pixel ( 0 , y , 9 ) sleep ( 300 ) display . clear ()","title":"3.1 Programmer le d\u00e9placement d'un point lumineux sur la carte"},{"location":"microbit/python_exercices/#32-programmer-le-deplacement-dun-point-lumineux-sur-le-ruban-neopixel","text":"neopixel Placer la carte micro-bit sur le shield Grove et connecter le ruban de led NeoPixel sur le connecteur P0-P14. Lire le programme suivant et anticiper l'effet produit sur le ruban NeoPixel : quels pixels sont allum\u00e9s, dans quel ordre, de quelle(s) couleurs(s) ? 1 2 3 4 5 6 7 8 9 10 11 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) while True : for x in range ( 30 ): # x prend les valeurs 0 \u00e0 29 np [ x ] = ( 255 , 0 , 0 ) sleep ( 200 ) np . show () np . clear () Saisir ce programme et le flasher sur une carte micro:bit, connect\u00e9e. V\u00e9rifier si l'effet constat\u00e9 correspond \u00e0 celui anticip\u00e9. Indenter l'instruction np.clear() pour qu'elle soit align\u00e9e avec le np.show() de la ligne 10. Quel effet cela a-t-il sur l'affichage produit sur le ruban ? Pourquoi ? Modifier une valeur du programme pour augmenter la \"vitesse\" du point lumineux. Modifier une ou plusieurs valeurs pour que le pixel allum\u00e9 soit jaune. Poursuivre le programme pr\u00e9c\u00e9dent pour que le point lumineux fasse des allers-retours entre les deux extr\u00e9mit\u00e9s du ruban.","title":"3.2 Programmer le d\u00e9placement d'un point lumineux sur le ruban NeoPixel"},{"location":"microbit/python_exercices/#33-deplacer-un-pixel-sur-la-carte-avec-les-boutons","text":"led boutons Fonctionnement attendu : Une led est allum\u00e9e au centre de l'\u00e9cran. En appuyant sur le bouton A, elle se \"d\u00e9place\" d'un pixel vers la gauche, et en appuyant sur le bouton B, elle se \"d\u00e9place\" d'un pixel vers la droite. Lorsqu'elle atteint un bord (gauche ou droit), l'appui sur le bouton correspondant \u00e0 ce bord n'a plus d'effet. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from microbit import * #positionnement initial au centre x = ... y = ... while True : display . set_pixel ( x , y , 0 ) # on \u00e9teint le pixel if button_a . was_pressed (): if x ... : # si le pixel n'est pas d\u00e9j\u00e0 au bord gauche x = x ... # on le d\u00e9place d'une unit\u00e9 vers la gauche if button_b . was_pressed (): if x ... : # si le pixel n'est pas d\u00e9j\u00e0 au bord droit x = x ... # on le d\u00e9place d'une unit\u00e9 vers la droite display . set_pixel ( x , y , 9 ) # on allume le pixel sleep ( 20 ) Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) if button_a . was_pressed (): if x > 0 : x = x - 1 if button_b . was_pressed (): if x < 4 : x = x + 1 display . set_pixel ( x , y , 9 ) sleep ( 20 )","title":"3.3 D\u00e9placer un pixel sur la carte avec les boutons"},{"location":"microbit/python_exercices/#34-deplacer-un-point-lumineux-sur-un-ruban-neopixel-avec-les-boutons","text":"boutons neopixel Fonctionnement attendu : Une led NeoPixel est allum\u00e9e au d\u00e9but du ruban de led NeoPixel. En appuyant sur le bouton A, un point lumineux se \"d\u00e9place\" d'un pixel vers la fin du ruban, et en appuyant sur le bouton B, elle revient d'un pixel vers le d\u00e9but du ruban. Lorsque le point lumineux atteint une extr\u00e9mit\u00e9, l'appui sur le bouton correspondant \u00e0 cette extr\u00e9mit\u00e9 n'a plus d'effet. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) position = 0 while True : np . clear () if button_a . was_pressed (): if position ... : # si le pixel n'est pas d\u00e9j\u00e0 au d\u00e9but du ruban position = position ... # on le d\u00e9place d'une unit\u00e9 vers le d\u00e9but if button_b . was_pressed (): if position ... : # si le pixel n'est pas d\u00e9j\u00e0 \u00e0 la fin du ruban position = position ... # on le d\u00e9place d'une unit\u00e9 vers la fin np [ position ] = ( ... , 0 , 0 ) # on allume le pixel en rouge np . show () sleep ( 20 ) Une solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from microbit import * import neopixel # pour une connexion sur connecteur P0/P14 np = neopixel . NeoPixel ( pin0 , 30 ) position = 0 while True : np . clear () if button_a . was_pressed (): if position > 0 : # si le pixel n'est pas d\u00e9j\u00e0 au d\u00e9but du ruban position = position - 1 # on le d\u00e9place d'une unit\u00e9 vers le d\u00e9but if button_b . was_pressed (): if position < 29 : # si le pixel n'est pas d\u00e9j\u00e0 \u00e0 la fin du ruban position = position + 1 # on le d\u00e9place d'une unit\u00e9 vers la fin np [ position ] = ( 255 , 0 , 0 ) # on allume le pixel en rouge np . show () sleep ( 20 )","title":"3.4 D\u00e9placer un point lumineux sur un ruban NeoPixel avec les boutons"},{"location":"microbit/python_exercices/#35-deplacer-un-point-lumineux-avec-linclinaison-de-la-carte","text":"led acc\u00e9l\u00e9rom\u00e8tre On souhaite d\u00e9placer un point lumineux sur l'\u00e9cran en fonction des valeurs des inclinaisons gauche-droite et avant-arri\u00e8re de la carte, comme une bille qui se d\u00e9placerait sur un plan inclin\u00e9. On utilise la valeur d\u00e9tect\u00e9e pour accelerometer.get_x() (inclinaison gauche-droite) et accelerometer.get_y() (inclinaison avant-arri\u00e8re) et selon leur valeur, on donne \u00e0 l'abscisse x et \u00e0 l'ordonn\u00e9e y d'un pixel allum\u00e9 la valeur 0, 1, 2, 3 ou 4. Par exemple, voici la valeur que l'on peut donner \u00e0 x selon la valeur de accelerometer.get_x() : Compl\u00e9ter le programme suivant pour qu'il respecte les indications pr\u00e9c\u00e9dentes pour d\u00e9terminer la valeur de x . from microbit import * x = 2 y = 2 while True : display . set_pixel ( x , y , 0 ) acc_x = accelerometer . get_x () if acc_x > ... : x = 4 elif acc_x > 200 : x = ... elif acc_x < - 400 : x = ... elif acc_x < ... : x = 1 else : x = ... display . set_pixel ( x , y , 9 ) sleep ( 100 ) Saisir le programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. V\u00e9rifier si le comportement anticip\u00e9 est conforme \u00e0 celui observ\u00e9. Compl\u00e9ter le programme en proc\u00e9dant de fa\u00e7on analogue pour d\u00e9terminer la valeur que doit en prendre l'ordonn\u00e9e du pixel y selon les valeurs de accelerometer.get_y()","title":"3.5 D\u00e9placer un point lumineux avec l'inclinaison de la carte"},{"location":"microbit/python_exercices/#4-detecter-lintensite-lumineuse","text":"","title":"4. D\u00e9tecter l'intensit\u00e9 lumineuse"},{"location":"microbit/python_exercices/#41-avec-les-leds-de-la-carte-microbit","text":"led Les LED de la carte peuvent d\u00e9tecter le niveau de lumi\u00e8re ambiante : la fonction display.read_light_level() renvoie une valeur comprise entre 0 et 255 : plus la valeur est \u00e9lev\u00e9e, plus l'environnement est lumineux. from microbit import * while True : niveau = display . read_light_level () if niveau > 220 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 200 ) Saisir ce programme et le flasher sur une carte connect\u00e9e \u00e0 l'ordinateur. Que faut-il faire pour que l'image Image.YES s'affiche ? Modifier ce programme pour que la carte affiche un carr\u00e9 en luminosit\u00e9 \"normale\" et un diamant dans la p\u00e9nombre.","title":"4.1 Avec les leds de la carte micro:bit"},{"location":"microbit/python_exercices/#42-avec-un-capteur-de-lumiere-grove","text":"led capteur de lumi\u00e8re Placer la carte micro-bit sur le shield Grove et connecter le capteur de lumi\u00e8re sur la broche P0-P14. La fonction pin0.read_analog() renvoie une valeur enti\u00e8re d'autant plus \u00e9lev\u00e9e que l'environnement est lumineux. Saisir et flasher le programme suivant : from microbit import * while True : mesure = pin0 . read_analog () if mesure > 600 : display . show ( Image . YES ) else : display . show ( Image . NO ) sleep ( 100 ) Que peut-on faire pour que l'image Image.NO s'affiche sur la carte micro:bit ? Emballer le capteur (connect\u00e9 \u00e0 la carte) dans une feuille de papier. Modifier le programme pour que la carte affiche l'image Image.YES tant que le capteur reste emball\u00e9 et l'image Image.NO d\u00e8s que l'emballage est ouvert.","title":"4.2 Avec un capteur de lumi\u00e8re Grove"},{"location":"microbit/python_exercices/#5-envoyer-des-messages-par-radio","text":"","title":"5. Envoyer des messages par radio"},{"location":"microbit/python_exercices/#51-envoyer-une-valeur","text":"led boutons radio Cet exercice n\u00e9cessite deux cartes : une carte mesure la temp\u00e9rature et envoie par radio la valeur mesur\u00e9e. Une autre carte re\u00e7oit les valeurs et les affiche. Programme sur la carte \u00e9mettrice from microbit import * import radio radio . on () while True : temperature = temperature () radio . send ( temperature ) sleep ( 1000 ) Programme sur la carte r\u00e9ceptrice from microbit import * import radio radio . on () while True : valeur = radio . receive () display . scroll ( valeur ) sleep ( 1000 ) Modifier le programme de la carte r\u00e9ceptrice pour qu'elle n'affiche plus la temp\u00e9rature mais affiche (Image.HAPPY) si la temp\u00e9rature est sup\u00e9rieure \u00e0 20\u00b0C et (Image.SAD) sinon. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 from microbit import * import radio radio . on () while True : valeur = radio . receive () if ... > 20 : display . show ( ... ) ... : display . show ( ... ) sleep ( 1000 ) Compl\u00e9ter le programme de la question pr\u00e9c\u00e9dente pour que la carte r\u00e9ceptrice affiche la temp\u00e9rature lorsqu'on appuie sur le bouton A. Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 from microbit import * import radio radio . on () while True : valeur = radio . receive () if ... > 20 : display . show ( ... ) ... : display . show ( ... ) if button_a . is_pressed (): ... sleep ( 1000 )","title":"5.1 Envoyer une valeur"},{"location":"microbit/python_grove/","text":"Le kit Grove pour micro:bit R\u00e9f\u00e9rence : Grove Inventor kit Le shield Ce shield est une carte d'interface permettant de raccorder facilement et sans soudure les capteurs et les actionneurs Grove de Seeedstudio sur une carte micro:bit. Ce shield comporte : 4 connecteurs Grove : I2C, P0/P14, P1/P15, P2/P16 8 connecteurs Edge pour pince crocodile ou fiche banane : 3V3, P0, P1, P2, P8, P12, P13, GND un port micro-USB permettant une alimentation de la carte micro:bit et des diff\u00e9rents capteurs et modules une LED verte de mise sous tension. R\u00e9f\u00e9rence : Grove Shield Capteurs Capteurs analogiques Si le capteur est branch\u00e9 sur la broche P0, la mesure analogique r\u00e9alis\u00e9e par le capteur est convertie en une valeur num\u00e9rique enti\u00e8re comprise entre 0 et 1023 que l'on lit avec l'instruction : pin0 . read_analog () Le potentiom\u00e8tre Le capteur d'angle rotatif (ou potentiom\u00e8tre) produit une sortie analogique variable selon l'angle de rotation. La plage angulaire est de 300 degr\u00e9s avec un changement lin\u00e9aire de valeur. R\u00e9f\u00e9rence : Grove-Rotary_Angle_Sensor Le capteur de lumi\u00e8re Le capteur Grove - Light int\u00e8gre une photo-r\u00e9sistance pour d\u00e9tecter l'intensit\u00e9 de la lumi\u00e8re. Le signal de sortie est une valeur analogique : plus la lumi\u00e8re est brillante, plus la valeur est \u00e9lev\u00e9e. R\u00e9f\u00e9rence : Grove-Light_Sensor Autres capteurs Le t\u00e9l\u00e9m\u00e8tre \u00e0 ultrasons R\u00e9f\u00e9rence : Grove-Ultrasonic_Ranger Le capteur de mouvements R\u00e9f\u00e9rences : Grove-Gesture Actionneurs Actionneur binaire Si l'actionneur est branch\u00e9 sur la broche P0, on l'active en \u00e9crivant la valeur 1, et on l'\u00e9teint en \u00e9crivant la valeur 0, \u00e0 l'aide des instructions : # active l'actionneur pin0 . write_digital ( 1 ) # d\u00e9sactive l'actionneur pin0 . write_digital ( 0 ) La LED La LED Rouge Grove abrite une source de lumi\u00e8re LED. De plus, ce module dispose d'un potentiom\u00e8tre embarqu\u00e9 pour g\u00e9rer les besoins en puissance de la LED. Branchement : la LED comporte un m\u00e9plat du c\u00f4t\u00e9 de la cathode, \u00e0 connecter au R\u00e9f\u00e9rence : Grove-Red_LED Autres actionneurs Le haut-parleur R\u00e9f\u00e9rence : Grove-Speaker L'\u00e9cran d'affichage (4 chiffres) R\u00e9f\u00e9rences : Grove-4-Digit_Display Le ruban de led NeoPixel Le ruban de LED comporte 30 NeoPixels et mesure 1 m\u00e8tre. Il est est \"waterproof\". Chaque NeoPixel comporte une LED RVB, un circuit \u00e9lectronique int\u00e9gr\u00e9 (le WS281), des donn\u00e9es entrantes et des donn\u00e9es sortantes. La biblioth\u00e8que neopixel comporte des m\u00e9thodes permettant d'utiliser le ruban. Chaque LED est adressable : le 1er NeoPixel a l'adresse 0, le suivant 1 etc. Instructions Effet import neopixel Importe la biblioth\u00e8que NeoPixel np = neopixel.NeoPixel(pin0, 30) D\u00e9clare un ruban nomm\u00e9 np de 30 NeoPixels sur la broche P0 np[i] = (r, v, b) Affecte au NeoPixel d'adresse i la couleur (r, v, b) np.show() Allume chaque NeoPixel du ruban np avec la couleur qui lui a \u00e9t\u00e9 affect\u00e9e np.clear() \u00c9teint toutes les leds du ruban np Exemple de programme : 1 2 3 4 5 6 7 8 from microbit import * import neopixel np = neopixel . NeoPixel ( pin0 , 30 ) np . clear () for x in range ( 30 ): np [ x ] = ( 240 - 8 * x , 0 , 8 * x ) np . show () sleep ( 100 ) L'ex\u00e9cution de ce programme provoque l'allumage progressif des 30 LED du ruban. Les premi\u00e8res LED sont rouges, et la couleur \u00e9volue au fur et \u00e0 mesure de l'avanc\u00e9e sur le ruban, les derni\u00e8res LED \u00e9tant bleues. R\u00e9f\u00e9rences : Un produit proche : Grove-RGB_LED_Stick Le module Neopixel dans la documentation microbit-micropython","title":"Le kit Grove"},{"location":"microbit/python_grove/#le-kit-grove-pour-microbit","text":"R\u00e9f\u00e9rence : Grove Inventor kit","title":"Le kit Grove pour micro:bit"},{"location":"microbit/python_grove/#le-shield","text":"Ce shield est une carte d'interface permettant de raccorder facilement et sans soudure les capteurs et les actionneurs Grove de Seeedstudio sur une carte micro:bit. Ce shield comporte : 4 connecteurs Grove : I2C, P0/P14, P1/P15, P2/P16 8 connecteurs Edge pour pince crocodile ou fiche banane : 3V3, P0, P1, P2, P8, P12, P13, GND un port micro-USB permettant une alimentation de la carte micro:bit et des diff\u00e9rents capteurs et modules une LED verte de mise sous tension. R\u00e9f\u00e9rence : Grove Shield","title":"Le shield"},{"location":"microbit/python_grove/#capteurs","text":"","title":"Capteurs"},{"location":"microbit/python_grove/#capteurs-analogiques","text":"Si le capteur est branch\u00e9 sur la broche P0, la mesure analogique r\u00e9alis\u00e9e par le capteur est convertie en une valeur num\u00e9rique enti\u00e8re comprise entre 0 et 1023 que l'on lit avec l'instruction : pin0 . read_analog () Le potentiom\u00e8tre Le capteur d'angle rotatif (ou potentiom\u00e8tre) produit une sortie analogique variable selon l'angle de rotation. La plage angulaire est de 300 degr\u00e9s avec un changement lin\u00e9aire de valeur. R\u00e9f\u00e9rence : Grove-Rotary_Angle_Sensor Le capteur de lumi\u00e8re Le capteur Grove - Light int\u00e8gre une photo-r\u00e9sistance pour d\u00e9tecter l'intensit\u00e9 de la lumi\u00e8re. Le signal de sortie est une valeur analogique : plus la lumi\u00e8re est brillante, plus la valeur est \u00e9lev\u00e9e. R\u00e9f\u00e9rence : Grove-Light_Sensor","title":"Capteurs analogiques"},{"location":"microbit/python_grove/#autres-capteurs","text":"Le t\u00e9l\u00e9m\u00e8tre \u00e0 ultrasons R\u00e9f\u00e9rence : Grove-Ultrasonic_Ranger Le capteur de mouvements R\u00e9f\u00e9rences : Grove-Gesture","title":"Autres capteurs"},{"location":"microbit/python_grove/#actionneurs","text":"","title":"Actionneurs"},{"location":"microbit/python_grove/#actionneur-binaire","text":"Si l'actionneur est branch\u00e9 sur la broche P0, on l'active en \u00e9crivant la valeur 1, et on l'\u00e9teint en \u00e9crivant la valeur 0, \u00e0 l'aide des instructions : # active l'actionneur pin0 . write_digital ( 1 ) # d\u00e9sactive l'actionneur pin0 . write_digital ( 0 ) La LED La LED Rouge Grove abrite une source de lumi\u00e8re LED. De plus, ce module dispose d'un potentiom\u00e8tre embarqu\u00e9 pour g\u00e9rer les besoins en puissance de la LED. Branchement : la LED comporte un m\u00e9plat du c\u00f4t\u00e9 de la cathode, \u00e0 connecter au R\u00e9f\u00e9rence : Grove-Red_LED","title":"Actionneur binaire"},{"location":"microbit/python_grove/#autres-actionneurs","text":"Le haut-parleur R\u00e9f\u00e9rence : Grove-Speaker L'\u00e9cran d'affichage (4 chiffres) R\u00e9f\u00e9rences : Grove-4-Digit_Display Le ruban de led NeoPixel Le ruban de LED comporte 30 NeoPixels et mesure 1 m\u00e8tre. Il est est \"waterproof\". Chaque NeoPixel comporte une LED RVB, un circuit \u00e9lectronique int\u00e9gr\u00e9 (le WS281), des donn\u00e9es entrantes et des donn\u00e9es sortantes. La biblioth\u00e8que neopixel comporte des m\u00e9thodes permettant d'utiliser le ruban. Chaque LED est adressable : le 1er NeoPixel a l'adresse 0, le suivant 1 etc. Instructions Effet import neopixel Importe la biblioth\u00e8que NeoPixel np = neopixel.NeoPixel(pin0, 30) D\u00e9clare un ruban nomm\u00e9 np de 30 NeoPixels sur la broche P0 np[i] = (r, v, b) Affecte au NeoPixel d'adresse i la couleur (r, v, b) np.show() Allume chaque NeoPixel du ruban np avec la couleur qui lui a \u00e9t\u00e9 affect\u00e9e np.clear() \u00c9teint toutes les leds du ruban np Exemple de programme : 1 2 3 4 5 6 7 8 from microbit import * import neopixel np = neopixel . NeoPixel ( pin0 , 30 ) np . clear () for x in range ( 30 ): np [ x ] = ( 240 - 8 * x , 0 , 8 * x ) np . show () sleep ( 100 ) L'ex\u00e9cution de ce programme provoque l'allumage progressif des 30 LED du ruban. Les premi\u00e8res LED sont rouges, et la couleur \u00e9volue au fur et \u00e0 mesure de l'avanc\u00e9e sur le ruban, les derni\u00e8res LED \u00e9tant bleues. R\u00e9f\u00e9rences : Un produit proche : Grove-RGB_LED_Stick Le module Neopixel dans la documentation microbit-micropython","title":"Autres actionneurs"},{"location":"microbit/python_leds5x5/","text":"Les LED L'objet display La matrice LED comporte 25 LED. On peut l'utiliser pour afficher des caract\u00e8res, des images, faire d\u00e9filer un message, etc. Info L'\u00e9cran est un objet nomm\u00e9 display . On applique \u00e0 cet objet des m\u00e9thodes selon la syntaxe : display.methode(parametres) o\u00f9 methode est \u00e0 choisir dans la liste suivante : clear show scroll on off is_on set_pixel get_pixel La compl\u00e9tion automatique de l'\u00e9diteur mu permet d'acc\u00e9der \u00e0 cette liste d\u00e8s que l'on saisit display. Afficher des caract\u00e8res, des messages Instructions Effet display.show(0) Affiche 0 sur la matrice LED display.show('A') Affiche A sur la matrice LED display.show('ABCDE') Affiche un par un les caract\u00e8res A, B, C, D et E sur la matrice LED Faire d\u00e9filer des messages Instructions Effet display.scroll('ABCDE') Fait d\u00e9filer de droite \u00e0 gauche les caract\u00e8res A, B, C, D et E sur la matrice LED display.scroll('ABCDE', delay=250, loop=False) Fait d\u00e9filer de droite \u00e0 gauche les caract\u00e8res A, B, C, D et E sur la matrice LED Allumer des pixels Info Chaque pixel a des coodonn\u00e9es enti\u00e8res, de (0,0) dans le coin sup\u00e9rieur gauche \u00e0 (4, 4) dans le coin inf\u00e9rieur droit. La luminosit\u00e9 de chaque pixel peut \u00eatre d\u00e9finie, de 0 (le pixel est alors d\u00e9sactiv\u00e9) \u00e0 9 (niveau le plus lumineux). Instructions Effet display.set_pixel(x, y, lum) Allume le pixel aux coordonn\u00e9es (x,y) avec un niveau de luminosit\u00e9 lum (entier entre 0 et 9) display.get_pixel(x, y) Renvoie le niveau de luminosit\u00e9 du pixel de coordonn\u00e9es (x,y) Afficher des images Afficher des images pr\u00e9-d\u00e9finies Info Il existe des images pr\u00e9d\u00e9finies que l'on peut afficher en utilisant leur nom et la syntaxe Image.nom Voici la liste des images pr\u00e9d\u00e9finies, par ordre alphab\u00e9tique : ANGRY - ASLEEP - BUTTERFLY - CHESSBOARD - CONFUSED - COW - DIAMOND - DIAMOND_SMALL - DUCK - FABULOUS - GHOST - GIRAFFE - HAPPY - HEART - HEART_SMALL - HOUSE - MEH - MUSIC_CROTCHET - MUSIC_QUAVER - MUSIC_QUAVERS - NO - PACMAN - PITCHFORK - RABBIT - ROLLERSKATE - SAD - SILLY - SKULL - SMILE - SNAKE - SQUARE - SQUARE_SMALL - STICKFIGURE - SURPRISED - SWORD - TARGET - TORTOISE - TRIANGLE - TRIANGLE_LEFT - TSHIRT - UMBRELLA - XMAS - YES Il existe \u00e9galement deux s\u00e9ries d'images : les fl\u00e8ches : ARROW_N, ARROW_NE, ARROW_E, ARROW_SE, ARROW_S, ARROW_SW, ARROW_W, ARROW_NW les heures : CLOCK12, CLOCK11, CLOCK10, CLOCK9, CLOCK8, CLOCK7, CLOCK6, CLOCK5, CLOCK4, CLOCK3, CLOCK2, CLOCK1 D\u00e9finir ses propres images Info On peut d\u00e9finir une image en affectant \u00e0 chaque pixel son niveau de luminosit\u00e9, soit ligne par ligne: eclat = Image ( \"00300:\" \"03630:\" \"36963:\" \"03630:\" \"00300\" ) soit en une seule ligne : eclat = Image ( \"00300:03630:36963:03630:00300\" ) Instructions Effet display.show(Image.HEART) Affiche un c\u0153ur sur la matrice LED display.show(mon_image) Affiche l'image d\u00e9finie par la variable mon_image Pour aller plus loin La classe Image contient des m\u00e9thodes pour cr\u00e9er et manipuler des images. Par exemple, mon_image = Image () mon_image . fill ( 7 ) cr\u00e9e une image o\u00f9 tous les pixels ont une luninosit\u00e9 de 7. Afficher des pixels al\u00e9atoires Info Le module random contient la fonction randint(min,max) qui renvoie un entier entre min et max compris. On peut l'utiliser pour d\u00e9finir al\u00e9atoirement la position d'un pixel ou la luminosit\u00e9 d'un pixel. from microbit import * from random import randint for i in range ( 5 ): # num\u00e9ro de colonne de 0 \u00e0 4 for j in range ( 5 ): # num\u00e9ro de ligne de 0 \u00e0 4 display . set_pixel ( i , j , randint ( 0 , 9 )) Animer des images Info Pour cr\u00e9er une animation affichant successivement plusieurs images, cr\u00e9er une liste contenant toutes les images, puis afficher cette liste. mes_images = [ Image . HEART , Image . HEART_SMALL ] display . show ( mes_images , delay = 400 , loop = True ) Instructions Effet display.show(mes_images, delay=400, loop=True) Affiche en boucle les images de la liste mes_images , chacune \u00e9tant affich\u00e9e pendant 400 ms avant d'\u00eatre remplac\u00e9e par la suivante display.show(mes_images, delay=400, loop=False) Affiche une fois chaque image de la liste mes_images , chacune \u00e9tant affich\u00e9e pendant 400 ms avant d'\u00eatre remplac\u00e9e par la suivante Effacer l'\u00e9cran Instructions Effet display.clear() \u00c9teint toutes les LED en leur affectant une luminosit\u00e9 \u00e0 0 Allumer / \u00e9teindre l'\u00e9cran Instructions Effet display.on() Allume chaque LED avec sa propre valeur de luminosit\u00e9 display.off() \u00c9teint chaque LED mais n'efface pas sa propre valeur de luminosit\u00e9 display.is_on() Allume chaque LED avec sa propre valeur de luminosit\u00e9 D\u00e9tecter le niveau de lumi\u00e8re ambiante Info Les LED de l\u2019\u00e9cran peuvent d\u00e9tecter la quantit\u00e9 de lumi\u00e8re arrivant sur l\u2019\u00e9cran. Instructions Effet display.read_light_level() Renvoie un entier compris entre 0 et 255 repr\u00e9sentant le niveau de lumi\u00e8re R\u00e9f\u00e9rences Le module Display : documentation microbit-micropython La classe Image","title":"Les LED"},{"location":"microbit/python_leds5x5/#les-led","text":"","title":"Les LED"},{"location":"microbit/python_leds5x5/#lobjet-display","text":"La matrice LED comporte 25 LED. On peut l'utiliser pour afficher des caract\u00e8res, des images, faire d\u00e9filer un message, etc. Info L'\u00e9cran est un objet nomm\u00e9 display . On applique \u00e0 cet objet des m\u00e9thodes selon la syntaxe : display.methode(parametres) o\u00f9 methode est \u00e0 choisir dans la liste suivante : clear show scroll on off is_on set_pixel get_pixel La compl\u00e9tion automatique de l'\u00e9diteur mu permet d'acc\u00e9der \u00e0 cette liste d\u00e8s que l'on saisit display.","title":"L'objet display"},{"location":"microbit/python_leds5x5/#afficher-des-caracteres-des-messages","text":"Instructions Effet display.show(0) Affiche 0 sur la matrice LED display.show('A') Affiche A sur la matrice LED display.show('ABCDE') Affiche un par un les caract\u00e8res A, B, C, D et E sur la matrice LED","title":"Afficher des caract\u00e8res, des messages"},{"location":"microbit/python_leds5x5/#faire-defiler-des-messages","text":"Instructions Effet display.scroll('ABCDE') Fait d\u00e9filer de droite \u00e0 gauche les caract\u00e8res A, B, C, D et E sur la matrice LED display.scroll('ABCDE', delay=250, loop=False) Fait d\u00e9filer de droite \u00e0 gauche les caract\u00e8res A, B, C, D et E sur la matrice LED","title":"Faire d\u00e9filer des messages"},{"location":"microbit/python_leds5x5/#allumer-des-pixels","text":"Info Chaque pixel a des coodonn\u00e9es enti\u00e8res, de (0,0) dans le coin sup\u00e9rieur gauche \u00e0 (4, 4) dans le coin inf\u00e9rieur droit. La luminosit\u00e9 de chaque pixel peut \u00eatre d\u00e9finie, de 0 (le pixel est alors d\u00e9sactiv\u00e9) \u00e0 9 (niveau le plus lumineux). Instructions Effet display.set_pixel(x, y, lum) Allume le pixel aux coordonn\u00e9es (x,y) avec un niveau de luminosit\u00e9 lum (entier entre 0 et 9) display.get_pixel(x, y) Renvoie le niveau de luminosit\u00e9 du pixel de coordonn\u00e9es (x,y)","title":"Allumer des pixels"},{"location":"microbit/python_leds5x5/#afficher-des-images","text":"","title":"Afficher des images"},{"location":"microbit/python_leds5x5/#afficher-des-images-pre-definies","text":"Info Il existe des images pr\u00e9d\u00e9finies que l'on peut afficher en utilisant leur nom et la syntaxe Image.nom Voici la liste des images pr\u00e9d\u00e9finies, par ordre alphab\u00e9tique : ANGRY - ASLEEP - BUTTERFLY - CHESSBOARD - CONFUSED - COW - DIAMOND - DIAMOND_SMALL - DUCK - FABULOUS - GHOST - GIRAFFE - HAPPY - HEART - HEART_SMALL - HOUSE - MEH - MUSIC_CROTCHET - MUSIC_QUAVER - MUSIC_QUAVERS - NO - PACMAN - PITCHFORK - RABBIT - ROLLERSKATE - SAD - SILLY - SKULL - SMILE - SNAKE - SQUARE - SQUARE_SMALL - STICKFIGURE - SURPRISED - SWORD - TARGET - TORTOISE - TRIANGLE - TRIANGLE_LEFT - TSHIRT - UMBRELLA - XMAS - YES Il existe \u00e9galement deux s\u00e9ries d'images : les fl\u00e8ches : ARROW_N, ARROW_NE, ARROW_E, ARROW_SE, ARROW_S, ARROW_SW, ARROW_W, ARROW_NW les heures : CLOCK12, CLOCK11, CLOCK10, CLOCK9, CLOCK8, CLOCK7, CLOCK6, CLOCK5, CLOCK4, CLOCK3, CLOCK2, CLOCK1","title":"Afficher des images pr\u00e9-d\u00e9finies"},{"location":"microbit/python_leds5x5/#definir-ses-propres-images","text":"Info On peut d\u00e9finir une image en affectant \u00e0 chaque pixel son niveau de luminosit\u00e9, soit ligne par ligne: eclat = Image ( \"00300:\" \"03630:\" \"36963:\" \"03630:\" \"00300\" ) soit en une seule ligne : eclat = Image ( \"00300:03630:36963:03630:00300\" ) Instructions Effet display.show(Image.HEART) Affiche un c\u0153ur sur la matrice LED display.show(mon_image) Affiche l'image d\u00e9finie par la variable mon_image Pour aller plus loin La classe Image contient des m\u00e9thodes pour cr\u00e9er et manipuler des images. Par exemple, mon_image = Image () mon_image . fill ( 7 ) cr\u00e9e une image o\u00f9 tous les pixels ont une luninosit\u00e9 de 7.","title":"D\u00e9finir ses propres images"},{"location":"microbit/python_leds5x5/#afficher-des-pixels-aleatoires","text":"Info Le module random contient la fonction randint(min,max) qui renvoie un entier entre min et max compris. On peut l'utiliser pour d\u00e9finir al\u00e9atoirement la position d'un pixel ou la luminosit\u00e9 d'un pixel. from microbit import * from random import randint for i in range ( 5 ): # num\u00e9ro de colonne de 0 \u00e0 4 for j in range ( 5 ): # num\u00e9ro de ligne de 0 \u00e0 4 display . set_pixel ( i , j , randint ( 0 , 9 ))","title":"Afficher des pixels al\u00e9atoires"},{"location":"microbit/python_leds5x5/#animer-des-images","text":"Info Pour cr\u00e9er une animation affichant successivement plusieurs images, cr\u00e9er une liste contenant toutes les images, puis afficher cette liste. mes_images = [ Image . HEART , Image . HEART_SMALL ] display . show ( mes_images , delay = 400 , loop = True ) Instructions Effet display.show(mes_images, delay=400, loop=True) Affiche en boucle les images de la liste mes_images , chacune \u00e9tant affich\u00e9e pendant 400 ms avant d'\u00eatre remplac\u00e9e par la suivante display.show(mes_images, delay=400, loop=False) Affiche une fois chaque image de la liste mes_images , chacune \u00e9tant affich\u00e9e pendant 400 ms avant d'\u00eatre remplac\u00e9e par la suivante","title":"Animer des images"},{"location":"microbit/python_leds5x5/#effacer-lecran","text":"Instructions Effet display.clear() \u00c9teint toutes les LED en leur affectant une luminosit\u00e9 \u00e0 0","title":"Effacer l'\u00e9cran"},{"location":"microbit/python_leds5x5/#allumer-eteindre-lecran","text":"Instructions Effet display.on() Allume chaque LED avec sa propre valeur de luminosit\u00e9 display.off() \u00c9teint chaque LED mais n'efface pas sa propre valeur de luminosit\u00e9 display.is_on() Allume chaque LED avec sa propre valeur de luminosit\u00e9","title":"Allumer / \u00e9teindre l'\u00e9cran"},{"location":"microbit/python_leds5x5/#detecter-le-niveau-de-lumiere-ambiante","text":"Info Les LED de l\u2019\u00e9cran peuvent d\u00e9tecter la quantit\u00e9 de lumi\u00e8re arrivant sur l\u2019\u00e9cran. Instructions Effet display.read_light_level() Renvoie un entier compris entre 0 et 255 repr\u00e9sentant le niveau de lumi\u00e8re","title":"D\u00e9tecter le niveau de lumi\u00e8re ambiante"},{"location":"microbit/python_leds5x5/#references","text":"Le module Display : documentation microbit-micropython La classe Image","title":"R\u00e9f\u00e9rences"},{"location":"microbit/python_mu/","text":"Utiliser l'\u00e9diteur Mu Mu est un \u00e9diteur de code simple pour programmeurs d\u00e9butants. Il est d\u00e9velopp\u00e9 en Python et fonctionne sur Windows, MacOS, Linux et Raspberry Pi. Une version portable peut \u00e9galement \u00eatre ex\u00e9cut\u00e9e depuis une cl\u00e9 USB sur Windows et MacOS. Cette interface dispose de l'auto-compl\u00e9tion et d'une indentation automatique, ainsi que d'une version en fran\u00e7ais. Choisir le mode micro:bit Mu propose diff\u00e9rents modes dont l'un est destin\u00e9 \u00e0 la carte micro:bit. On peut \u00e9galement choisir d'autres cartes ou Python 3 standard. ( en savoir plus ) G\u00e9rer ses fichiers .py On peut cr\u00e9er un nouveau fichier .py , en charger un depuis l'ordinateur ou en enregistrer un sur l'ordinateur. Un r\u00e9pertoire mu_code est cr\u00e9\u00e9 par d\u00e9faut mais les programmes peuvent \u00eatre enregistr\u00e9s \u00e0 tout emplacement usuel. Avec une micro:bit connect\u00e9e Remarque Ces quatre boutons n\u00e9cessitent pour fonctionner qu'une carte soit connect\u00e9e \u00e0 l'ordinateur (par un c\u00e2ble USB). Flasher Le bouton \u00ab Flasher \u00bb place le code Python pr\u00e9sent dans la fen\u00eatre d'\u00e9dition sur la carte micro:bit connect\u00e9e. Le processus de flash prend environ 10 secondes, pendant lesquelles une LED orange clignote \u00e0 l'arri\u00e8re de la carte. Apr\u00e8s cette op\u00e9ration, tous les codes et donn\u00e9es pr\u00e9c\u00e9dents ont \u00e9t\u00e9 supprim\u00e9s. Si le programme utilise une biblioth\u00e8que, il est alors n\u00e9cessaire de la charger \u00e0 nouveau. (voir Fichiers) Si le code contient une erreur, un message d\u00e9file sur l'\u00e9cran de la carte, mais il n'est pas toujours ais\u00e9 de le lire. Flasher un programme avec MacOS Catalina Sur les syst\u00e8mes MacOS \u00e0 partir de Catalina, il faut disposer des droits suffisants pour que Mu \u00e9crive sur la carte micro:bit. Le moyen le plus simple d'y parvenir est d'ex\u00e9cuter Mu comme administrateur en tapant les instructions suivantes dans un terminal : $ cd /Applications $ sudo open mu-editor.app Fichiers Remarque Cette fonctionnalit\u00e9 n\u00e9cessite qu'un programme MicroPython ait \u00e9t\u00e9 flash\u00e9 sur l'appareil. Le bouton \u00ab Fichiers \u00bb de Mu acc\u00e8de \u00e0 un syst\u00e8me de fichiers et facilite l'acc\u00e8s, le placement, l'obtention et la suppression de fichiers sur l'appareil. Il ouvre deux volets : le volet de gauche r\u00e9pertorie tous les fichiers de la carte micro:bit, le volet de droite r\u00e9pertorie tous les fichiers du r\u00e9pertoire mu_code sur l'ordinateur. Faire glisser les fichiers de l'un \u00e0 l'autre pour les copier. Pour supprimer un fichier sur la carte, cliquer dessus avec le bouton droit de la souris et s\u00e9lectionner \u00ab Supprimer \u00bb. REPL Le bouton \u00ab REPL \u00bb cr\u00e9e un nouveau volet entre l'\u00e9diteur de texte et le pied de page de Mu. Il s'agit d'un interpr\u00e9teur interactif qui se connecte au MicroPython REPL sur la carte micro:bit. Le terme \u00ab REPL \u00bb est un acronyme qui signifie \u00ab Read, Evaluate, Print, Loop \u00bb : l'interpr\u00e9teur lit les lignes de Python, \u00e9value ce que cela peut signifier, affiche tout r\u00e9sultat (dans l'interpr\u00e9teur ou sur la carte, selon l'instruction), puis revient en boucle pour attendre la prochaine instruction Python. L'ouverture du volet REPL interrompt l'ex\u00e9cution du programme en cours : pour le faire re-d\u00e9marrer on peut soit actionner le bouton \u00e0 l'arri\u00e8re de la carte, soit taper Ctrl + D . Graphique Enfin, le bouton \u00ab Graphique \u00bb ouvre le traceur de Mu. Si la carte micro:bit produit des p-uplets ( tuples ) de nombres via la connexion s\u00e9rie, le traceur les affichera sous forme graphique. La sortie est constitu\u00e9e de courbes, avec le temps en abscisses et les valeurs des donn\u00e9es en ordonn\u00e9es. Attention Le mod\u00e8le habituel pour \u00e9mettre des p-uplets est de le faire dans une boucle. Il faut inclure une pause dans la boucle pour que le traceur fonctionne correctement. Sinon, il y a un risque que le code inonde le traceur de donn\u00e9es, et il ne pourra pas suivre. La meilleure fa\u00e7on d'y parvenir est d'utiliser time.sleep() (mesure en secondes) ou microbit.sleep() (mesure en millisecondes). Exemple L'instruction print((mesure,)) permet au traceur de repr\u00e9senter la valeur de la mesure en fonction du temps. Aspect Les boutons de ce groupe permettent de r\u00e9gler quelques param\u00e8tres d'affichage (zoom, mode sombre) et notamment de vid\u00e9oprojeter du code dans de bonnes conditions. Divers Ce dernier groupe comporte un bouton de v\u00e9rification du code, qui d\u00e9tecte plusieurs types d'erreurs (syntaxe, indentation, ... ) ou non-respect des recommandation de la PEP8 . Certains messages sont traduits en fran\u00e7ais, d'autres non. Lorsqu'aucune erreur n'est d\u00e9tect\u00e9e, un message l'indique en bas de la fen\u00eatre.","title":"Utiliser l'\u00e9diteur Mu"},{"location":"microbit/python_mu/#utiliser-lediteur-mu","text":"Mu est un \u00e9diteur de code simple pour programmeurs d\u00e9butants. Il est d\u00e9velopp\u00e9 en Python et fonctionne sur Windows, MacOS, Linux et Raspberry Pi. Une version portable peut \u00e9galement \u00eatre ex\u00e9cut\u00e9e depuis une cl\u00e9 USB sur Windows et MacOS. Cette interface dispose de l'auto-compl\u00e9tion et d'une indentation automatique, ainsi que d'une version en fran\u00e7ais.","title":"Utiliser l'\u00e9diteur Mu"},{"location":"microbit/python_mu/#choisir-le-mode-microbit","text":"Mu propose diff\u00e9rents modes dont l'un est destin\u00e9 \u00e0 la carte micro:bit. On peut \u00e9galement choisir d'autres cartes ou Python 3 standard. ( en savoir plus )","title":"Choisir le mode micro:bit"},{"location":"microbit/python_mu/#gerer-ses-fichiers-py","text":"On peut cr\u00e9er un nouveau fichier .py , en charger un depuis l'ordinateur ou en enregistrer un sur l'ordinateur. Un r\u00e9pertoire mu_code est cr\u00e9\u00e9 par d\u00e9faut mais les programmes peuvent \u00eatre enregistr\u00e9s \u00e0 tout emplacement usuel.","title":"G\u00e9rer ses fichiers .py"},{"location":"microbit/python_mu/#avec-une-microbit-connectee","text":"Remarque Ces quatre boutons n\u00e9cessitent pour fonctionner qu'une carte soit connect\u00e9e \u00e0 l'ordinateur (par un c\u00e2ble USB).","title":"Avec une micro:bit connect\u00e9e"},{"location":"microbit/python_mu/#flasher","text":"Le bouton \u00ab Flasher \u00bb place le code Python pr\u00e9sent dans la fen\u00eatre d'\u00e9dition sur la carte micro:bit connect\u00e9e. Le processus de flash prend environ 10 secondes, pendant lesquelles une LED orange clignote \u00e0 l'arri\u00e8re de la carte. Apr\u00e8s cette op\u00e9ration, tous les codes et donn\u00e9es pr\u00e9c\u00e9dents ont \u00e9t\u00e9 supprim\u00e9s. Si le programme utilise une biblioth\u00e8que, il est alors n\u00e9cessaire de la charger \u00e0 nouveau. (voir Fichiers) Si le code contient une erreur, un message d\u00e9file sur l'\u00e9cran de la carte, mais il n'est pas toujours ais\u00e9 de le lire. Flasher un programme avec MacOS Catalina Sur les syst\u00e8mes MacOS \u00e0 partir de Catalina, il faut disposer des droits suffisants pour que Mu \u00e9crive sur la carte micro:bit. Le moyen le plus simple d'y parvenir est d'ex\u00e9cuter Mu comme administrateur en tapant les instructions suivantes dans un terminal : $ cd /Applications $ sudo open mu-editor.app","title":"Flasher"},{"location":"microbit/python_mu/#fichiers","text":"Remarque Cette fonctionnalit\u00e9 n\u00e9cessite qu'un programme MicroPython ait \u00e9t\u00e9 flash\u00e9 sur l'appareil. Le bouton \u00ab Fichiers \u00bb de Mu acc\u00e8de \u00e0 un syst\u00e8me de fichiers et facilite l'acc\u00e8s, le placement, l'obtention et la suppression de fichiers sur l'appareil. Il ouvre deux volets : le volet de gauche r\u00e9pertorie tous les fichiers de la carte micro:bit, le volet de droite r\u00e9pertorie tous les fichiers du r\u00e9pertoire mu_code sur l'ordinateur. Faire glisser les fichiers de l'un \u00e0 l'autre pour les copier. Pour supprimer un fichier sur la carte, cliquer dessus avec le bouton droit de la souris et s\u00e9lectionner \u00ab Supprimer \u00bb.","title":"Fichiers"},{"location":"microbit/python_mu/#repl","text":"Le bouton \u00ab REPL \u00bb cr\u00e9e un nouveau volet entre l'\u00e9diteur de texte et le pied de page de Mu. Il s'agit d'un interpr\u00e9teur interactif qui se connecte au MicroPython REPL sur la carte micro:bit. Le terme \u00ab REPL \u00bb est un acronyme qui signifie \u00ab Read, Evaluate, Print, Loop \u00bb : l'interpr\u00e9teur lit les lignes de Python, \u00e9value ce que cela peut signifier, affiche tout r\u00e9sultat (dans l'interpr\u00e9teur ou sur la carte, selon l'instruction), puis revient en boucle pour attendre la prochaine instruction Python. L'ouverture du volet REPL interrompt l'ex\u00e9cution du programme en cours : pour le faire re-d\u00e9marrer on peut soit actionner le bouton \u00e0 l'arri\u00e8re de la carte, soit taper Ctrl + D .","title":"REPL"},{"location":"microbit/python_mu/#graphique","text":"Enfin, le bouton \u00ab Graphique \u00bb ouvre le traceur de Mu. Si la carte micro:bit produit des p-uplets ( tuples ) de nombres via la connexion s\u00e9rie, le traceur les affichera sous forme graphique. La sortie est constitu\u00e9e de courbes, avec le temps en abscisses et les valeurs des donn\u00e9es en ordonn\u00e9es. Attention Le mod\u00e8le habituel pour \u00e9mettre des p-uplets est de le faire dans une boucle. Il faut inclure une pause dans la boucle pour que le traceur fonctionne correctement. Sinon, il y a un risque que le code inonde le traceur de donn\u00e9es, et il ne pourra pas suivre. La meilleure fa\u00e7on d'y parvenir est d'utiliser time.sleep() (mesure en secondes) ou microbit.sleep() (mesure en millisecondes). Exemple L'instruction print((mesure,)) permet au traceur de repr\u00e9senter la valeur de la mesure en fonction du temps.","title":"Graphique"},{"location":"microbit/python_mu/#aspect","text":"Les boutons de ce groupe permettent de r\u00e9gler quelques param\u00e8tres d'affichage (zoom, mode sombre) et notamment de vid\u00e9oprojeter du code dans de bonnes conditions.","title":"Aspect"},{"location":"microbit/python_mu/#divers","text":"Ce dernier groupe comporte un bouton de v\u00e9rification du code, qui d\u00e9tecte plusieurs types d'erreurs (syntaxe, indentation, ... ) ou non-respect des recommandation de la PEP8 . Certains messages sont traduits en fran\u00e7ais, d'autres non. Lorsqu'aucune erreur n'est d\u00e9tect\u00e9e, un message l'indique en bas de la fen\u00eatre.","title":"Divers"},{"location":"microbit/python_radio/","text":"La communication radio Fonctionnalit\u00e9s de base La fonctionnalit\u00e9 radio permet d'\u00e9changer des messages avec une ou plusieurs cartes micro:bit. Il faut au moins deux cartes et chacune comporte un programme (qui peut \u00eatre commun si les r\u00f4les sont sym\u00e9triques). Instructions Effet import radio Importe la biblioth\u00e8que radio radio.on() Active la fonctionnalit\u00e9 radio radio.send(message) Envoie un message de type chaine de caract\u00e8res radio.receive() Prend pour valeur la chaine de caract\u00e8res re\u00e7ue Exemple Ce programme n\u00e9cessite deux cartes : un appui sur un bouton de la carte \u00e9mettrice provoque un affichage sur la carte r\u00e9ceptrice. En cas d'appui sur le bouton A, on affiche Image.YES et en cas d'appui sur le bouton B, on affiche Image.NO . Programme sur la carte \u00e9mettrice from microbit import * import radio radio . on () while True : if button_a . was_pressed (): radio . send ( \"A\" ) elif button_b . was_pressed (): radio . send ( \"B\" ) Programme sur la carte r\u00e9ceptrice from microbit import * import radio radio . on () while True : incoming = radio . receive () if incoming == \"A\" : display . show ( Image . YES ) sleep ( 200 ) elif incoming == \"B\" : display . show ( Image . NO ) sleep ( 200 ) display . clear () Fonctionnalit\u00e9s avanc\u00e9es Il est possible de configurer certains param\u00e8tres : la fr\u00e9quence d'\u00e9mission (entre 2,4GHz et 2,5Ghz selon le canal choisi), l'adresse ou le groupe. Seules les cartes poss\u00e9dant le m\u00eame canal, la m\u00eame adresse et le m\u00eame num\u00e9ro de groupe communiqueront. Instructions Effet radio.config(channel=7) Configure la fr\u00e9quence d'\u00e9mission : la valeur est un num\u00e9ro entre 0 et 83 radio.config(address=0x75626974) Configure l'adresse, cod\u00e9e sur 4 octets radio.config(group=0) Configure le groupe : au sein d'une m\u00eame adresse, 256 groupes num\u00e9rot\u00e9s de 0 \u00e0 255 peuvent cohabiter radio.config(queue=3) Fixe \u00e0 3 le nombre de messages dans la file d'attente. Au del\u00e0 de 3 messages en attente, ils seront supprim\u00e9s. radio.config(length=32) Fixe la longueur maximum du message ( 32 octets par d\u00e9faut, 251 au maximum). radio.config(power=6) Fixe la puissance d'\u00e9mission du signal, de 0 \u00e0 7 radio.config(data_rate=radio.RATE_1MBIT) Fixe la vitesse de transmission parmi RATE_250KBIT , RATE_1MBIT ou RATE_2MBIT radio.reset() R\u00e9initialise les param\u00e8tres aux r\u00e9glages par d\u00e9faut radio.off() D\u00e9sactive la fonctionnalit\u00e9 radio","title":"La communication radio"},{"location":"microbit/python_radio/#la-communication-radio","text":"","title":"La communication radio"},{"location":"microbit/python_radio/#fonctionnalites-de-base","text":"La fonctionnalit\u00e9 radio permet d'\u00e9changer des messages avec une ou plusieurs cartes micro:bit. Il faut au moins deux cartes et chacune comporte un programme (qui peut \u00eatre commun si les r\u00f4les sont sym\u00e9triques). Instructions Effet import radio Importe la biblioth\u00e8que radio radio.on() Active la fonctionnalit\u00e9 radio radio.send(message) Envoie un message de type chaine de caract\u00e8res radio.receive() Prend pour valeur la chaine de caract\u00e8res re\u00e7ue","title":"Fonctionnalit\u00e9s de base"},{"location":"microbit/python_radio/#exemple","text":"Ce programme n\u00e9cessite deux cartes : un appui sur un bouton de la carte \u00e9mettrice provoque un affichage sur la carte r\u00e9ceptrice. En cas d'appui sur le bouton A, on affiche Image.YES et en cas d'appui sur le bouton B, on affiche Image.NO . Programme sur la carte \u00e9mettrice from microbit import * import radio radio . on () while True : if button_a . was_pressed (): radio . send ( \"A\" ) elif button_b . was_pressed (): radio . send ( \"B\" ) Programme sur la carte r\u00e9ceptrice from microbit import * import radio radio . on () while True : incoming = radio . receive () if incoming == \"A\" : display . show ( Image . YES ) sleep ( 200 ) elif incoming == \"B\" : display . show ( Image . NO ) sleep ( 200 ) display . clear ()","title":"Exemple"},{"location":"microbit/python_radio/#fonctionnalites-avancees","text":"Il est possible de configurer certains param\u00e8tres : la fr\u00e9quence d'\u00e9mission (entre 2,4GHz et 2,5Ghz selon le canal choisi), l'adresse ou le groupe. Seules les cartes poss\u00e9dant le m\u00eame canal, la m\u00eame adresse et le m\u00eame num\u00e9ro de groupe communiqueront. Instructions Effet radio.config(channel=7) Configure la fr\u00e9quence d'\u00e9mission : la valeur est un num\u00e9ro entre 0 et 83 radio.config(address=0x75626974) Configure l'adresse, cod\u00e9e sur 4 octets radio.config(group=0) Configure le groupe : au sein d'une m\u00eame adresse, 256 groupes num\u00e9rot\u00e9s de 0 \u00e0 255 peuvent cohabiter radio.config(queue=3) Fixe \u00e0 3 le nombre de messages dans la file d'attente. Au del\u00e0 de 3 messages en attente, ils seront supprim\u00e9s. radio.config(length=32) Fixe la longueur maximum du message ( 32 octets par d\u00e9faut, 251 au maximum). radio.config(power=6) Fixe la puissance d'\u00e9mission du signal, de 0 \u00e0 7 radio.config(data_rate=radio.RATE_1MBIT) Fixe la vitesse de transmission parmi RATE_250KBIT , RATE_1MBIT ou RATE_2MBIT radio.reset() R\u00e9initialise les param\u00e8tres aux r\u00e9glages par d\u00e9faut radio.off() D\u00e9sactive la fonctionnalit\u00e9 radio","title":"Fonctionnalit\u00e9s avanc\u00e9es"},{"location":"microbit/scratch/","text":"Utiliser la carte micro:bit avec Scratch Programmer la carte avec Scratch L' interface de programmation Scratch s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur ou tablette. La connexion avec la carte micro:bit utilise le bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, ou sur le drapeau vert, etc. Sur ordinateur (Windows, macOS), lancer Scratch Link , \u00e0 installer au pr\u00e9alable : lien de t\u00e9l\u00e9chargement et instructions Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le fichier scratch-microbit.hex sur la carte micro:bit : lien de t\u00e9l\u00e9chargement et instructions Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l' interface de programmation Scratch Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension micro:bit . Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. La possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Exemple 1 : crabe et diamants Par exemple, dans le programme Crabe et diamants disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Exemple 2 : roulis et tangage Sur cet autre exemple, Roulis et tangage , les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : un nuage de points donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). Exemple 3 : labyrinthe Un lutin se d\u00e9place dans un labyrinthe (sans franchir les murs) selon l'inclinaison de la carte micro:bit. - version avec blocs dissoci\u00e9s \u00e0 assembler - version compl\u00e8te","title":"Programmer la carte avec Scratch"},{"location":"microbit/scratch/#utiliser-la-carte-microbit-avec-scratch","text":"","title":"Utiliser la carte micro:bit avec Scratch"},{"location":"microbit/scratch/#programmer-la-carte-avec-scratch","text":"L' interface de programmation Scratch s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur ou tablette. La connexion avec la carte micro:bit utilise le bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, ou sur le drapeau vert, etc. Sur ordinateur (Windows, macOS), lancer Scratch Link , \u00e0 installer au pr\u00e9alable : lien de t\u00e9l\u00e9chargement et instructions Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le fichier scratch-microbit.hex sur la carte micro:bit : lien de t\u00e9l\u00e9chargement et instructions Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l' interface de programmation Scratch Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension micro:bit . Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. La possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran.","title":"Programmer la carte avec Scratch"},{"location":"microbit/scratch/#exemple-1-crabe-et-diamants","text":"Par exemple, dans le programme Crabe et diamants disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte.","title":"Exemple 1 : crabe et diamants"},{"location":"microbit/scratch/#exemple-2-roulis-et-tangage","text":"Sur cet autre exemple, Roulis et tangage , les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : un nuage de points donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite).","title":"Exemple 2 : roulis et tangage"},{"location":"microbit/scratch/#exemple-3-labyrinthe","text":"Un lutin se d\u00e9place dans un labyrinthe (sans franchir les murs) selon l'inclinaison de la carte micro:bit. - version avec blocs dissoci\u00e9s \u00e0 assembler - version compl\u00e8te","title":"Exemple 3 : labyrinthe"},{"location":"nsi_premiere/defimotifs/","text":"Vingt motifs Tous les motifs de ce notebook sont r\u00e9alis\u00e9s avec le module ipythonblocks . from ipythonblocks import BlockGrid 1. Motifs et \u00e9galit\u00e9 L'instruction grille = BlockGrid(12, 12, fill = (240, 240, 240)) permet de cr\u00e9er une grille carr\u00e9e de 12 cellules de c\u00f4t\u00e9. La couleur de chaque cellule est un gris clair de code RVB(240, 240, 240). grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2ef841c8-77c0-43c9-bf06-bd8619231932 td {border: 1px solid white;} Chaque cellule poss\u00e8de les attributs : row : indice de ligne de la cellule col : indice de colonne de la cellule La m\u00e9thode set_colors() permet de modifier les niveaux de (rouge, vert, bleu). Au survol de la souris, les coordonn\u00e9es [row, col] et la couleur de la cellule sont affich\u00e9es. Question 1.1 On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b01 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_1 (): for cellule in grille : if 4 <= cellule . row < 8 and 4 <= cellule . col < 8 : cellule . set_colors ( 0 , 0 , 0 ) motif_1 () grille . show () a) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. b) V\u00e9rifier en ex\u00e9cutant le code. c) Analyser les \u00e9ventuels \u00e9carts entre le dessin anticip\u00e9 et l'affichage obtenu. Question 1.2 On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b02 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_2 (): for cellule in grille : if ( cellule . row == cellule . col ) : cellule . set_colors ( 0 , 0 , 0 ) motif_2 () grille . show () a) En lisant le code, trouver les coordonn\u00e9es d'une cellule colori\u00e9e en noir et les coordonn\u00e9es d'une cellule qui ne l'est pas. b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code et en affichant la grille. d) Quelle est la particularit\u00e9 des cellules qui sont en noir apr\u00e8s l'ex\u00e9cution du code ? Question 1.3 a) Observer le motif n\u00b03 ci-dessous. b) Trouver une ou plusieurs relation(s) v\u00e9rifi\u00e9e(s) par les coordonn\u00e9es des cellules colori\u00e9es en noir. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks62979eff-d1ec-4918-a083-ccfd7cdc2f47 td {border: 1px solid white;} c) Compl\u00e9ter le code suivant pour que son ex\u00e9cution produise le motif ci-dessus. grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_3 (): for cellule in grille : if cellule . row == ... or cellule . row == ... : # remplacer les ... cellule . set_colors ( 0 , 0 , 0 ) motif_3 () grille . show () Question 1.4 \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif n\u00b04 ci-dessous : table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks3a7217df-b358-46a5-ae0a-0f4dbee198d5 td {border: 1px solid white;} 2. Motifs et modulo Question 2.1 On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b05 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_5 (): for cellule in grille : if ( cellule . row ) % 2 == 0 : cellule . set_colors ( 0 , 0 , 0 ) motif_5 () grille . show () a) En lisant le code, trouver les coordonn\u00e9es d'une cellule colori\u00e9e en noir et les coordonn\u00e9es d'une cellule qui ne l'est pas. b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code. d) Quelle est la particularit\u00e9 des cellules qui sont en noir apr\u00e8s l'ex\u00e9cution du code ? Question 2.2 a) Observer le motif n\u00b06 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par les coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks5f1d3a1d-fc8d-4943-ad5f-3a7d636281aa td {border: 1px solid white;} Question 2.3 a) Observer le motif n\u00b07 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par la somme des coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous : table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd5fce63c-ad6b-4746-bb49-b56bb5aa8362 td {border: 1px solid white;} Question 2.4 Pour chacun des 2 motifs (n\u00b08 et 9) ci-dessous, \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks959d58bd-d756-4268-ac53-4e4361c096c5 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks12379258-abe9-43ca-9836-16dcc634dc26 td {border: 1px solid white;} Question 2.5 a) Observer le motif n\u00b010 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par le produit des coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks25997fe8-b32d-4d01-91f5-d038df6ff845 td {border: 1px solid white;} Question 2.6 Pour chacun des 4 motifs ci-dessous (n\u00b011 \u00e0 14), \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks9e200774-fbf7-42c2-928f-3f0878db4e9f td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksa80d0c4c-4e5a-4f93-a3a9-e48a763e2b73 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks1509ed2d-6f6d-4f10-bce1-a6a59a31ce55 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd2885928-0980-4523-8d53-3473f391ef90 td {border: 1px solid white;} 3. Motifs et division Question 3.1 On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b015 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_15 (): for cellule in grille : if cellule . row // 2 == cellule . col // 2 : cellule . set_colors ( 0 , 0 , 0 ) motif_15 () grille . show () a) En lisant le code, d\u00e9terminer la couleur des cellules de coordonn\u00e9es : [2, 2], [2, 3], [3, 2], [3, 3] b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code et en affichant la grille. d) Analyser les \u00e9ventuels \u00e9carts entre le dessin anticip\u00e9 et l'affichage obtenu. Question 3.2 Pour chacun des 3 motifs ci-dessous (n\u00b0 16 \u00e0 18), \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksc5a36c20-5986-4be5-b28b-4ee68b461aa7 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks74db0e90-ef7e-494b-8bce-0df5b5ee7be6 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2919cf80-e08b-4d69-869b-e24f4ebf6212 td {border: 1px solid white;} 4. Motifs complexes Voici un motif dont le code comporte les diff\u00e9rentes op\u00e9rations utilis\u00e9es pr\u00e9c\u00e9demment (+, *, //, %) et combine deux fonctions. grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_19 (): for cellule in grille : if ( cellule . row // 2 + cellule . col * 3 ) % 7 == 0 : cellule . set_colors ( 0 , 0 , 0 ) def motif_20 (): for cellule in grille : if ( cellule . row * 3 + cellule . col // 2 ) % 7 == 0 : cellule . set_colors ( 0 , 0 , 0 ) motif_19 () motif_20 () grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks9404fe4d-0c02-471f-8feb-d46a8fd66e1c td {border: 1px solid white;} Question 4 Cr\u00e9er son propre motif en cr\u00e9ant et combinant les fonctions de son choix.","title":"Vingt motifs"},{"location":"nsi_premiere/defimotifs/#vingt-motifs","text":"Tous les motifs de ce notebook sont r\u00e9alis\u00e9s avec le module ipythonblocks . from ipythonblocks import BlockGrid","title":"Vingt motifs"},{"location":"nsi_premiere/defimotifs/#1-motifs-et-egalite","text":"L'instruction grille = BlockGrid(12, 12, fill = (240, 240, 240)) permet de cr\u00e9er une grille carr\u00e9e de 12 cellules de c\u00f4t\u00e9. La couleur de chaque cellule est un gris clair de code RVB(240, 240, 240). grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2ef841c8-77c0-43c9-bf06-bd8619231932 td {border: 1px solid white;} Chaque cellule poss\u00e8de les attributs : row : indice de ligne de la cellule col : indice de colonne de la cellule La m\u00e9thode set_colors() permet de modifier les niveaux de (rouge, vert, bleu). Au survol de la souris, les coordonn\u00e9es [row, col] et la couleur de la cellule sont affich\u00e9es.","title":"1.  Motifs et \u00e9galit\u00e9"},{"location":"nsi_premiere/defimotifs/#question-11","text":"On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b01 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_1 (): for cellule in grille : if 4 <= cellule . row < 8 and 4 <= cellule . col < 8 : cellule . set_colors ( 0 , 0 , 0 ) motif_1 () grille . show () a) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. b) V\u00e9rifier en ex\u00e9cutant le code. c) Analyser les \u00e9ventuels \u00e9carts entre le dessin anticip\u00e9 et l'affichage obtenu.","title":"Question 1.1"},{"location":"nsi_premiere/defimotifs/#question-12","text":"On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b02 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_2 (): for cellule in grille : if ( cellule . row == cellule . col ) : cellule . set_colors ( 0 , 0 , 0 ) motif_2 () grille . show () a) En lisant le code, trouver les coordonn\u00e9es d'une cellule colori\u00e9e en noir et les coordonn\u00e9es d'une cellule qui ne l'est pas. b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code et en affichant la grille. d) Quelle est la particularit\u00e9 des cellules qui sont en noir apr\u00e8s l'ex\u00e9cution du code ?","title":"Question 1.2"},{"location":"nsi_premiere/defimotifs/#question-13","text":"a) Observer le motif n\u00b03 ci-dessous. b) Trouver une ou plusieurs relation(s) v\u00e9rifi\u00e9e(s) par les coordonn\u00e9es des cellules colori\u00e9es en noir. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks62979eff-d1ec-4918-a083-ccfd7cdc2f47 td {border: 1px solid white;} c) Compl\u00e9ter le code suivant pour que son ex\u00e9cution produise le motif ci-dessus. grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_3 (): for cellule in grille : if cellule . row == ... or cellule . row == ... : # remplacer les ... cellule . set_colors ( 0 , 0 , 0 ) motif_3 () grille . show ()","title":"Question 1.3"},{"location":"nsi_premiere/defimotifs/#question-14","text":"\u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif n\u00b04 ci-dessous : table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks3a7217df-b358-46a5-ae0a-0f4dbee198d5 td {border: 1px solid white;}","title":"Question 1.4"},{"location":"nsi_premiere/defimotifs/#2-motifs-et-modulo","text":"","title":"2. Motifs et modulo"},{"location":"nsi_premiere/defimotifs/#question-21","text":"On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b05 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_5 (): for cellule in grille : if ( cellule . row ) % 2 == 0 : cellule . set_colors ( 0 , 0 , 0 ) motif_5 () grille . show () a) En lisant le code, trouver les coordonn\u00e9es d'une cellule colori\u00e9e en noir et les coordonn\u00e9es d'une cellule qui ne l'est pas. b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code. d) Quelle est la particularit\u00e9 des cellules qui sont en noir apr\u00e8s l'ex\u00e9cution du code ?","title":"Question 2.1"},{"location":"nsi_premiere/defimotifs/#question-22","text":"a) Observer le motif n\u00b06 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par les coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks5f1d3a1d-fc8d-4943-ad5f-3a7d636281aa td {border: 1px solid white;}","title":"Question 2.2"},{"location":"nsi_premiere/defimotifs/#question-23","text":"a) Observer le motif n\u00b07 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par la somme des coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous : table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd5fce63c-ad6b-4746-bb49-b56bb5aa8362 td {border: 1px solid white;}","title":"Question 2.3"},{"location":"nsi_premiere/defimotifs/#question-24","text":"Pour chacun des 2 motifs (n\u00b08 et 9) ci-dessous, \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks959d58bd-d756-4268-ac53-4e4361c096c5 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks12379258-abe9-43ca-9836-16dcc634dc26 td {border: 1px solid white;}","title":"Question 2.4"},{"location":"nsi_premiere/defimotifs/#question-25","text":"a) Observer le motif n\u00b010 ci-dessous. b) Trouver une relation v\u00e9rifi\u00e9e par le produit des coordonn\u00e9es des cellules colori\u00e9es en noir. c) \u00c9crire un code dont l'ex\u00e9cution produit l'affichage du motif ci-dessous. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks25997fe8-b32d-4d01-91f5-d038df6ff845 td {border: 1px solid white;}","title":"Question 2.5"},{"location":"nsi_premiere/defimotifs/#question-26","text":"Pour chacun des 4 motifs ci-dessous (n\u00b011 \u00e0 14), \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks9e200774-fbf7-42c2-928f-3f0878db4e9f td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksa80d0c4c-4e5a-4f93-a3a9-e48a763e2b73 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks1509ed2d-6f6d-4f10-bce1-a6a59a31ce55 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksd2885928-0980-4523-8d53-3473f391ef90 td {border: 1px solid white;}","title":"Question 2.6"},{"location":"nsi_premiere/defimotifs/#3-motifs-et-division","text":"","title":"3. Motifs et division"},{"location":"nsi_premiere/defimotifs/#question-31","text":"On consid\u00e8re le code suivant, qui permet de colorier en noir (code RVB (0, 0, 0)) certaines cellules et de cr\u00e9er le motif n\u00b015 : grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_15 (): for cellule in grille : if cellule . row // 2 == cellule . col // 2 : cellule . set_colors ( 0 , 0 , 0 ) motif_15 () grille . show () a) En lisant le code, d\u00e9terminer la couleur des cellules de coordonn\u00e9es : [2, 2], [2, 3], [3, 2], [3, 3] b) Dessiner sur une feuille la grille que l'on obtiendrait en ex\u00e9cutant le code pr\u00e9c\u00e9dent. c) V\u00e9rifier en ex\u00e9cutant le code et en affichant la grille. d) Analyser les \u00e9ventuels \u00e9carts entre le dessin anticip\u00e9 et l'affichage obtenu.","title":"Question 3.1"},{"location":"nsi_premiere/defimotifs/#question-32","text":"Pour chacun des 3 motifs ci-dessous (n\u00b0 16 \u00e0 18), \u00e9crire un code dont l'ex\u00e9cution produit l'affichage du motif. table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocksc5a36c20-5986-4be5-b28b-4ee68b461aa7 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks74db0e90-ef7e-494b-8bce-0df5b5ee7be6 td {border: 1px solid white;} table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks2919cf80-e08b-4d69-869b-e24f4ebf6212 td {border: 1px solid white;}","title":"Question 3.2"},{"location":"nsi_premiere/defimotifs/#4-motifs-complexes","text":"Voici un motif dont le code comporte les diff\u00e9rentes op\u00e9rations utilis\u00e9es pr\u00e9c\u00e9demment (+, *, //, %) et combine deux fonctions. grille = BlockGrid ( 12 , 12 , fill = ( 240 , 240 , 240 )) def motif_19 (): for cellule in grille : if ( cellule . row // 2 + cellule . col * 3 ) % 7 == 0 : cellule . set_colors ( 0 , 0 , 0 ) def motif_20 (): for cellule in grille : if ( cellule . row * 3 + cellule . col // 2 ) % 7 == 0 : cellule . set_colors ( 0 , 0 , 0 ) motif_19 () motif_20 () grille . show () table.blockgrid {border: none;} .blockgrid tr {border: none;} .blockgrid td {padding: 0px;} #blocks9404fe4d-0c02-471f-8feb-d46a8fd66e1c td {border: 1px solid white;}","title":"4. Motifs complexes"},{"location":"nsi_premiere/defimotifs/#question-4","text":"Cr\u00e9er son propre motif en cr\u00e9ant et combinant les fonctions de son choix.","title":"Question 4"},{"location":"nsi_premiere/express/","text":"Questions express Des questions en tout genre, dont la r\u00e9ponse peut se trouver avec quelques lignes de code. Les r\u00e9ponses sont donn\u00e9es brutes sans aucun argument de validit\u00e9. Quels sont les entiers... ? \u00c9nonc\u00e9 1 Question Quels sont les entiers n n tels que n! n! (factorielle n n ) comporte exactement n n chiffres ? R\u00e9ponse 1, 23, 24 et 25 \u00c9nonc\u00e9 2 Question Quels sont les entiers qui sont \u00e9gaux \u00e0 la somme de la factorielle de leur(s) chiffre(s) ? R\u00e9ponse 1, 2, 145 et 40585","title":"Questions express"},{"location":"nsi_premiere/express/#questions-express","text":"Des questions en tout genre, dont la r\u00e9ponse peut se trouver avec quelques lignes de code. Les r\u00e9ponses sont donn\u00e9es brutes sans aucun argument de validit\u00e9.","title":"Questions express"},{"location":"nsi_premiere/express/#quels-sont-les-entiers","text":"","title":"Quels sont les entiers... ?"},{"location":"nsi_premiere/express/#enonce-1","text":"Question Quels sont les entiers n n tels que n! n! (factorielle n n ) comporte exactement n n chiffres ? R\u00e9ponse 1, 23, 24 et 25","title":"\u00c9nonc\u00e9 1"},{"location":"nsi_premiere/express/#enonce-2","text":"Question Quels sont les entiers qui sont \u00e9gaux \u00e0 la somme de la factorielle de leur(s) chiffre(s) ? R\u00e9ponse 1, 2, 145 et 40585","title":"\u00c9nonc\u00e9 2"},{"location":"nsi_premiere/express_sol/","text":"Questions express Des questions en tout genre, dont la r\u00e9ponse peut se trouver avec quelques lignes de code. Les r\u00e9ponses et propositions de code sont donn\u00e9es brutes sans aucun argument de validit\u00e9. Quels sont les entiers... ? \u00c9nonc\u00e9 1 Question Quels sont les entiers n n tels que n! n! (factorielle n n ) comporte exactement n n chiffres ? R\u00e9ponse 1, 23, 24 et 25 Un code possible from math import factorial [ n for n in range ( 100 ) if len ( str ( factorial ( n ))) == n ] \u00c9nonc\u00e9 2 Question Quels sont les entiers qui sont \u00e9gaux \u00e0 la somme de la factorielle de leur(s) chiffre(s) ? R\u00e9ponse 1, 2, 145 et 40585 Un code possible from math import factorial factorielles = { n : factorial ( n ) for n in range ( 10 )} def verif ( n ): somme = 0 for chiffre in str ( n ) : somme += factorielles [ int ( chiffre )] return n == somme [ n for n in range ( 10000000 ) if verif ( n )] oeis","title":"Questions express"},{"location":"nsi_premiere/express_sol/#questions-express","text":"Des questions en tout genre, dont la r\u00e9ponse peut se trouver avec quelques lignes de code. Les r\u00e9ponses et propositions de code sont donn\u00e9es brutes sans aucun argument de validit\u00e9.","title":"Questions express"},{"location":"nsi_premiere/express_sol/#quels-sont-les-entiers","text":"","title":"Quels sont les entiers... ?"},{"location":"nsi_premiere/express_sol/#enonce-1","text":"Question Quels sont les entiers n n tels que n! n! (factorielle n n ) comporte exactement n n chiffres ? R\u00e9ponse 1, 23, 24 et 25 Un code possible from math import factorial [ n for n in range ( 100 ) if len ( str ( factorial ( n ))) == n ]","title":"\u00c9nonc\u00e9 1"},{"location":"nsi_premiere/express_sol/#enonce-2","text":"Question Quels sont les entiers qui sont \u00e9gaux \u00e0 la somme de la factorielle de leur(s) chiffre(s) ? R\u00e9ponse 1, 2, 145 et 40585 Un code possible from math import factorial factorielles = { n : factorial ( n ) for n in range ( 10 )} def verif ( n ): somme = 0 for chiffre in str ( n ) : somme += factorielles [ int ( chiffre )] return n == somme [ n for n in range ( 10000000 ) if verif ( n )] oeis","title":"\u00c9nonc\u00e9 2"},{"location":"nsi_premiere/fourmi_langton/","text":"La fourmi de Langton Vous trouverez sur cette page diff\u00e9rentes sources vous permettant de vous documenter sur \u201cla fourmi de Langton\u201d. L\u2019objectif est de cr\u00e9er un notebook pr\u00e9sentant \u201cla fourmi de Langton\u201d. Il devra comporter : le programme du parcours anim\u00e9 d\u2019une fourmi de Langton (en utilisant le module ipythonblocks ) un r\u00e9sum\u00e9 des connaissances que les diff\u00e9rents documents ont permis de recueillir Une vid\u00e9o de la chaine Youtube Science \u00e9tonnante (David Louapre) Un article sur Wikip\u00e9dia La fourmi de Langton sur Wikip\u00e9dia Un article de la revue Pour la science Les intrigants chemin de la fourmi de Langton par Jean-Paul Delahaye.","title":"La fourmi de Langton"},{"location":"nsi_premiere/fourmi_langton/#la-fourmi-de-langton","text":"Vous trouverez sur cette page diff\u00e9rentes sources vous permettant de vous documenter sur \u201cla fourmi de Langton\u201d. L\u2019objectif est de cr\u00e9er un notebook pr\u00e9sentant \u201cla fourmi de Langton\u201d. Il devra comporter : le programme du parcours anim\u00e9 d\u2019une fourmi de Langton (en utilisant le module ipythonblocks ) un r\u00e9sum\u00e9 des connaissances que les diff\u00e9rents documents ont permis de recueillir","title":"La fourmi de Langton"},{"location":"nsi_premiere/fourmi_langton/#une-video-de-la-chaine-youtube-science-etonnante-david-louapre","text":"","title":"Une vid\u00e9o de la chaine Youtube Science \u00e9tonnante (David Louapre)"},{"location":"nsi_premiere/fourmi_langton/#un-article-sur-wikipedia","text":"La fourmi de Langton sur Wikip\u00e9dia","title":"Un article sur Wikip\u00e9dia"},{"location":"nsi_premiere/fourmi_langton/#un-article-de-la-revue-pour-la-science","text":"Les intrigants chemin de la fourmi de Langton par Jean-Paul Delahaye.","title":"Un article de la revue Pour la science"},{"location":"nsi_premiere/jeu_cliquable/","text":"Une grille de jeu cliquable Les instructions de cette page reposent sur l'utilisation de Processing et de ses d\u00e9riv\u00e9s comme p5 , dans une version transpos\u00e9e en python. Le notebook support utilise la biblioth\u00e8que p5 dans la version propos\u00e9e par le site basthon.fr. Aucun pr\u00e9-requis li\u00e9 aux fonctions de p5 n'est attendu. Dans toute cette page, le terme grille peut d\u00e9signer : - soit un tableau de tableaux, ces derniers \u00e9tant tous de m\u00eame dimension, - soit une repr\u00e9sentation graphique, sous la forme d'un rectangle compos\u00e9 de cases dispos\u00e9es en lignes et colonnes. 1. Repr\u00e9senter une grille \u00e0 l'aide d'un tableau 1.1 Lecture du programme Lire le programme du notebook support et d\u00e9crire le lien entre la valeur de la variable grille et l'affichage r\u00e9alis\u00e9. 1.2 Modifications de la grille Quelles valeurs de la variable grille permettent d'obtenir les affichages suivants ? (tester en ex\u00e9cutant le programme apr\u00e8s modification de la valeur de la variable grille ) a) b) c) 1.3 Analyse Lorsque l'on ex\u00e9cute ce programme : De quelle couleur sont les cases correspondant \u00e0 des 0 dans la variable grille ? Quelles sont les dimensions de l'affichage r\u00e9alis\u00e9 ? Que repr\u00e9sente la variable lignes pour la grille affich\u00e9e ? Que repr\u00e9sente la variable taille pour la grille affich\u00e9e ? 1.4 Description de fonctions Les fonctions fill , rect , color , stroke , strokeWeight sont des fonctions de la biblioth\u00e8que p5 . Proposer une description du r\u00f4le de la fonction fill() . Proposer une description du r\u00f4le de la fonction rect() . Modifier les param\u00e8tres des fonctions color , stroke , strokeWeight et observer les effets produits. Proposer une description du r\u00f4le de chacune de ces fonctions. 1.5 Modification du programme Modifier le programme pour que l'affichage r\u00e9alis\u00e9 soit le suivant : \u200b 2. Une grille de jeu cliquable La grille de jeu est compos\u00e9e de cases initialement toutes oranges. En cliquant sur une case on modifie sa couleur et celle de ses voisines (c'est \u00e0 dire les cases ayant un c\u00f4t\u00e9 en commun). Chaque case est alternativement orange ou bleue. L'objectif est de rendre la totalit\u00e9 de la grille bleue. Les \u00e9tapes propos\u00e9es permettent, \u00e0 partir du notebook support, d'aboutir au jeu d\u00e9crit ci-dessus. 2.1 Configuration initiale de la grille Quelle grille permet de d\u00e9marrer avec un jeu ne comportant que des cases oranges ? Modifier la valeur de la variable grille . 2.2 Victoire Cr\u00e9er une fonction gagne qui prend en param\u00e8tre une grille et renvoie True si la grille ne comporte que des 1, et False sinon. V\u00e9rifier que la fonction passe les tests suivants : assert ( gagne ([[ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ]])) assert ( not gagne ([[ 1 , 1 , 1 ], [ 1 , 1 , 0 ], [ 1 , 1 , 1 ]])) Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 def gagne ( grille ): for ... in grille : for ... in ... : if ... != 1 : return False return True 2.3 Inversion Cr\u00e9er une fonction change_case(ligne, colonne, grille) qui prend en param\u00e8tres un indice de ligne, un indice de colonne et une grille (ne comportant que des 0 et des 1), et qui modifie la valeur de grille[ligne][colonne] en lui affectant la valeur 0 si sa valeur \u00e9tait 1, et en lui affectant la valeur 1 si sa valeur \u00e9tait 0. Cette fonction ne renvoie rien. 2.4 Dans quelle case est le clic ? Lors d'un clic sur la grille avec la souris, on pourra r\u00e9cup\u00e9rer les coordonn\u00e9es du point cliqu\u00e9. \u00c0 partir de ces coordonn\u00e9es, on a besoin de d\u00e9terminer dans quelle case de la grille se trouve le point cliqu\u00e9. On suppose que l'affichage est r\u00e9alis\u00e9 dans une fen\u00eatre de dimensions 400 x 400, et que la grille est carr\u00e9e. Par exemple, avec une grille de 4 lignes et 4 colonnes : - le clic aux coordonn\u00e9es (50, 50) devra \u00eatre associ\u00e9 aux valeurs (0, 0), (ligne d'indice 0, colonne d'indice 0) - le clic aux coordonn\u00e9es (250, 150) devra \u00eatre associ\u00e9 aux valeurs (1, 2) : (ligne d'indice 1, colonne d'indice 2) - le clic aux coordonn\u00e9es (250, 350) devra \u00eatre associ\u00e9 aux valeurs (3, 2) : (ligne d'indice 3, colonne d'indice 2). Compl\u00e9ter la fonction suivante : def pixel_vers_grille ( x , y , dimension_grille ): \"\"\" renvoie les indices de ligne et de colonne dans une grille carr\u00e9e (de dimension dimension_grille) de la case qui contient le pixel de coordonn\u00e9es (x,y) \"\"\" # taille d'une case, en pixels taille_pixels = int ( 400 / dimension_grille ) return ( ... // ... , ... // ... ) V\u00e9rifier que la fonction passe les tests suivants : assert ( pixel_vers_grille ( 50 , 50 , 4 ) == ( 0 , 0 )) assert ( pixel_vers_grille ( 250 , 150 , 4 ) == ( 1 , 2 )) assert ( pixel_vers_grille ( 250 , 350 , 4 ) == ( 3 , 2 )) 2.5 Rassemblement des voisins Lors du clic sur une case, la couleur de cette case et celle de ses voisines doit s'inverser. On souhaite \u00e9crire une fonction voisins(ligne, colonne, dimension_grille) qui prend en param\u00e8tres un indice de ligne, un indice de colonne et la dimension d'une grille carr\u00e9e. Cette fonction renvoie une liste compos\u00e9e des couples des indices de ligne et de colonne de chaque case voisine. Une case peut avoir de 2 \u00e0 4 voisins : les cases dans les coins n'en ont que 2, les cases hors des bords en ont 4. \u00c0 quelles conditions portant sur ligne et colonne une case poss\u00e8de-t-elle une voisine \u00e0 gauche ? \u00c0 droite ? Au-dessus ? Au dessous ? V\u00e9rifier que la fonction passe les tests suivants (la fonction sorted est utilis\u00e9e dans les tests pour valider les listes contenant les bons couples ind\u00e9pendamment de l'ordre de ces couples) : assert ( sorted ( voisins ( 3 , 3 , 4 )) == [( 2 , 3 ), ( 3 , 2 )] assert ( sorted ( voisins ( 1 , 3 , 4 )) == [( 0 , 3 ), ( 1 , 2 ), ( 2 , 3 )] assert ( sorted ( voisins ( 1 , 1 , 4 )) == [( 0 , 1 ), ( 1 , 0 ), ( 1 , 2 ), ( 2 , 1 )] Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def voisins ( ligne , colonne , dimension_grille ): liste_voisins = ... # gauche if colonne ... : liste_voisins . append (( ... , colonne - 1 )) # droite if colonne ... : liste_voisins . append (( ... , ... )) # haut if ligne ... : liste_voisins . append (( ... , colonne )) # bas : if ligne < ... : liste_voisins . append (( ... , ... )) return ... 2.6 Actions \u00e0 r\u00e9aliser au clic de souris La version de p5 utilis\u00e9e propose un bool\u00e9en mouseIsPressed qui vaut True lorsque la souris est cliqu\u00e9e. On peut lire les coordonn\u00e9es de la souris dans la fen\u00eatre de trac\u00e9 gr\u00e2ce aux variables mouseX et mouseY . La fonction souris_cliquee suivante : permet de stocker les coordonn\u00e9es de la souris \u00e0 chaque clic, en v\u00e9rifiant que l'on ne prend pas en compte deux fois de suite le m\u00eame clic ; inverse la couleur de la case cliqu\u00e9e en utilisant les fonctions pixel_vers_grille et change_case ; d\u00e9termine la liste des cases voisines de la case cliqu\u00e9e en utilisant la fonction voisins puis parcourt cette liste pour changer la couleur de chaque case voisine en utilisant \u00e0 nouveau la fonction change_case ; def souris_cliquee (): if mouseIsPressed : if ( mouseX , mouseY ) != souris [ - 1 ]: souris . append (( mouseX , mouseY )) ligne , colonne = pixel_vers_grille ( int ( mouseX ), int ( mouseY ), DIMENSION ) change_case ( ligne , colonne , grille ) for case in voisins ( ligne , colonne , DIMENSION ): ligne_case , colonne_case = case change_case ( ligne_case , colonne_case , grille ) Copier cette fonction, ainsi que toutes les fonctions \u00e9crites dans cette partie 2 (2.1 \u00e0 2.6) dans une cellule du notebook, au-dessus de la cellule qui contient les fonctions setup , draw et run . 2.7 Finalisation La fonction souris_cliquee utilise une liste nomm\u00e9e souris et une constante nomm\u00e9e DIMENSION qui sont d\u00e9finies au d\u00e9but de la cellule qui contient les fonctions setup , draw et run . # \u00e0 ins\u00e9rer juste apr\u00e8s l'initialisation de grille DIMENSION = len ( grille ) souris = [( 0 , 0 )] Enfin, la fonction draw (qui est ex\u00e9cut\u00e9e en boucle apr\u00e8s l'ex\u00e9cution de setup ) est \u00e0 compl\u00e9ter pour prendre en compte l'interaction avec la souris, et v\u00e9rifier apr\u00e8s chaque clic si la partie est gagn\u00e9e. C'est la fonction draw qui fait appel \u00e0 celles pr\u00e9c\u00e9demment d\u00e9finies. def draw (): affiche_grille ( grille ) souris_cliquee () if gagne ( grille ): affiche_grille ( grille ) stop () Tester le jeu obtenu en ex\u00e9cutant la cellule qui contient les fonctions setup , draw et run . 2.8 Compl\u00e9ments Proposer des fonctionnalit\u00e9s suppl\u00e9mentaires : cr\u00e9er un compteur de clics qui compte le nombre de clics jou\u00e9s avant la victoire ; afficher en cas de victoire un message de f\u00e9licitation, ainsi que le nombre de coups jou\u00e9s ; (l'intruction text(message, x, y) permet d'afficher le texte de la variable message \u00e0 partir des coordonn\u00e9es (x, y) )","title":"Grille cliquable"},{"location":"nsi_premiere/jeu_cliquable/#une-grille-de-jeu-cliquable","text":"Les instructions de cette page reposent sur l'utilisation de Processing et de ses d\u00e9riv\u00e9s comme p5 , dans une version transpos\u00e9e en python. Le notebook support utilise la biblioth\u00e8que p5 dans la version propos\u00e9e par le site basthon.fr. Aucun pr\u00e9-requis li\u00e9 aux fonctions de p5 n'est attendu. Dans toute cette page, le terme grille peut d\u00e9signer : - soit un tableau de tableaux, ces derniers \u00e9tant tous de m\u00eame dimension, - soit une repr\u00e9sentation graphique, sous la forme d'un rectangle compos\u00e9 de cases dispos\u00e9es en lignes et colonnes.","title":"Une grille de jeu cliquable"},{"location":"nsi_premiere/jeu_cliquable/#1-representer-une-grille-a-laide-dun-tableau","text":"","title":"1. Repr\u00e9senter une grille \u00e0 l'aide d'un tableau"},{"location":"nsi_premiere/jeu_cliquable/#11-lecture-du-programme","text":"Lire le programme du notebook support et d\u00e9crire le lien entre la valeur de la variable grille et l'affichage r\u00e9alis\u00e9.","title":"1.1 Lecture du programme"},{"location":"nsi_premiere/jeu_cliquable/#12-modifications-de-la-grille","text":"Quelles valeurs de la variable grille permettent d'obtenir les affichages suivants ? (tester en ex\u00e9cutant le programme apr\u00e8s modification de la valeur de la variable grille ) a) b) c)","title":"1.2 Modifications de la grille"},{"location":"nsi_premiere/jeu_cliquable/#13-analyse","text":"Lorsque l'on ex\u00e9cute ce programme : De quelle couleur sont les cases correspondant \u00e0 des 0 dans la variable grille ? Quelles sont les dimensions de l'affichage r\u00e9alis\u00e9 ? Que repr\u00e9sente la variable lignes pour la grille affich\u00e9e ? Que repr\u00e9sente la variable taille pour la grille affich\u00e9e ?","title":"1.3 Analyse"},{"location":"nsi_premiere/jeu_cliquable/#14-description-de-fonctions","text":"Les fonctions fill , rect , color , stroke , strokeWeight sont des fonctions de la biblioth\u00e8que p5 . Proposer une description du r\u00f4le de la fonction fill() . Proposer une description du r\u00f4le de la fonction rect() . Modifier les param\u00e8tres des fonctions color , stroke , strokeWeight et observer les effets produits. Proposer une description du r\u00f4le de chacune de ces fonctions.","title":"1.4 Description de fonctions"},{"location":"nsi_premiere/jeu_cliquable/#15-modification-du-programme","text":"Modifier le programme pour que l'affichage r\u00e9alis\u00e9 soit le suivant : \u200b","title":"1.5 Modification du programme"},{"location":"nsi_premiere/jeu_cliquable/#2-une-grille-de-jeu-cliquable","text":"La grille de jeu est compos\u00e9e de cases initialement toutes oranges. En cliquant sur une case on modifie sa couleur et celle de ses voisines (c'est \u00e0 dire les cases ayant un c\u00f4t\u00e9 en commun). Chaque case est alternativement orange ou bleue. L'objectif est de rendre la totalit\u00e9 de la grille bleue. Les \u00e9tapes propos\u00e9es permettent, \u00e0 partir du notebook support, d'aboutir au jeu d\u00e9crit ci-dessus.","title":"2. Une grille de jeu cliquable"},{"location":"nsi_premiere/jeu_cliquable/#21-configuration-initiale-de-la-grille","text":"Quelle grille permet de d\u00e9marrer avec un jeu ne comportant que des cases oranges ? Modifier la valeur de la variable grille .","title":"2.1 Configuration initiale de la grille"},{"location":"nsi_premiere/jeu_cliquable/#22-victoire","text":"Cr\u00e9er une fonction gagne qui prend en param\u00e8tre une grille et renvoie True si la grille ne comporte que des 1, et False sinon. V\u00e9rifier que la fonction passe les tests suivants : assert ( gagne ([[ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ], [ 1 , 1 , 1 ]])) assert ( not gagne ([[ 1 , 1 , 1 ], [ 1 , 1 , 0 ], [ 1 , 1 , 1 ]])) Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 def gagne ( grille ): for ... in grille : for ... in ... : if ... != 1 : return False return True","title":"2.2 Victoire"},{"location":"nsi_premiere/jeu_cliquable/#23-inversion","text":"Cr\u00e9er une fonction change_case(ligne, colonne, grille) qui prend en param\u00e8tres un indice de ligne, un indice de colonne et une grille (ne comportant que des 0 et des 1), et qui modifie la valeur de grille[ligne][colonne] en lui affectant la valeur 0 si sa valeur \u00e9tait 1, et en lui affectant la valeur 1 si sa valeur \u00e9tait 0. Cette fonction ne renvoie rien.","title":"2.3 Inversion"},{"location":"nsi_premiere/jeu_cliquable/#24-dans-quelle-case-est-le-clic","text":"Lors d'un clic sur la grille avec la souris, on pourra r\u00e9cup\u00e9rer les coordonn\u00e9es du point cliqu\u00e9. \u00c0 partir de ces coordonn\u00e9es, on a besoin de d\u00e9terminer dans quelle case de la grille se trouve le point cliqu\u00e9. On suppose que l'affichage est r\u00e9alis\u00e9 dans une fen\u00eatre de dimensions 400 x 400, et que la grille est carr\u00e9e. Par exemple, avec une grille de 4 lignes et 4 colonnes : - le clic aux coordonn\u00e9es (50, 50) devra \u00eatre associ\u00e9 aux valeurs (0, 0), (ligne d'indice 0, colonne d'indice 0) - le clic aux coordonn\u00e9es (250, 150) devra \u00eatre associ\u00e9 aux valeurs (1, 2) : (ligne d'indice 1, colonne d'indice 2) - le clic aux coordonn\u00e9es (250, 350) devra \u00eatre associ\u00e9 aux valeurs (3, 2) : (ligne d'indice 3, colonne d'indice 2). Compl\u00e9ter la fonction suivante : def pixel_vers_grille ( x , y , dimension_grille ): \"\"\" renvoie les indices de ligne et de colonne dans une grille carr\u00e9e (de dimension dimension_grille) de la case qui contient le pixel de coordonn\u00e9es (x,y) \"\"\" # taille d'une case, en pixels taille_pixels = int ( 400 / dimension_grille ) return ( ... // ... , ... // ... ) V\u00e9rifier que la fonction passe les tests suivants : assert ( pixel_vers_grille ( 50 , 50 , 4 ) == ( 0 , 0 )) assert ( pixel_vers_grille ( 250 , 150 , 4 ) == ( 1 , 2 )) assert ( pixel_vers_grille ( 250 , 350 , 4 ) == ( 3 , 2 ))","title":"2.4 Dans quelle case est le clic ?"},{"location":"nsi_premiere/jeu_cliquable/#25-rassemblement-des-voisins","text":"Lors du clic sur une case, la couleur de cette case et celle de ses voisines doit s'inverser. On souhaite \u00e9crire une fonction voisins(ligne, colonne, dimension_grille) qui prend en param\u00e8tres un indice de ligne, un indice de colonne et la dimension d'une grille carr\u00e9e. Cette fonction renvoie une liste compos\u00e9e des couples des indices de ligne et de colonne de chaque case voisine. Une case peut avoir de 2 \u00e0 4 voisins : les cases dans les coins n'en ont que 2, les cases hors des bords en ont 4. \u00c0 quelles conditions portant sur ligne et colonne une case poss\u00e8de-t-elle une voisine \u00e0 gauche ? \u00c0 droite ? Au-dessus ? Au dessous ? V\u00e9rifier que la fonction passe les tests suivants (la fonction sorted est utilis\u00e9e dans les tests pour valider les listes contenant les bons couples ind\u00e9pendamment de l'ordre de ces couples) : assert ( sorted ( voisins ( 3 , 3 , 4 )) == [( 2 , 3 ), ( 3 , 2 )] assert ( sorted ( voisins ( 1 , 3 , 4 )) == [( 0 , 3 ), ( 1 , 2 ), ( 2 , 3 )] assert ( sorted ( voisins ( 1 , 1 , 4 )) == [( 0 , 1 ), ( 1 , 0 ), ( 1 , 2 ), ( 2 , 1 )] Aide : une proposition \u00e0 compl\u00e9ter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def voisins ( ligne , colonne , dimension_grille ): liste_voisins = ... # gauche if colonne ... : liste_voisins . append (( ... , colonne - 1 )) # droite if colonne ... : liste_voisins . append (( ... , ... )) # haut if ligne ... : liste_voisins . append (( ... , colonne )) # bas : if ligne < ... : liste_voisins . append (( ... , ... )) return ...","title":"2.5 Rassemblement des voisins"},{"location":"nsi_premiere/jeu_cliquable/#26-actions-a-realiser-au-clic-de-souris","text":"La version de p5 utilis\u00e9e propose un bool\u00e9en mouseIsPressed qui vaut True lorsque la souris est cliqu\u00e9e. On peut lire les coordonn\u00e9es de la souris dans la fen\u00eatre de trac\u00e9 gr\u00e2ce aux variables mouseX et mouseY . La fonction souris_cliquee suivante : permet de stocker les coordonn\u00e9es de la souris \u00e0 chaque clic, en v\u00e9rifiant que l'on ne prend pas en compte deux fois de suite le m\u00eame clic ; inverse la couleur de la case cliqu\u00e9e en utilisant les fonctions pixel_vers_grille et change_case ; d\u00e9termine la liste des cases voisines de la case cliqu\u00e9e en utilisant la fonction voisins puis parcourt cette liste pour changer la couleur de chaque case voisine en utilisant \u00e0 nouveau la fonction change_case ; def souris_cliquee (): if mouseIsPressed : if ( mouseX , mouseY ) != souris [ - 1 ]: souris . append (( mouseX , mouseY )) ligne , colonne = pixel_vers_grille ( int ( mouseX ), int ( mouseY ), DIMENSION ) change_case ( ligne , colonne , grille ) for case in voisins ( ligne , colonne , DIMENSION ): ligne_case , colonne_case = case change_case ( ligne_case , colonne_case , grille ) Copier cette fonction, ainsi que toutes les fonctions \u00e9crites dans cette partie 2 (2.1 \u00e0 2.6) dans une cellule du notebook, au-dessus de la cellule qui contient les fonctions setup , draw et run .","title":"2.6 Actions \u00e0 r\u00e9aliser au clic de souris"},{"location":"nsi_premiere/jeu_cliquable/#27-finalisation","text":"La fonction souris_cliquee utilise une liste nomm\u00e9e souris et une constante nomm\u00e9e DIMENSION qui sont d\u00e9finies au d\u00e9but de la cellule qui contient les fonctions setup , draw et run . # \u00e0 ins\u00e9rer juste apr\u00e8s l'initialisation de grille DIMENSION = len ( grille ) souris = [( 0 , 0 )] Enfin, la fonction draw (qui est ex\u00e9cut\u00e9e en boucle apr\u00e8s l'ex\u00e9cution de setup ) est \u00e0 compl\u00e9ter pour prendre en compte l'interaction avec la souris, et v\u00e9rifier apr\u00e8s chaque clic si la partie est gagn\u00e9e. C'est la fonction draw qui fait appel \u00e0 celles pr\u00e9c\u00e9demment d\u00e9finies. def draw (): affiche_grille ( grille ) souris_cliquee () if gagne ( grille ): affiche_grille ( grille ) stop () Tester le jeu obtenu en ex\u00e9cutant la cellule qui contient les fonctions setup , draw et run .","title":"2.7 Finalisation"},{"location":"nsi_premiere/jeu_cliquable/#28-complements","text":"Proposer des fonctionnalit\u00e9s suppl\u00e9mentaires : cr\u00e9er un compteur de clics qui compte le nombre de clics jou\u00e9s avant la victoire ; afficher en cas de victoire un message de f\u00e9licitation, ainsi que le nombre de coups jou\u00e9s ; (l'intruction text(message, x, y) permet d'afficher le texte de la variable message \u00e0 partir des coordonn\u00e9es (x, y) )","title":"2.8 Compl\u00e9ments"},{"location":"nsi_premiere/jeu_de_la_vie/","text":"Le jeu de la vie Vous trouverez sur cette page diff\u00e9rentes sources vous permettant de vous documenter sur \u201cle jeu de la vie\u201d. L\u2019objectif est de cr\u00e9er un notebook pr\u00e9sentant \u201cle jeu de la vie\u201d en utilisant le module ipythonblocks . Il devra comporter un r\u00e9sum\u00e9 des connaissances que les diff\u00e9rents documents ont permis de recueillir, illustr\u00e9 de programmes d\u2019animations respectant les r\u00e8gles du jeu de la vie. On pourra pr\u00e9senter diff\u00e9rents types de structures comme des structures oscillantes, des structures stables, des vaisseaux, etc. On pourra \u00e9galement proposer une animation pr\u00e9sentant l\u2019\u00e9volution d\u2019une situation de d\u00e9part al\u00e9atoire. Une vid\u00e9o de la chaine Youtube Science \u00e9tonnante (David Louapre) Un article sur Wikip\u00e9dia Le jeu de la vie sur Wikip\u00e9dia. Un wiki d\u00e9crivant plus de 1000 motifs Les motifs du jeu de la vie","title":"Le jeu de la vie"},{"location":"nsi_premiere/jeu_de_la_vie/#le-jeu-de-la-vie","text":"Vous trouverez sur cette page diff\u00e9rentes sources vous permettant de vous documenter sur \u201cle jeu de la vie\u201d. L\u2019objectif est de cr\u00e9er un notebook pr\u00e9sentant \u201cle jeu de la vie\u201d en utilisant le module ipythonblocks . Il devra comporter un r\u00e9sum\u00e9 des connaissances que les diff\u00e9rents documents ont permis de recueillir, illustr\u00e9 de programmes d\u2019animations respectant les r\u00e8gles du jeu de la vie. On pourra pr\u00e9senter diff\u00e9rents types de structures comme des structures oscillantes, des structures stables, des vaisseaux, etc. On pourra \u00e9galement proposer une animation pr\u00e9sentant l\u2019\u00e9volution d\u2019une situation de d\u00e9part al\u00e9atoire.","title":"Le jeu de la vie"},{"location":"nsi_premiere/jeu_de_la_vie/#une-video-de-la-chaine-youtube-science-etonnante-david-louapre","text":"","title":"Une vid\u00e9o de la chaine Youtube Science \u00e9tonnante (David Louapre)"},{"location":"nsi_premiere/jeu_de_la_vie/#un-article-sur-wikipedia","text":"Le jeu de la vie sur Wikip\u00e9dia.","title":"Un article sur Wikip\u00e9dia"},{"location":"nsi_premiere/jeu_de_la_vie/#un-wiki-decrivant-plus-de-1000-motifs","text":"Les motifs du jeu de la vie","title":"Un wiki d\u00e9crivant\u00a0plus de 1000 motifs"},{"location":"nsi_premiere/melange_cartes/","text":"M\u00e9langes parfaits d'un jeu de 32 cartes Cette page pr\u00e9sente les m\u00e9langes parfaits de type out-shuffle et in-shuffle d'un jeu de cartes et en explore quelques propri\u00e9t\u00e9s. 1. M\u00e9lange parfait Question 1 Un jeu de 32 cartes peut \u00eatre repr\u00e9sent\u00e9 par un tableau, o\u00f9 chaque carte est repr\u00e9sent\u00e9e par un entier. Cr\u00e9er le tableau jeu32 , contenant les 32 entiers entre 1 et 32. jeu32 = [ \u2026 ] # \u00e0 compl\u00e9ter Pour r\u00e9aliser un m\u00e9lange parfait d'un jeu de cartes, on le s\u00e9pare en 2 paquets de m\u00eame taille avant de m\u00e9langer ensemble les 2 paquets cr\u00e9\u00e9s. Les fonctions ci-dessous permettent de r\u00e9cup\u00e9rer la moiti\u00e9 du \"dessus\" et la moiti\u00e9 du \"dessous\" d'un jeu de cartes. def dessus ( tab ): return ( tab [: len ( tab ) // 2 ]) def dessous ( tab ): return ( tab [ len ( tab ) // 2 :]) \u00c0 r\u00e9aliser Ex\u00e9cuter les appels dessus(jeu32) et dessous(jeu32) et observer le r\u00e9sultat produit. Lors du m\u00e9lange parfait d'un jeu de cartes, on le s\u00e9pare en 2 paquets de m\u00eame taille : le paquet A d\u00e9signe la moiti\u00e9 du dessus et le paquet B d\u00e9signe la moiti\u00e9 du dessous. Puis on alterne les cartes d'un paquet et de l'autre. Le m\u00e9lange peut se r\u00e9aliser de 2 fa\u00e7ons : - soit c'est la carte du dessus du paquet A qui sera au-dessus du paquet m\u00e9lang\u00e9 : ce m\u00e9lange est appel\u00e9 out-shuffle ; - soit c'est la carte du dessus du paquet B qui sera au-dessus du paquet m\u00e9lang\u00e9 : ce m\u00e9lange est appel\u00e9 in-shuffle . Voici un exemple avec un jeu initial de 8 cartes : observer la position des cartes extr\u00eames (1 et 8) dans les manipulations suivantes. On s\u00e9pare le jeu en 2 paquets de m\u00eame taille : le paquet A est constitu\u00e9 des cartes 1 \u00e0 4, le paquet B des cartes 5 \u00e0 8. Voici le paquet obtenu apr\u00e8s un m\u00e9lange out-shuffle : les cartes du paquet A occupent les places 1, 3, 5 et 7. Les cartes extr\u00eames (1 et 8) ont conserv\u00e9 leur position initiale (\u00e0 l'ext\u00e9rieur : out ). Voici le paquet obtenu apr\u00e8s un m\u00e9lange in-shuffle : les cartes du paquet A occupent les places 2, 4, 6 et 8. Les cartes extr\u00eames (1 et 8) sont d\u00e9sormais \u00e0 l'int\u00e9rieur du paquet m\u00e9lang\u00e9 (\u00e0 l'int\u00e9rieur : in ). 2. M\u00e9lange Out-shuffle 2.1 Fonction outshuffle Afin de pouvoir simuler des m\u00e9langes r\u00e9p\u00e9t\u00e9s, on programme une fonction qui agit sur un jeu de carte comme un m\u00e9lange out-shuffle . Question 2 Compl\u00e9ter la fonction outshuffle(tab) qui prend en param\u00e8tre un tableau repr\u00e9sentant un jeu de cartes et qui renvoie le contenu de ce tableau apr\u00e8s un m\u00e9lange de type out-shuffle. On suppose que tab contient un nombre pair d'\u00e9l\u00e9ments . def outshuffle ( tab ): # on s\u00e9pare le paquet de cartes en 2 tas_haut = \u2026 # \u00e0 compl\u00e9ter tas_bas = \u2026 # \u00e0 compl\u00e9ter # on cr\u00e9e un tableau de m\u00eame longueur que tab tab2 = [ 0 ] * len ( tab ) # on copie dans tab2 les cartes de tas_haut et tas_bas en les alternant # dans le tri out-shuffle, la carte du dessus du paquet initial reste # au-dessus du paquet m\u00e9lang\u00e9 for i in range ( len ( tas_haut )): # rangs pairs tab2 [ 2 * i ] = \u2026 # rangs impairs tab2 [ 2 * i + 1 ] = \u2026 return tab2 \u00c0 r\u00e9aliser V\u00e9rifier qu'un m\u00e9lange de jeu32 avec la fonction outshuffle donne bien le r\u00e9sultat attendu. assert ( outshuffle ( jeu32 ) == [ 1 , 17 , 2 , 18 , 3 , 19 , 4 , 20 , 5 , 21 , 6 , 22 , 7 , 23 , 8 , 24 , 9 , 25 , 10 , 26 , 11 , 27 , 12 , 28 , 13 , 29 , 14 , 30 , 15 , 31 , 16 , 32 ]) 2.2 Apr\u00e8s plusieurs m\u00e9langes Question 3 Quelle est la position de la carte 2 du tableau jeu32 apr\u00e8s un m\u00e9lange de type out-shuffle ? Et apr\u00e8s 2 m\u00e9langes ? 3 m\u00e9langes ? Question 4 En appliquant successivement plusieurs fois le m\u00e9lange out-shuffle, peut-on revenir \u00e0 l'ordre initial du jeu de 32 cartes ? Si oui, au bout de combien de m\u00e9langes au minimum ? Question 5 Que r\u00e9alise la fonction cycle_out(tab) ci-dessous ? Quelle est la valeur de cycle_out(jeu32) ? Comment interpr\u00e9ter cette valeur ? def cycle_out ( tab ): tab2 = tab [:] #copie des valeurs contenues dans tab compteur = 1 tab = outshuffle ( tab ) while tab2 != tab : compteur += 1 tab = outshuffle ( tab ) return compteur 2.3 Trajectoire d'une carte fix\u00e9e On s'int\u00e9resse dans cette partie \u00e0 toutes les positions occup\u00e9es par la carte 2 du jeu jeu32 au cours des m\u00e9langes successifs jusqu'\u00e0 revenir \u00e0 la configuration initiale du jeu. Info La m\u00e9thode tab.index(valeur) permet de renvoyer l'indice de la premi\u00e8re occurrence de valeur dans le tableau tab . Exemple Dans le tableau jeu32 , la carte 2 appara\u00eet en 2e position, c'est-\u00e0-dire avec l'indice 1. jeu32 . index ( 2 ) 1 Il peut \u00eatre int\u00e9ressant de constater que cette valeur est le nombre de cartes \"au-dessus\" de la carte 2 dans le paquet. Question 6 Quels sont tous les indices de la carte 2 du tableau jeu32 lorsqu'on effectue des m\u00e9langes out-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part ? nombre de m\u00e9lange(s) out-shuffle indice de la carte 2 0 1 1 2 3 ... \u00e0 compl\u00e9ter Question 7 On r\u00e9alise des m\u00e9langes out-shuffle \u00e0 partir du tableau jeu32 . Conjecturer une formule permettant d'obtenir l'indice de la carte 2 dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange out-shuffle, en fonction de son indice actuel. \u00c0 r\u00e9aliser V\u00e9rifier que la formule conjectur\u00e9e permet de passer de chacun des indices du tableau de la question 6 \u00e0 l'indice suivant, obtenu avec un nouveau m\u00e9lange out-shuffle de jeu32 . En particulier, \u00e0 partir de l'indice de la derni\u00e8re ligne du tableau, la formule conjectur\u00e9e doit donner 1, qui serait l'indice de la carte 2 apr\u00e8s un nouveau m\u00e9lange. 2.4 Trajectoire d'une carte quelconque La fonction orbite_out(tab, valeur) ci-dessous permet d'obtenir le tableau de tous les indices de la carte valeur dans le tableau tab lorsqu'on effectue 5 m\u00e9langes out-shuffle successifs. def orbite_out ( tab , valeur ): orbite = [ 0 ] * 5 for i in range ( 5 ): orbite [ i ] = tab . index ( valeur ) tab = outshuffle ( tab ) return orbite Question 8 Utiliser la fonction pr\u00e9c\u00e9dente pour explorer les indices de quelques cartes du tableau jeu32 lorsqu'on effectue des m\u00e9langes out-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part. Conjecturer une formule permettant d'obtenir l'indice de la carte valeur dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange out-shuffle, en fonction de son indice actuel. Question 9 Cr\u00e9er une fonction orbite_conjecture_out(valeur) permettant d'obtenir le tableau de tous les indices de la carte valeur dans le tableau jeu32 , au fur et \u00e0 mesure des m\u00e9langes, selon la conjecture formul\u00e9e \u00e0 la question pr\u00e9c\u00e9dente. def orbite_conjecture_out ( valeur ): # \u00e0 compl\u00e9ter Question 10 Cr\u00e9er une fonction validation_conjecture_out() qui v\u00e9rifie si, pour toutes les valeurs des cartes de jeu32 , les tableaux orbite_out(jeu32, valeur) et orbite_conjecture_out(valeur) sont identiques. def validation_conjecture_out ( tab ): # \u00e0 compl\u00e9ter 2.5 Synth\u00e8se Question 11 R\u00e9diger une synth\u00e8se des r\u00e9sultats \u00e9tablis concernant le m\u00e9lange out-shuffle. 3. M\u00e9lange in-shuffle 3.1 Fonction inshuffle Question 12 \u00c9crire une fonction inshuffle(tab) qui prend en param\u00e8tre un tableau repr\u00e9sentant un jeu de cartes et qui renvoie le contenu de ce tableau apr\u00e8s un m\u00e9lange de type in-shuffle. On suppose que tab contient un nombre pair d'\u00e9l\u00e9ments . def inshuffle ( tab ): # \u00e0 compl\u00e9ter 3.2 Apr\u00e8s plusieurs m\u00e9langes Question 13 En appliquant successivement plusieurs fois le m\u00e9lange in-shuffle, peut-on revenir \u00e0 l'ordre initial du jeu de 32 cartes ? Si oui, au bout de combien de m\u00e9langes au minimum ? On utilisera une fonction pour d\u00e9terminer cette valeur . 3.3 Trajectoire d'une carte fix\u00e9e Question 14 Quels sont tous les indices de la carte 2 du tableau jeu32 lorsqu'on effectue des m\u00e9langes in-shuffle jusqu'\u00e0 revenir \u00e0 la position de d\u00e9part ? nombre de m\u00e9lange(s) in-shuffle indice de la carte 2 0 1 1 2 3 ... \u00e0 compl\u00e9ter Question 15 On r\u00e9alise des m\u00e9langes in-shuffle \u00e0 partir du tableau jeu32 . Conjecturer une formule permettant d'obtenir l'indice de la carte 2 dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange in-shuffle, en fonction de son indice actuel. 3.4 Trajectoire d'une carte quelconque La fonction orbite_in(tab, valeur) ci-dessous permet d'obtenir le tableau de tous les indices de la carte valeur dans le tableau tab lorsqu'on effectue 10 m\u00e9langes in-shuffle. def orbite_in ( tab , valeur ): orbite = [ 0 ] * 10 for i in range ( 10 ): orbite [ i ] = tab . index ( valeur ) tab = inshuffle ( tab ) return orbite Question 16 Utiliser la fonction pr\u00e9c\u00e9dente pour explorer les indices de quelques cartes du tableau jeu32 lorsqu'on effectue des m\u00e9langes in-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part. Conjecturer une formule permettant d'obtenir l'indice de la carte valeur dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange in-shuffle, en fonction de son indice actuel. Question 17 Cr\u00e9er une fonction orbite_conjecture_in(valeur) permettant d'obtenir le tableau de tous les indices de la carte valeur dans le tableau jeu32 , au fur et \u00e0 mesure des m\u00e9langes, selon la conjecture formul\u00e9e \u00e0 la question pr\u00e9c\u00e9dente. def orbite_conjecture_in ( valeur ): # \u00e0 compl\u00e9ter Question 18 Cr\u00e9er une fonction validation_conjecture_in() qui v\u00e9rifie si pour toutes les valeurs des cartes de jeu32 les tableaux orbite_in(jeu32, valeur) et orbite_conjecture_in(valeur) sont identiques. def validation_conjecture_in ( tab ): # \u00e0 compl\u00e9ter 3.5 Synth\u00e8se Question 19 R\u00e9diger une synth\u00e8se des r\u00e9sultats \u00e9tablis concernant le m\u00e9lange in-shuffle.","title":"M\u00e9lange Parfait"},{"location":"nsi_premiere/melange_cartes/#melanges-parfaits-dun-jeu-de-32-cartes","text":"Cette page pr\u00e9sente les m\u00e9langes parfaits de type out-shuffle et in-shuffle d'un jeu de cartes et en explore quelques propri\u00e9t\u00e9s.","title":"M\u00e9langes parfaits d'un jeu de 32 cartes"},{"location":"nsi_premiere/melange_cartes/#1-melange-parfait","text":"Question 1 Un jeu de 32 cartes peut \u00eatre repr\u00e9sent\u00e9 par un tableau, o\u00f9 chaque carte est repr\u00e9sent\u00e9e par un entier. Cr\u00e9er le tableau jeu32 , contenant les 32 entiers entre 1 et 32. jeu32 = [ \u2026 ] # \u00e0 compl\u00e9ter Pour r\u00e9aliser un m\u00e9lange parfait d'un jeu de cartes, on le s\u00e9pare en 2 paquets de m\u00eame taille avant de m\u00e9langer ensemble les 2 paquets cr\u00e9\u00e9s. Les fonctions ci-dessous permettent de r\u00e9cup\u00e9rer la moiti\u00e9 du \"dessus\" et la moiti\u00e9 du \"dessous\" d'un jeu de cartes. def dessus ( tab ): return ( tab [: len ( tab ) // 2 ]) def dessous ( tab ): return ( tab [ len ( tab ) // 2 :]) \u00c0 r\u00e9aliser Ex\u00e9cuter les appels dessus(jeu32) et dessous(jeu32) et observer le r\u00e9sultat produit. Lors du m\u00e9lange parfait d'un jeu de cartes, on le s\u00e9pare en 2 paquets de m\u00eame taille : le paquet A d\u00e9signe la moiti\u00e9 du dessus et le paquet B d\u00e9signe la moiti\u00e9 du dessous. Puis on alterne les cartes d'un paquet et de l'autre. Le m\u00e9lange peut se r\u00e9aliser de 2 fa\u00e7ons : - soit c'est la carte du dessus du paquet A qui sera au-dessus du paquet m\u00e9lang\u00e9 : ce m\u00e9lange est appel\u00e9 out-shuffle ; - soit c'est la carte du dessus du paquet B qui sera au-dessus du paquet m\u00e9lang\u00e9 : ce m\u00e9lange est appel\u00e9 in-shuffle . Voici un exemple avec un jeu initial de 8 cartes : observer la position des cartes extr\u00eames (1 et 8) dans les manipulations suivantes. On s\u00e9pare le jeu en 2 paquets de m\u00eame taille : le paquet A est constitu\u00e9 des cartes 1 \u00e0 4, le paquet B des cartes 5 \u00e0 8. Voici le paquet obtenu apr\u00e8s un m\u00e9lange out-shuffle : les cartes du paquet A occupent les places 1, 3, 5 et 7. Les cartes extr\u00eames (1 et 8) ont conserv\u00e9 leur position initiale (\u00e0 l'ext\u00e9rieur : out ). Voici le paquet obtenu apr\u00e8s un m\u00e9lange in-shuffle : les cartes du paquet A occupent les places 2, 4, 6 et 8. Les cartes extr\u00eames (1 et 8) sont d\u00e9sormais \u00e0 l'int\u00e9rieur du paquet m\u00e9lang\u00e9 (\u00e0 l'int\u00e9rieur : in ).","title":"1. M\u00e9lange parfait"},{"location":"nsi_premiere/melange_cartes/#2-melange-out-shuffle","text":"","title":"2. M\u00e9lange Out-shuffle"},{"location":"nsi_premiere/melange_cartes/#21-fonction-outshuffle","text":"Afin de pouvoir simuler des m\u00e9langes r\u00e9p\u00e9t\u00e9s, on programme une fonction qui agit sur un jeu de carte comme un m\u00e9lange out-shuffle . Question 2 Compl\u00e9ter la fonction outshuffle(tab) qui prend en param\u00e8tre un tableau repr\u00e9sentant un jeu de cartes et qui renvoie le contenu de ce tableau apr\u00e8s un m\u00e9lange de type out-shuffle. On suppose que tab contient un nombre pair d'\u00e9l\u00e9ments . def outshuffle ( tab ): # on s\u00e9pare le paquet de cartes en 2 tas_haut = \u2026 # \u00e0 compl\u00e9ter tas_bas = \u2026 # \u00e0 compl\u00e9ter # on cr\u00e9e un tableau de m\u00eame longueur que tab tab2 = [ 0 ] * len ( tab ) # on copie dans tab2 les cartes de tas_haut et tas_bas en les alternant # dans le tri out-shuffle, la carte du dessus du paquet initial reste # au-dessus du paquet m\u00e9lang\u00e9 for i in range ( len ( tas_haut )): # rangs pairs tab2 [ 2 * i ] = \u2026 # rangs impairs tab2 [ 2 * i + 1 ] = \u2026 return tab2 \u00c0 r\u00e9aliser V\u00e9rifier qu'un m\u00e9lange de jeu32 avec la fonction outshuffle donne bien le r\u00e9sultat attendu. assert ( outshuffle ( jeu32 ) == [ 1 , 17 , 2 , 18 , 3 , 19 , 4 , 20 , 5 , 21 , 6 , 22 , 7 , 23 , 8 , 24 , 9 , 25 , 10 , 26 , 11 , 27 , 12 , 28 , 13 , 29 , 14 , 30 , 15 , 31 , 16 , 32 ])","title":"2.1 Fonction  outshuffle"},{"location":"nsi_premiere/melange_cartes/#22-apres-plusieurs-melanges","text":"Question 3 Quelle est la position de la carte 2 du tableau jeu32 apr\u00e8s un m\u00e9lange de type out-shuffle ? Et apr\u00e8s 2 m\u00e9langes ? 3 m\u00e9langes ? Question 4 En appliquant successivement plusieurs fois le m\u00e9lange out-shuffle, peut-on revenir \u00e0 l'ordre initial du jeu de 32 cartes ? Si oui, au bout de combien de m\u00e9langes au minimum ? Question 5 Que r\u00e9alise la fonction cycle_out(tab) ci-dessous ? Quelle est la valeur de cycle_out(jeu32) ? Comment interpr\u00e9ter cette valeur ? def cycle_out ( tab ): tab2 = tab [:] #copie des valeurs contenues dans tab compteur = 1 tab = outshuffle ( tab ) while tab2 != tab : compteur += 1 tab = outshuffle ( tab ) return compteur","title":"2.2 Apr\u00e8s plusieurs m\u00e9langes"},{"location":"nsi_premiere/melange_cartes/#23-trajectoire-dune-carte-fixee","text":"On s'int\u00e9resse dans cette partie \u00e0 toutes les positions occup\u00e9es par la carte 2 du jeu jeu32 au cours des m\u00e9langes successifs jusqu'\u00e0 revenir \u00e0 la configuration initiale du jeu. Info La m\u00e9thode tab.index(valeur) permet de renvoyer l'indice de la premi\u00e8re occurrence de valeur dans le tableau tab . Exemple Dans le tableau jeu32 , la carte 2 appara\u00eet en 2e position, c'est-\u00e0-dire avec l'indice 1. jeu32 . index ( 2 ) 1 Il peut \u00eatre int\u00e9ressant de constater que cette valeur est le nombre de cartes \"au-dessus\" de la carte 2 dans le paquet. Question 6 Quels sont tous les indices de la carte 2 du tableau jeu32 lorsqu'on effectue des m\u00e9langes out-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part ? nombre de m\u00e9lange(s) out-shuffle indice de la carte 2 0 1 1 2 3 ... \u00e0 compl\u00e9ter Question 7 On r\u00e9alise des m\u00e9langes out-shuffle \u00e0 partir du tableau jeu32 . Conjecturer une formule permettant d'obtenir l'indice de la carte 2 dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange out-shuffle, en fonction de son indice actuel. \u00c0 r\u00e9aliser V\u00e9rifier que la formule conjectur\u00e9e permet de passer de chacun des indices du tableau de la question 6 \u00e0 l'indice suivant, obtenu avec un nouveau m\u00e9lange out-shuffle de jeu32 . En particulier, \u00e0 partir de l'indice de la derni\u00e8re ligne du tableau, la formule conjectur\u00e9e doit donner 1, qui serait l'indice de la carte 2 apr\u00e8s un nouveau m\u00e9lange.","title":"2.3 Trajectoire d'une carte fix\u00e9e"},{"location":"nsi_premiere/melange_cartes/#24-trajectoire-dune-carte-quelconque","text":"La fonction orbite_out(tab, valeur) ci-dessous permet d'obtenir le tableau de tous les indices de la carte valeur dans le tableau tab lorsqu'on effectue 5 m\u00e9langes out-shuffle successifs. def orbite_out ( tab , valeur ): orbite = [ 0 ] * 5 for i in range ( 5 ): orbite [ i ] = tab . index ( valeur ) tab = outshuffle ( tab ) return orbite Question 8 Utiliser la fonction pr\u00e9c\u00e9dente pour explorer les indices de quelques cartes du tableau jeu32 lorsqu'on effectue des m\u00e9langes out-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part. Conjecturer une formule permettant d'obtenir l'indice de la carte valeur dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange out-shuffle, en fonction de son indice actuel. Question 9 Cr\u00e9er une fonction orbite_conjecture_out(valeur) permettant d'obtenir le tableau de tous les indices de la carte valeur dans le tableau jeu32 , au fur et \u00e0 mesure des m\u00e9langes, selon la conjecture formul\u00e9e \u00e0 la question pr\u00e9c\u00e9dente. def orbite_conjecture_out ( valeur ): # \u00e0 compl\u00e9ter Question 10 Cr\u00e9er une fonction validation_conjecture_out() qui v\u00e9rifie si, pour toutes les valeurs des cartes de jeu32 , les tableaux orbite_out(jeu32, valeur) et orbite_conjecture_out(valeur) sont identiques. def validation_conjecture_out ( tab ): # \u00e0 compl\u00e9ter","title":"2.4 Trajectoire d'une carte quelconque"},{"location":"nsi_premiere/melange_cartes/#25-synthese","text":"Question 11 R\u00e9diger une synth\u00e8se des r\u00e9sultats \u00e9tablis concernant le m\u00e9lange out-shuffle.","title":"2.5 Synth\u00e8se"},{"location":"nsi_premiere/melange_cartes/#3-melange-in-shuffle","text":"","title":"3. M\u00e9lange in-shuffle"},{"location":"nsi_premiere/melange_cartes/#31-fonction-inshuffle","text":"Question 12 \u00c9crire une fonction inshuffle(tab) qui prend en param\u00e8tre un tableau repr\u00e9sentant un jeu de cartes et qui renvoie le contenu de ce tableau apr\u00e8s un m\u00e9lange de type in-shuffle. On suppose que tab contient un nombre pair d'\u00e9l\u00e9ments . def inshuffle ( tab ): # \u00e0 compl\u00e9ter","title":"3.1 Fonction inshuffle"},{"location":"nsi_premiere/melange_cartes/#32-apres-plusieurs-melanges","text":"Question 13 En appliquant successivement plusieurs fois le m\u00e9lange in-shuffle, peut-on revenir \u00e0 l'ordre initial du jeu de 32 cartes ? Si oui, au bout de combien de m\u00e9langes au minimum ? On utilisera une fonction pour d\u00e9terminer cette valeur .","title":"3.2 Apr\u00e8s plusieurs m\u00e9langes"},{"location":"nsi_premiere/melange_cartes/#33-trajectoire-dune-carte-fixee","text":"Question 14 Quels sont tous les indices de la carte 2 du tableau jeu32 lorsqu'on effectue des m\u00e9langes in-shuffle jusqu'\u00e0 revenir \u00e0 la position de d\u00e9part ? nombre de m\u00e9lange(s) in-shuffle indice de la carte 2 0 1 1 2 3 ... \u00e0 compl\u00e9ter Question 15 On r\u00e9alise des m\u00e9langes in-shuffle \u00e0 partir du tableau jeu32 . Conjecturer une formule permettant d'obtenir l'indice de la carte 2 dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange in-shuffle, en fonction de son indice actuel.","title":"3.3 Trajectoire d'une carte fix\u00e9e"},{"location":"nsi_premiere/melange_cartes/#34-trajectoire-dune-carte-quelconque","text":"La fonction orbite_in(tab, valeur) ci-dessous permet d'obtenir le tableau de tous les indices de la carte valeur dans le tableau tab lorsqu'on effectue 10 m\u00e9langes in-shuffle. def orbite_in ( tab , valeur ): orbite = [ 0 ] * 10 for i in range ( 10 ): orbite [ i ] = tab . index ( valeur ) tab = inshuffle ( tab ) return orbite Question 16 Utiliser la fonction pr\u00e9c\u00e9dente pour explorer les indices de quelques cartes du tableau jeu32 lorsqu'on effectue des m\u00e9langes in-shuffle jusqu'\u00e0 revenir \u00e0 la configuration de d\u00e9part. Conjecturer une formule permettant d'obtenir l'indice de la carte valeur dans le tableau jeu32 \u00e0 l'issue du prochain m\u00e9lange in-shuffle, en fonction de son indice actuel. Question 17 Cr\u00e9er une fonction orbite_conjecture_in(valeur) permettant d'obtenir le tableau de tous les indices de la carte valeur dans le tableau jeu32 , au fur et \u00e0 mesure des m\u00e9langes, selon la conjecture formul\u00e9e \u00e0 la question pr\u00e9c\u00e9dente. def orbite_conjecture_in ( valeur ): # \u00e0 compl\u00e9ter Question 18 Cr\u00e9er une fonction validation_conjecture_in() qui v\u00e9rifie si pour toutes les valeurs des cartes de jeu32 les tableaux orbite_in(jeu32, valeur) et orbite_conjecture_in(valeur) sont identiques. def validation_conjecture_in ( tab ): # \u00e0 compl\u00e9ter","title":"3.4 Trajectoire d'une carte quelconque"},{"location":"nsi_premiere/melange_cartes/#35-synthese","text":"Question 19 R\u00e9diger une synth\u00e8se des r\u00e9sultats \u00e9tablis concernant le m\u00e9lange in-shuffle.","title":"3.5 Synth\u00e8se"},{"location":"nsi_premiere/problemes/","text":"S\u00e9lection de probl\u00e8mes Algorithmes gloutons Volvian, c'est mon eau : Prologin 2020, \u00e9preuve r\u00e9gionale Binaire Tour de magie : Prologin 2013, qualification Tour de cartes Instructions conditionnelles M\u00e9t\u00e9orite, Vagues, Vent ! : Prologin 2020, \u00e9preuve r\u00e9gionale","title":"Probl\u00e8mes"},{"location":"nsi_premiere/problemes/#selection-de-problemes","text":"","title":"S\u00e9lection de probl\u00e8mes"},{"location":"nsi_premiere/problemes/#algorithmes-gloutons","text":"Volvian, c'est mon eau : Prologin 2020, \u00e9preuve r\u00e9gionale","title":"Algorithmes gloutons"},{"location":"nsi_premiere/problemes/#binaire","text":"Tour de magie : Prologin 2013, qualification Tour de cartes","title":"Binaire"},{"location":"nsi_premiere/problemes/#instructions-conditionnelles","text":"M\u00e9t\u00e9orite, Vagues, Vent ! : Prologin 2020, \u00e9preuve r\u00e9gionale","title":"Instructions conditionnelles"},{"location":"nsi_premiere/qcm_nsi/","text":"QCM NSI G\u00e9n\u00e9rateur de QCM portant sur les sept th\u00e8mes du programme de 1ere NSI.","title":"QCM NSI"},{"location":"nsi_premiere/qcm_nsi/#qcm-nsi","text":"G\u00e9n\u00e9rateur de QCM portant sur les sept th\u00e8mes du programme de 1ere NSI.","title":"QCM NSI"},{"location":"nsi_premiere/tour_de_cartes/","text":"Un tour de cartes D'apr\u00e8s un exercice du concours Castor informatique suisse Le jeu de 7 familles de l'informatique est un jeu de cartes compos\u00e9 de 42 cartes r\u00e9parties en 7 familles, repr\u00e9sentant des personnes c\u00e9l\u00e8bres dans l'histoire de l'informatique. Il a \u00e9t\u00e9 publi\u00e9 par interstice.info . On aligne quelques cartes du jeu sur une seule rang\u00e9e et on consid\u00e8re la r\u00e8gle suivante : Lors d\u2019un tour, on examine les cartes en commen\u00e7ant par celle la plus \u00e0 droite : \u2014 Si la carte est face vers le haut, on la retourne \u00e0 l\u2019envers et s'il reste des cartes \u00e0 sa gauche, on passe \u00e0 la carte suivante. \u2014 Si la carte est face vers le bas, on la retourne \u00e0 l\u2019endroit et on ne fait rien sur les cartes \u00e0 sa gauche. Voici un exemple : Situation de d\u00e9part : Situation apr\u00e8s un tour : Voici l'\u00e9nonc\u00e9 du probl\u00e8me : On extrait la famille Algorithmes & programmation du jeu (t\u00e9l\u00e9charger les cartes \u00e0 imprimer ) et on range les 6 cartes, face vers le haut, dans l'ordre croissant, de droite \u00e0 gauche (elles sont num\u00e9rot\u00e9es en binaire de 001 \u00e0 110). Puis on les retourne toutes. On applique alors la r\u00e8gle pr\u00e9c\u00e9dente pendant 16 tours. Question Quelle(s) carte(s) est(sont) face vers le haut \u00e0 l'issue des 16 tours ?","title":"Un tour de cartes"},{"location":"nsi_premiere/tour_de_cartes/#un-tour-de-cartes","text":"D'apr\u00e8s un exercice du concours Castor informatique suisse Le jeu de 7 familles de l'informatique est un jeu de cartes compos\u00e9 de 42 cartes r\u00e9parties en 7 familles, repr\u00e9sentant des personnes c\u00e9l\u00e8bres dans l'histoire de l'informatique. Il a \u00e9t\u00e9 publi\u00e9 par interstice.info . On aligne quelques cartes du jeu sur une seule rang\u00e9e et on consid\u00e8re la r\u00e8gle suivante : Lors d\u2019un tour, on examine les cartes en commen\u00e7ant par celle la plus \u00e0 droite : \u2014 Si la carte est face vers le haut, on la retourne \u00e0 l\u2019envers et s'il reste des cartes \u00e0 sa gauche, on passe \u00e0 la carte suivante. \u2014 Si la carte est face vers le bas, on la retourne \u00e0 l\u2019endroit et on ne fait rien sur les cartes \u00e0 sa gauche. Voici un exemple : Situation de d\u00e9part : Situation apr\u00e8s un tour : Voici l'\u00e9nonc\u00e9 du probl\u00e8me : On extrait la famille Algorithmes & programmation du jeu (t\u00e9l\u00e9charger les cartes \u00e0 imprimer ) et on range les 6 cartes, face vers le haut, dans l'ordre croissant, de droite \u00e0 gauche (elles sont num\u00e9rot\u00e9es en binaire de 001 \u00e0 110). Puis on les retourne toutes. On applique alors la r\u00e8gle pr\u00e9c\u00e9dente pendant 16 tours. Question Quelle(s) carte(s) est(sont) face vers le haut \u00e0 l'issue des 16 tours ?","title":"Un tour de cartes"},{"location":"python/boucles_bornees/","text":"Boucles born\u00e9es Les boucles born\u00e9es servent \u00e0 ex\u00e9cuter certaines instructions d'un programme de mani\u00e8re r\u00e9p\u00e9titive, un nombre pr\u00e9d\u00e9fini de fois. Par exemple pour r\u00e9p\u00e9ter quatre fois un bloc d'instructions, on peut \u00e9crire : for i in range ( 4 ): bloc d 'instructions Exemple : for i in range ( 4 ): print ( \"Bienvenue !\" ) Bienvenue ! Bienvenue ! Bienvenue ! Bienvenue ! En premi\u00e8re approche, on peut se contenter de la syntaxe : for i in range ( n ) : bloc d 'instructions pour r\u00e9p\u00e9ter n fois un bloc d'instructions. Mais les deux instructions que cette syntaxe combine : for ... in et range() permettent de nombreuses possibilit\u00e9s. L'instruction for La boucle born\u00e9e (ou instruction for ) permet d\u2019it\u00e9rer sur les \u00e9l\u00e9ments d\u2019une s\u00e9quence (liste, chaine de caract\u00e8res, etc.) dans l'ordre dans lequel les \u00e9l\u00e9ments apparaissent dans la s\u00e9quence. Exemple : liste_mots = [ 'anthracite' , 'blanc' , 'cyan' ] for mot in liste_mots : print ( mot ) anthracite blanc cyan La syntaxe de la boucle for est : for iterateur in sequence : instructions L'it\u00e9rateur est une variable \u00e0 laquelle il faut donner un nom, et qui prend successivement les valeurs des \u00e9l\u00e9ments de la s\u00e9quence. Le bloc d'instructions \u00e0 ex\u00e9cuter dans le corps de la boucle est \u00e0 indenter. La fonction range() Pour it\u00e9rer sur une suite de nombres, on utilise la fonction range() . Exemple : for i in range ( 4 ): print ( i , i ** 2 ) 0 0 1 1 2 4 3 9 Ici i prend successivement les valeurs 0, 1, 2, puis 3 et pour chaque valeur de i on affiche i et son carr\u00e9. La syntaxe g\u00e9n\u00e9rale est range(debut, fin, pas) . La liste des valeurs g\u00e9n\u00e9r\u00e9es commence avec la valeur debut ; les valeurs suivantes sont g\u00e9n\u00e9r\u00e9es en augmentant de la valeur pas et la liste s'arr\u00eate juste avant d'atteindre ou d\u00e9passer la valeur fin . debut est un param\u00e8tre facultatif : sa valeur par d\u00e9faut est 0 . pas est aussi un param\u00e8tre facultatif. Il vaut 1 par d\u00e9faut ; il faut donner les 3 param\u00e8tres de range() pour modifier sa valeur. La syntaxe range(valeur) est donc \u00e9quivalente \u00e0 range(0, valeur, 1) et g\u00e9n\u00e8re la liste les entiers de 0 \u00e0 valeur - 1. Exemple : range(10) g\u00e9n\u00e8re la liste 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 range(4, 10) g\u00e9n\u00e8re la liste 4, 5, 6, 7, 8, 9 range(1, 12, 3) g\u00e9n\u00e8re la liste 1, 4, 7, 10 range(5, -10, -3) g\u00e9n\u00e8re la liste 5, 2, -1, -4, -7 Info L'objet renvoy\u00e9 par range() se comporte presque comme une liste, mais n'en est pas une. Cet objet g\u00e9n\u00e8re les \u00e9l\u00e9ments de la s\u00e9quence au fur et \u00e0 mesure de l'it\u00e9ration, sans r\u00e9ellement produire la liste en tant que telle. It\u00e9rer sur les indices d'une s\u00e9quence Pour it\u00e9rer sur les indices d'une s\u00e9quence, on peut combiner les fonctions range() et len() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for i in range ( len ( couleurs )): print ( i , couleurs [ i ]) 0 anthracite 1 blanc 2 cyan Mais il existe une instruction sp\u00e9cifique pour cela : dans une boucle sur une s\u00e9quence, l'indice et la valeur correspondante peuvent \u00eatre r\u00e9cup\u00e9r\u00e9s en m\u00eame temps en utilisant la fonction enumerate() . Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for indice , valeur in enumerate ( couleurs ): print ( indice , valeur ) 0 anthracite 1 blanc 2 cyan It\u00e9rer sur plusieurs s\u00e9quences Pour faire une boucle sur deux s\u00e9quences ou plus en m\u00eame temps, les \u00e9l\u00e9ments peuvent \u00eatre associ\u00e9s en utilisant la fonction zip() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] codes_hex = [ '#303030' , '#FFFFFF' , '#00FFFF' ] for couleur , code in zip ( couleurs , codes_hex ): print ( couleur , code ) anthracite #303030 blanc #FFFFFF cyan #00FFFF","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees/#boucles-bornees","text":"Les boucles born\u00e9es servent \u00e0 ex\u00e9cuter certaines instructions d'un programme de mani\u00e8re r\u00e9p\u00e9titive, un nombre pr\u00e9d\u00e9fini de fois. Par exemple pour r\u00e9p\u00e9ter quatre fois un bloc d'instructions, on peut \u00e9crire : for i in range ( 4 ): bloc d 'instructions Exemple : for i in range ( 4 ): print ( \"Bienvenue !\" ) Bienvenue ! Bienvenue ! Bienvenue ! Bienvenue ! En premi\u00e8re approche, on peut se contenter de la syntaxe : for i in range ( n ) : bloc d 'instructions pour r\u00e9p\u00e9ter n fois un bloc d'instructions. Mais les deux instructions que cette syntaxe combine : for ... in et range() permettent de nombreuses possibilit\u00e9s.","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees/#linstruction-for","text":"La boucle born\u00e9e (ou instruction for ) permet d\u2019it\u00e9rer sur les \u00e9l\u00e9ments d\u2019une s\u00e9quence (liste, chaine de caract\u00e8res, etc.) dans l'ordre dans lequel les \u00e9l\u00e9ments apparaissent dans la s\u00e9quence. Exemple : liste_mots = [ 'anthracite' , 'blanc' , 'cyan' ] for mot in liste_mots : print ( mot ) anthracite blanc cyan La syntaxe de la boucle for est : for iterateur in sequence : instructions L'it\u00e9rateur est une variable \u00e0 laquelle il faut donner un nom, et qui prend successivement les valeurs des \u00e9l\u00e9ments de la s\u00e9quence. Le bloc d'instructions \u00e0 ex\u00e9cuter dans le corps de la boucle est \u00e0 indenter.","title":"L'instruction for"},{"location":"python/boucles_bornees/#la-fonction-range","text":"Pour it\u00e9rer sur une suite de nombres, on utilise la fonction range() . Exemple : for i in range ( 4 ): print ( i , i ** 2 ) 0 0 1 1 2 4 3 9 Ici i prend successivement les valeurs 0, 1, 2, puis 3 et pour chaque valeur de i on affiche i et son carr\u00e9. La syntaxe g\u00e9n\u00e9rale est range(debut, fin, pas) . La liste des valeurs g\u00e9n\u00e9r\u00e9es commence avec la valeur debut ; les valeurs suivantes sont g\u00e9n\u00e9r\u00e9es en augmentant de la valeur pas et la liste s'arr\u00eate juste avant d'atteindre ou d\u00e9passer la valeur fin . debut est un param\u00e8tre facultatif : sa valeur par d\u00e9faut est 0 . pas est aussi un param\u00e8tre facultatif. Il vaut 1 par d\u00e9faut ; il faut donner les 3 param\u00e8tres de range() pour modifier sa valeur. La syntaxe range(valeur) est donc \u00e9quivalente \u00e0 range(0, valeur, 1) et g\u00e9n\u00e8re la liste les entiers de 0 \u00e0 valeur - 1. Exemple : range(10) g\u00e9n\u00e8re la liste 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 range(4, 10) g\u00e9n\u00e8re la liste 4, 5, 6, 7, 8, 9 range(1, 12, 3) g\u00e9n\u00e8re la liste 1, 4, 7, 10 range(5, -10, -3) g\u00e9n\u00e8re la liste 5, 2, -1, -4, -7 Info L'objet renvoy\u00e9 par range() se comporte presque comme une liste, mais n'en est pas une. Cet objet g\u00e9n\u00e8re les \u00e9l\u00e9ments de la s\u00e9quence au fur et \u00e0 mesure de l'it\u00e9ration, sans r\u00e9ellement produire la liste en tant que telle.","title":"La fonction range()"},{"location":"python/boucles_bornees/#iterer-sur-les-indices-dune-sequence","text":"Pour it\u00e9rer sur les indices d'une s\u00e9quence, on peut combiner les fonctions range() et len() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for i in range ( len ( couleurs )): print ( i , couleurs [ i ]) 0 anthracite 1 blanc 2 cyan Mais il existe une instruction sp\u00e9cifique pour cela : dans une boucle sur une s\u00e9quence, l'indice et la valeur correspondante peuvent \u00eatre r\u00e9cup\u00e9r\u00e9s en m\u00eame temps en utilisant la fonction enumerate() . Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for indice , valeur in enumerate ( couleurs ): print ( indice , valeur ) 0 anthracite 1 blanc 2 cyan","title":"It\u00e9rer sur les indices d'une s\u00e9quence"},{"location":"python/boucles_bornees/#iterer-sur-plusieurs-sequences","text":"Pour faire une boucle sur deux s\u00e9quences ou plus en m\u00eame temps, les \u00e9l\u00e9ments peuvent \u00eatre associ\u00e9s en utilisant la fonction zip() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] codes_hex = [ '#303030' , '#FFFFFF' , '#00FFFF' ] for couleur , code in zip ( couleurs , codes_hex ): print ( couleur , code ) anthracite #303030 blanc #FFFFFF cyan #00FFFF","title":"It\u00e9rer sur plusieurs s\u00e9quences"},{"location":"python/boucles_bornees_exercices/","text":"Exercices : boucles born\u00e9es 1. Affichage Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne. Exercice 1.1 Afficher sur une ligne \"la table de multiplication de 8\", c'est \u00e0 dire les produits : 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 . Exercice 1.2 Afficher sur 10 lignes les \"tables de multiplication\" des entiers de 1 \u00e0 10. 2. Somme Exercice 2.1 Calculer la somme des entiers de 1 \u00e0 100. Exercice 2.2 Calculer la somme des cubes des entiers de 1 \u00e0 100. Comparer le r\u00e9sultat au carr\u00e9 de la somme des entiers de 1 \u00e0 100. 3. Calculs en boucle Exercice 3.1 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 50 ): resultat = resultat + 2 Exercice 3.2 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 5 ): resultat = resultat * 2 Exercice 3.3 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 1 , 5 ): resultat = resultat + i Exercice 3.4 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 1 , 5 ): resultat = resultat * i 4. Trac\u00e9s en boucle Exercice 4.1 R\u00e9aliser la figure suivante : Exercice 4.2 R\u00e9aliser la figure suivante : Exercice 4.3 R\u00e9aliser la figure suivante : Exercice 4.4 R\u00e9aliser la figure suivante : Exercice 4.5 R\u00e9aliser la figure suivante : Exercice 4.6 R\u00e9aliser la figure suivante : Exercice 4.7 R\u00e9aliser la figure suivante :","title":"Exercices"},{"location":"python/boucles_bornees_exercices/#exercices-boucles-bornees","text":"","title":"Exercices : boucles born\u00e9es"},{"location":"python/boucles_bornees_exercices/#1-affichage","text":"Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne.","title":"1. Affichage"},{"location":"python/boucles_bornees_exercices/#exercice-11","text":"Afficher sur une ligne \"la table de multiplication de 8\", c'est \u00e0 dire les produits : 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 .","title":"Exercice 1.1"},{"location":"python/boucles_bornees_exercices/#exercice-12","text":"Afficher sur 10 lignes les \"tables de multiplication\" des entiers de 1 \u00e0 10.","title":"Exercice 1.2"},{"location":"python/boucles_bornees_exercices/#2-somme","text":"","title":"2. Somme"},{"location":"python/boucles_bornees_exercices/#exercice-21","text":"Calculer la somme des entiers de 1 \u00e0 100.","title":"Exercice 2.1"},{"location":"python/boucles_bornees_exercices/#exercice-22","text":"Calculer la somme des cubes des entiers de 1 \u00e0 100. Comparer le r\u00e9sultat au carr\u00e9 de la somme des entiers de 1 \u00e0 100.","title":"Exercice 2.2"},{"location":"python/boucles_bornees_exercices/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_bornees_exercices/#exercice-31","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 50 ): resultat = resultat + 2","title":"Exercice 3.1"},{"location":"python/boucles_bornees_exercices/#exercice-32","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 5 ): resultat = resultat * 2","title":"Exercice 3.2"},{"location":"python/boucles_bornees_exercices/#exercice-33","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 1 , 5 ): resultat = resultat + i","title":"Exercice 3.3"},{"location":"python/boucles_bornees_exercices/#exercice-34","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 1 , 5 ): resultat = resultat * i","title":"Exercice 3.4"},{"location":"python/boucles_bornees_exercices/#4-traces-en-boucle","text":"","title":"4. Trac\u00e9s en boucle"},{"location":"python/boucles_bornees_exercices/#exercice-41","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.1"},{"location":"python/boucles_bornees_exercices/#exercice-42","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.2"},{"location":"python/boucles_bornees_exercices/#exercice-43","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.3"},{"location":"python/boucles_bornees_exercices/#exercice-44","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.4"},{"location":"python/boucles_bornees_exercices/#exercice-45","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.5"},{"location":"python/boucles_bornees_exercices/#exercice-46","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.6"},{"location":"python/boucles_bornees_exercices/#exercice-47","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.7"},{"location":"python/boucles_bornees_imbriquees_questions/","text":"Questions : boucles born\u00e9es imbriqu\u00e9es 1. Trac\u00e9 de motifs Info L'instruction print('*') affiche un caract\u00e8re * et passe \u00e0 la ligne suivante. L'instruction print('*', end='') affiche un caract\u00e8re * et ne passe pas \u00e0 la ligne. L'instruction print() n'affiche aucun caract\u00e8re et passe \u00e0 la ligne. Question 1.1 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? **** **** **** **** **** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 4 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 4 ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 4 \u00e9toiles. Question 1.2 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? * ** *** **** ***** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 1 \u00e0 5 \u00e9toiles. Le nombre d'\u00e9toiles trac\u00e9es vaut 1 sur la premi\u00e8re ligne, 2 sur la 2e, etc. Seule la boucle for j in range(i + 1) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4. Question 1.3 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? ***** **** *** ** * Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 5 \u00e0 1 \u00e9toile(s). Le nombre d'\u00e9toiles trac\u00e9es vaut 5 sur la premi\u00e8re ligne, 4 sur la 2e, etc. Seule la boucle for j in range(5 - i) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4. 2. Questions num\u00e9riques Question 2.1 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( 3 ): total = total + 1 Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i : - j prend les valeurs 0 \u00e0 2 soit 3 valeurs. - La variable total est augment\u00e9e 3 fois de la quantit\u00e9 1 Finalement, total vaut 0 + 4*3 = 12 Question 2.2 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( i ): total = total + i Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 la valeur de i , soit de 1. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 2 fois de la valeur de i , soit de 2*2 = 4. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 3 fois de la valeur de i , soit de 3*3 = 9. Finalement, total vaut 0 + 1 + 2*2 + 3*3 = 14. valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 i = 0 X X X i = 1 1 X X i = 2 2 2 X i = 3 3 3 3 Question 2.3 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 5 ): for j in range ( i ): total = total + j Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 4. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 de 0. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 = 1. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 = 3. Quand i = 4 , j prend les valeurs 0, 1, 2 et 3, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 + 3 = 6 Finalement, total vaut 0 + 1 + 3 + 6 = 10 valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 j = 3 i = 0 X X X X i = 1 0 X X X i = 2 0 1 X X i = 3 0 1 2 X i = 4 0 1 2 3 3. Trac\u00e9s en boucles Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 3.1 Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_carre in range ( 4 ) : for nb_cote in range ( 3 ) : t . forward ( 100 ) t . left ( 90 ) t . right ( 120 ) Boucle B : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 30 ) Boucle C : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 120 ) t . left ( 90 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 carr\u00e9s \u00e0 tracer ( range(3) ) et chaque carr\u00e9 poss\u00e8de 4 c\u00f4t\u00e9s ( range(4) ). Les angles du carr\u00e9 font 90\u00b0 et chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu. Question 3.2 Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle B : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle C : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ) et chaque hexagone poss\u00e8de 6 c\u00f4t\u00e9s ( range(6) ). Les angles de l'hexagone font 120\u00b0 (donc la tortue doit pivoter de 180 - 120 = 60\u00b0) et chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Boucles born\u00e9es imbriqu\u00e9es"},{"location":"python/boucles_bornees_imbriquees_questions/#questions-boucles-bornees-imbriquees","text":"","title":"Questions : boucles born\u00e9es imbriqu\u00e9es"},{"location":"python/boucles_bornees_imbriquees_questions/#1-trace-de-motifs","text":"Info L'instruction print('*') affiche un caract\u00e8re * et passe \u00e0 la ligne suivante. L'instruction print('*', end='') affiche un caract\u00e8re * et ne passe pas \u00e0 la ligne. L'instruction print() n'affiche aucun caract\u00e8re et passe \u00e0 la ligne.","title":"1. Trac\u00e9 de motifs"},{"location":"python/boucles_bornees_imbriquees_questions/#question-11","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? **** **** **** **** **** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 4 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 4 ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 4 \u00e9toiles.","title":"Question 1.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-12","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? * ** *** **** ***** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 1 \u00e0 5 \u00e9toiles. Le nombre d'\u00e9toiles trac\u00e9es vaut 1 sur la premi\u00e8re ligne, 2 sur la 2e, etc. Seule la boucle for j in range(i + 1) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4.","title":"Question 1.2"},{"location":"python/boucles_bornees_imbriquees_questions/#question-13","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? ***** **** *** ** * Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 5 \u00e0 1 \u00e9toile(s). Le nombre d'\u00e9toiles trac\u00e9es vaut 5 sur la premi\u00e8re ligne, 4 sur la 2e, etc. Seule la boucle for j in range(5 - i) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4.","title":"Question 1.3"},{"location":"python/boucles_bornees_imbriquees_questions/#2-questions-numeriques","text":"","title":"2. Questions num\u00e9riques"},{"location":"python/boucles_bornees_imbriquees_questions/#question-21","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( 3 ): total = total + 1 Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i : - j prend les valeurs 0 \u00e0 2 soit 3 valeurs. - La variable total est augment\u00e9e 3 fois de la quantit\u00e9 1 Finalement, total vaut 0 + 4*3 = 12","title":"Question 2.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-22","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( i ): total = total + i Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 la valeur de i , soit de 1. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 2 fois de la valeur de i , soit de 2*2 = 4. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 3 fois de la valeur de i , soit de 3*3 = 9. Finalement, total vaut 0 + 1 + 2*2 + 3*3 = 14. valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 i = 0 X X X i = 1 1 X X i = 2 2 2 X i = 3 3 3 3","title":"Question 2.2"},{"location":"python/boucles_bornees_imbriquees_questions/#question-23","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 5 ): for j in range ( i ): total = total + j Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 4. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 de 0. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 = 1. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 = 3. Quand i = 4 , j prend les valeurs 0, 1, 2 et 3, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 + 3 = 6 Finalement, total vaut 0 + 1 + 3 + 6 = 10 valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 j = 3 i = 0 X X X X i = 1 0 X X X i = 2 0 1 X X i = 3 0 1 2 X i = 4 0 1 2 3","title":"Question 2.3"},{"location":"python/boucles_bornees_imbriquees_questions/#3-traces-en-boucles","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"3. Trac\u00e9s en boucles"},{"location":"python/boucles_bornees_imbriquees_questions/#question-31","text":"Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_carre in range ( 4 ) : for nb_cote in range ( 3 ) : t . forward ( 100 ) t . left ( 90 ) t . right ( 120 ) Boucle B : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 30 ) Boucle C : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 120 ) t . left ( 90 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 carr\u00e9s \u00e0 tracer ( range(3) ) et chaque carr\u00e9 poss\u00e8de 4 c\u00f4t\u00e9s ( range(4) ). Les angles du carr\u00e9 font 90\u00b0 et chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-32","text":"Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle B : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle C : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ) et chaque hexagone poss\u00e8de 6 c\u00f4t\u00e9s ( range(6) ). Les angles de l'hexagone font 120\u00b0 (donc la tortue doit pivoter de 180 - 120 = 60\u00b0) et chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.2"},{"location":"python/boucles_bornees_questions/","text":"Questions : boucles born\u00e9es 1. Affichage Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne. Question 1.1 Question Parmi les 4 boucles suivantes, lesquelles permettent d'afficher sur une seule ligne les entiers de 1 \u00e0 10, s\u00e9par\u00e9s par un espace et rang\u00e9s dans l'ordre croissant ? 1 2 3 4 5 6 7 8 9 10 Boucle A : for i in range ( 10 ): print ( i ) Boucle B : for i in range ( 10 ): print ( i , end = ' ' ) Boucle C : for i in range ( 1 , 11 ): print ( i , end = ' ' ) Boucle D : for i in range ( 10 ): print ( i + 1 , end = ' ' ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, celles qui conviennent consistent : - soit \u00e0 faire varier i de 1 \u00e0 10 ( range(1,11) ) et afficher i ; - soit \u00e0 faire varier i de 0 \u00e0 9 ( range(10) ) et afficher i + 1 . Question 1.2 Question mots = [ 'syst\u00e8me' , 'syst\u00e9matique' , 'syst\u00e9mique' ] Parmi les 4 boucles suivantes, lesquelles permettent d'afficher chaque mot de la liste mots ainsi que son nombre de lettres ? syst\u00e8me comporte 7 lettres syst\u00e9matique comporte 12 lettres syst\u00e9mique comporte 10 lettres Boucle A : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , i , \"lettres\" ) Boucle B : for mot in mots : print ( mot , \"comporte\" , len ( mot ), \"lettres\" ) Boucle C : for mot in mots : print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Boucle D : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La solution B parcourt directement les \u00e9l\u00e9ments de la liste mots et affiche leur valeur et leur nombre de lettres, \u00e0 l'aide de la fonction len() . La solution D parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et affiche leur valeur et leur nombre de lettres. 2. Somme Question 2.1 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 98 , 76 , 54 , 32 , 10 ] Parmi les 4 programmes suivants, lesquels permettent d'afficher la somme des valeurs de la liste nombres ? Programme A : for i in range ( len ( nombres )): somme = 0 somme = somme + nombres [ i ] print ( somme ) Programme B : somme = 0 for i in range ( len ( nombres )): somme = somme + nombres [ i ] print ( somme ) Programme C : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Programme D : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution B parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et ajoute chacun d'eux \u00e0 la variable somme . La solution D parcourt directement les \u00e9l\u00e9ments de la liste et ajoute chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet de la liste de valeurs. Question 2.2 Question Parmi les 4 programmes suivants, lequel permet d'afficher la somme des carr\u00e9s des entiers de 1 \u00e0 10 ? Programme A : for i in range ( 11 ): print ( i ** 2 ) Programme B : somme = 0 for i in range ( 1 , 10 ): somme = somme + i ** 2 print ( somme ) Programme C : somme = 0 for i in range ( 1 , 11 ): somme = somme + i ** 2 print ( somme ) Programme D : somme = 0 for i in range ( 11 ): somme = i ** 2 print ( somme ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution C parcourt la liste des entiers de 1 \u00e0 10 compris, et ajoute le carr\u00e9 de chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet des dix entiers. 3. Calculs en boucle Question 3.1 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + 3 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i , la variable total est augment\u00e9e de la quantit\u00e9 3. Finalement, total vaut 0 + 4*3 = 12 Question 3.2 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i . Finalement, total vaut 0 + 0 + 1 + 2 + 3 = 6. Question 3.3 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i ** 2 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i 2 . Finalement, total vaut 0 + 1 + 4 + 9 = 14 4. Boucle avec une condition Question 4.1 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = - 1 for i in range ( len ( nombres )): if nombres [ i ] == cible : reponse = i Propositions de r\u00e9ponses -1 1 2 6 Solution -1 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres[i] == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc affect\u00e9e deux fois. En fin de boucle, la valeur de la variable est celle de la derni\u00e8re affectation, donc l'indice de la derni\u00e8re occurrence de 34 dans nombres . Question 4.2 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = 0 for nombre in nombres : if nombre == cible : reponse = reponse + 1 Propositions de r\u00e9ponses 0 1 2 6 Solution 0 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc incr\u00e9ment\u00e9e deux fois. En fin de boucle, la valeur de la variable initialis\u00e9e \u00e0 0 est donc 2 . 5. Trac\u00e9s en boucle Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 5.1 Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 60 ) Boucle B : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 60 ) Boucle C : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 120 ) Boucle D : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 6 c\u00f4t\u00e9s et range(6) g\u00e9n\u00e8rera les entiers de 0 \u00e0 5, soit 6 entiers. Les angles \"internes\" de la figure sont de 120\u00b0, la tortue doit donc pivoter de 180 - 120 = 60\u00b0 entre 2 trac\u00e9s. Question 5.2 Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Le programme commence par les instructions suivantes : t = Turtle () # d\u00e9placement sans trac\u00e9 t . penup () t . setposition ( 75 , 150 ) t . pendown () Puis se termine par l'une des boucles suivantes : Boucle A : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 72 ) Boucle B : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 144 ) Boucle C : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 36 ) Boucle D : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 72 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 5 c\u00f4t\u00e9s et range(5) g\u00e9n\u00e8rera les entiers de 0 \u00e0 4, soit 5 entiers. Les angles \"internes\" des pointes de l'\u00e9toile sont de 36\u00b0, la tortue doit donc pivoter de 180 - 36 = 144\u00b0 entre 2 trac\u00e9s.","title":"Questions"},{"location":"python/boucles_bornees_questions/#questions-boucles-bornees","text":"","title":"Questions : boucles born\u00e9es"},{"location":"python/boucles_bornees_questions/#1-affichage","text":"Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne.","title":"1. Affichage"},{"location":"python/boucles_bornees_questions/#question-11","text":"Question Parmi les 4 boucles suivantes, lesquelles permettent d'afficher sur une seule ligne les entiers de 1 \u00e0 10, s\u00e9par\u00e9s par un espace et rang\u00e9s dans l'ordre croissant ? 1 2 3 4 5 6 7 8 9 10 Boucle A : for i in range ( 10 ): print ( i ) Boucle B : for i in range ( 10 ): print ( i , end = ' ' ) Boucle C : for i in range ( 1 , 11 ): print ( i , end = ' ' ) Boucle D : for i in range ( 10 ): print ( i + 1 , end = ' ' ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, celles qui conviennent consistent : - soit \u00e0 faire varier i de 1 \u00e0 10 ( range(1,11) ) et afficher i ; - soit \u00e0 faire varier i de 0 \u00e0 9 ( range(10) ) et afficher i + 1 .","title":"Question 1.1"},{"location":"python/boucles_bornees_questions/#question-12","text":"Question mots = [ 'syst\u00e8me' , 'syst\u00e9matique' , 'syst\u00e9mique' ] Parmi les 4 boucles suivantes, lesquelles permettent d'afficher chaque mot de la liste mots ainsi que son nombre de lettres ? syst\u00e8me comporte 7 lettres syst\u00e9matique comporte 12 lettres syst\u00e9mique comporte 10 lettres Boucle A : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , i , \"lettres\" ) Boucle B : for mot in mots : print ( mot , \"comporte\" , len ( mot ), \"lettres\" ) Boucle C : for mot in mots : print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Boucle D : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La solution B parcourt directement les \u00e9l\u00e9ments de la liste mots et affiche leur valeur et leur nombre de lettres, \u00e0 l'aide de la fonction len() . La solution D parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et affiche leur valeur et leur nombre de lettres.","title":"Question 1.2"},{"location":"python/boucles_bornees_questions/#2-somme","text":"","title":"2. Somme"},{"location":"python/boucles_bornees_questions/#question-21","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 98 , 76 , 54 , 32 , 10 ] Parmi les 4 programmes suivants, lesquels permettent d'afficher la somme des valeurs de la liste nombres ? Programme A : for i in range ( len ( nombres )): somme = 0 somme = somme + nombres [ i ] print ( somme ) Programme B : somme = 0 for i in range ( len ( nombres )): somme = somme + nombres [ i ] print ( somme ) Programme C : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Programme D : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution B parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et ajoute chacun d'eux \u00e0 la variable somme . La solution D parcourt directement les \u00e9l\u00e9ments de la liste et ajoute chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet de la liste de valeurs.","title":"Question 2.1"},{"location":"python/boucles_bornees_questions/#question-22","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher la somme des carr\u00e9s des entiers de 1 \u00e0 10 ? Programme A : for i in range ( 11 ): print ( i ** 2 ) Programme B : somme = 0 for i in range ( 1 , 10 ): somme = somme + i ** 2 print ( somme ) Programme C : somme = 0 for i in range ( 1 , 11 ): somme = somme + i ** 2 print ( somme ) Programme D : somme = 0 for i in range ( 11 ): somme = i ** 2 print ( somme ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution C parcourt la liste des entiers de 1 \u00e0 10 compris, et ajoute le carr\u00e9 de chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet des dix entiers.","title":"Question 2.2"},{"location":"python/boucles_bornees_questions/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_bornees_questions/#question-31","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + 3 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i , la variable total est augment\u00e9e de la quantit\u00e9 3. Finalement, total vaut 0 + 4*3 = 12","title":"Question 3.1"},{"location":"python/boucles_bornees_questions/#question-32","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i . Finalement, total vaut 0 + 0 + 1 + 2 + 3 = 6.","title":"Question 3.2"},{"location":"python/boucles_bornees_questions/#question-33","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i ** 2 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i 2 . Finalement, total vaut 0 + 1 + 4 + 9 = 14","title":"Question 3.3"},{"location":"python/boucles_bornees_questions/#4-boucle-avec-une-condition","text":"","title":"4. Boucle avec une condition"},{"location":"python/boucles_bornees_questions/#question-41","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = - 1 for i in range ( len ( nombres )): if nombres [ i ] == cible : reponse = i Propositions de r\u00e9ponses -1 1 2 6 Solution -1 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres[i] == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc affect\u00e9e deux fois. En fin de boucle, la valeur de la variable est celle de la derni\u00e8re affectation, donc l'indice de la derni\u00e8re occurrence de 34 dans nombres .","title":"Question 4.1"},{"location":"python/boucles_bornees_questions/#question-42","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = 0 for nombre in nombres : if nombre == cible : reponse = reponse + 1 Propositions de r\u00e9ponses 0 1 2 6 Solution 0 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc incr\u00e9ment\u00e9e deux fois. En fin de boucle, la valeur de la variable initialis\u00e9e \u00e0 0 est donc 2 .","title":"Question 4.2"},{"location":"python/boucles_bornees_questions/#5-traces-en-boucle","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"5. Trac\u00e9s en boucle"},{"location":"python/boucles_bornees_questions/#question-51","text":"Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 60 ) Boucle B : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 60 ) Boucle C : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 120 ) Boucle D : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 6 c\u00f4t\u00e9s et range(6) g\u00e9n\u00e8rera les entiers de 0 \u00e0 5, soit 6 entiers. Les angles \"internes\" de la figure sont de 120\u00b0, la tortue doit donc pivoter de 180 - 120 = 60\u00b0 entre 2 trac\u00e9s.","title":"Question 5.1"},{"location":"python/boucles_bornees_questions/#question-52","text":"Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Le programme commence par les instructions suivantes : t = Turtle () # d\u00e9placement sans trac\u00e9 t . penup () t . setposition ( 75 , 150 ) t . pendown () Puis se termine par l'une des boucles suivantes : Boucle A : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 72 ) Boucle B : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 144 ) Boucle C : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 36 ) Boucle D : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 72 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 5 c\u00f4t\u00e9s et range(5) g\u00e9n\u00e8rera les entiers de 0 \u00e0 4, soit 5 entiers. Les angles \"internes\" des pointes de l'\u00e9toile sont de 36\u00b0, la tortue doit donc pivoter de 180 - 36 = 144\u00b0 entre 2 trac\u00e9s.","title":"Question 5.2"},{"location":"python/boucles_non_bornees/","text":"Boucles non born\u00e9es L'instruction while La boucle non born\u00e9e (ou boucle while ) permet de r\u00e9p\u00e9ter un bloc d'instructions tant qu'une expression (bool\u00e9enne) est vraie. La syntaxe de la boucle while est : while expression : bloc d_instructions \u00e0 r\u00e9p\u00e9ter o\u00f9 expression a pour valeur True ou False . Le bloc d'instructions est \u00e0 indenter. On utilise g\u00e9n\u00e9ralement cette boucle lorsqu'on ne connait pas le nombre d'it\u00e9rations au pr\u00e9alable. Exemple : La boucle suivante permet d'afficher la plus petite puissance de 2 sup\u00e9rieure \u00e0 nombre . nombre = 999 valeur = 1 while valeur < nombre : valeur = valeur * 2 print ( valeur ) 1024 Boucle infinie Les boucles while pr\u00e9sentent un risque de boucle infinie. Pour que la boucle prenne fin, il faut s'assurer que l'expression qui conditionne l'ex\u00e9cution du corps de la boucle prendra la valeur False , \u00e9ventuellement apr\u00e8s de tr\u00e8s nombreuses \u00e9tapes. Il faut donc s\u2019assurer que la valeur de cette expression est bien modifi\u00e9e par les instructions du corps de la boucle (ou par un \u00e9v\u00e9nement). Exemple : La boucle suivante ne se termine jamais : la variable valeur n'est jamais modifi\u00e9e dans le corps de la boucle. Seule une action de l\u2019utilisateur peut interrompre l'ex\u00e9cution du programme. compteur = 0 valeur = 0 while valeur == 0 : compteur = compteur + 1 print ( compteur ) \u00c0 l'inverse, si l'expression qui conditionne l'ex\u00e9cution du corps de la boucle a pour valeur False d\u00e8s le d\u00e9part, le corps de la boucle n\u2019est jamais ex\u00e9cut\u00e9.","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees/#boucles-non-bornees","text":"","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees/#linstruction-while","text":"La boucle non born\u00e9e (ou boucle while ) permet de r\u00e9p\u00e9ter un bloc d'instructions tant qu'une expression (bool\u00e9enne) est vraie. La syntaxe de la boucle while est : while expression : bloc d_instructions \u00e0 r\u00e9p\u00e9ter o\u00f9 expression a pour valeur True ou False . Le bloc d'instructions est \u00e0 indenter. On utilise g\u00e9n\u00e9ralement cette boucle lorsqu'on ne connait pas le nombre d'it\u00e9rations au pr\u00e9alable. Exemple : La boucle suivante permet d'afficher la plus petite puissance de 2 sup\u00e9rieure \u00e0 nombre . nombre = 999 valeur = 1 while valeur < nombre : valeur = valeur * 2 print ( valeur ) 1024","title":"L'instruction while"},{"location":"python/boucles_non_bornees/#boucle-infinie","text":"Les boucles while pr\u00e9sentent un risque de boucle infinie. Pour que la boucle prenne fin, il faut s'assurer que l'expression qui conditionne l'ex\u00e9cution du corps de la boucle prendra la valeur False , \u00e9ventuellement apr\u00e8s de tr\u00e8s nombreuses \u00e9tapes. Il faut donc s\u2019assurer que la valeur de cette expression est bien modifi\u00e9e par les instructions du corps de la boucle (ou par un \u00e9v\u00e9nement). Exemple : La boucle suivante ne se termine jamais : la variable valeur n'est jamais modifi\u00e9e dans le corps de la boucle. Seule une action de l\u2019utilisateur peut interrompre l'ex\u00e9cution du programme. compteur = 0 valeur = 0 while valeur == 0 : compteur = compteur + 1 print ( compteur ) \u00c0 l'inverse, si l'expression qui conditionne l'ex\u00e9cution du corps de la boucle a pour valeur False d\u00e8s le d\u00e9part, le corps de la boucle n\u2019est jamais ex\u00e9cut\u00e9.","title":"Boucle infinie"},{"location":"python/boucles_non_bornees_exercices/","text":"Exercices : boucles non born\u00e9es 1. Al\u00e9atoire Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint . Exercice 1.1 On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce qu'on obtienne un double (deux 1, deux 2, etc.). Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir le premier double. (Un premier double au 3e lancer doit faire afficher la valeur 3). Exercice 1.2 On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce que la somme des deux d\u00e9s soit \u00e9gale \u00e0 7. Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir une somme des deux d\u00e9s \u00e9gale \u00e0 7. 2. Accumulation Exercice 2.1 On dispose d'une feuille de papier d'\u00e9paisseur 0,1 mm. En supposant qu'on peut plier en 2 cette feuille autant de fois qu'on le souhaite, combien de fois doit-on la plier en deux au minimum pour que l'\u00e9paisseur d\u00e9passe la hauteur de la tour Eiffel (324 m) ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me. Exercice 2.2 Un capital de 1000 euros est d\u00e9pos\u00e9 sur un compte \u00e0 int\u00e9r\u00eats compos\u00e9s \u00e0 4 % : chaque ann\u00e9e le montant disponible sur le compte est augment\u00e9 de 4 %. Si l'on n'effectue ni d\u00e9p\u00f4t ni retrait, combien d'ann\u00e9es faut-il pour que le montant disponible atteigne (ou d\u00e9passe) 2000 euros ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me. 3. Calculs en boucle Exercice 3.1 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? Comment d\u00e9crire ce que r\u00e9alise ce programme ? resultat = 1 while resultat < 1000 : resultat = resultat * 2 Exercice 3.2 \u00c9crire un programme qui permet de d\u00e9terminer la plus petite puissance de 5 sup\u00e9rieure \u00e0 1000. Le programme ne devra pas utiliser l'op\u00e9rateur python ** . 4. Trac\u00e9s en boucle Exercice 4.1 Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur - 2 Exercice 4.2 Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur / 2","title":"Exercices"},{"location":"python/boucles_non_bornees_exercices/#exercices-boucles-non-bornees","text":"","title":"Exercices : boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_exercices/#1-aleatoire","text":"Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint .","title":"1. Al\u00e9atoire"},{"location":"python/boucles_non_bornees_exercices/#exercice-11","text":"On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce qu'on obtienne un double (deux 1, deux 2, etc.). Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir le premier double. (Un premier double au 3e lancer doit faire afficher la valeur 3).","title":"Exercice 1.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-12","text":"On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce que la somme des deux d\u00e9s soit \u00e9gale \u00e0 7. Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir une somme des deux d\u00e9s \u00e9gale \u00e0 7.","title":"Exercice 1.2"},{"location":"python/boucles_non_bornees_exercices/#2-accumulation","text":"","title":"2. Accumulation"},{"location":"python/boucles_non_bornees_exercices/#exercice-21","text":"On dispose d'une feuille de papier d'\u00e9paisseur 0,1 mm. En supposant qu'on peut plier en 2 cette feuille autant de fois qu'on le souhaite, combien de fois doit-on la plier en deux au minimum pour que l'\u00e9paisseur d\u00e9passe la hauteur de la tour Eiffel (324 m) ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me.","title":"Exercice 2.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-22","text":"Un capital de 1000 euros est d\u00e9pos\u00e9 sur un compte \u00e0 int\u00e9r\u00eats compos\u00e9s \u00e0 4 % : chaque ann\u00e9e le montant disponible sur le compte est augment\u00e9 de 4 %. Si l'on n'effectue ni d\u00e9p\u00f4t ni retrait, combien d'ann\u00e9es faut-il pour que le montant disponible atteigne (ou d\u00e9passe) 2000 euros ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me.","title":"Exercice 2.2"},{"location":"python/boucles_non_bornees_exercices/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_non_bornees_exercices/#exercice-31","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? Comment d\u00e9crire ce que r\u00e9alise ce programme ? resultat = 1 while resultat < 1000 : resultat = resultat * 2","title":"Exercice 3.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-32","text":"\u00c9crire un programme qui permet de d\u00e9terminer la plus petite puissance de 5 sup\u00e9rieure \u00e0 1000. Le programme ne devra pas utiliser l'op\u00e9rateur python ** .","title":"Exercice 3.2"},{"location":"python/boucles_non_bornees_exercices/#4-traces-en-boucle","text":"","title":"4. Trac\u00e9s en boucle"},{"location":"python/boucles_non_bornees_exercices/#exercice-41","text":"Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur - 2","title":"Exercice 4.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-42","text":"Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur / 2","title":"Exercice 4.2"},{"location":"python/boucles_non_bornees_questions/","text":"Questions : boucles non born\u00e9es 1. Al\u00e9atoire Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint . Question 1.1 Question On simule le tirage al\u00e9atoire d'un d\u00e9, jusqu'\u00e0 ce qu'on obtienne un 6. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires ? (un premier 6 au 3e lancer doit faire afficher la valeur 3). Programme A : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme B : from random import randint de = randint ( 1 , 6 ) compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme C : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de == 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur - 1 ) Programme D : from random import randint de = 0 compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur + 1 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le premier lancer peut donner lieu \u00e0 un 6 : le compteur doit \u00eatre initialis\u00e9 \u00e0 1 d\u00e8s qu'un lancer est simul\u00e9. Ensuite il faut incr\u00e9menter 1 le compteur \u00e0 chaque fois qu'un lancer est simul\u00e9. De cette fa\u00e7on, compteur contient exactement le nombre de lancers jusqu'au premier 6. Question 1.2 Question Une grenouille monte l'escalier de 17 marches qui m\u00e8ne \u00e0 la terrasse. A chacun de ses bonds, elle grimpe al\u00e9atoirement d'une ou de deux marches. On simule son trajet \u00e0 l'aide d'un programme. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de bonds qui ont \u00e9t\u00e9 n\u00e9cessaires pour atteindre la terrasse ? Programme A : from random import randint marche = 0 compteur = 1 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme B : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme C : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + bond marche = marche + bond print ( compteur ) Programme D : from random import randint marche = 0 compteur = 0 while marche != 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le programme A initialise la variable compteur \u00e0 1 alors que marche est initialis\u00e9 \u00e0 0. Le programme C n'incr\u00e9mente 1 pas correctement compteur : chaque bond ne compte que pour 1. Le programme D teste si on atteint exactement la 17e marche, or notre simulation pourrait induire un bond de 2 marches \u00e0 partir de la 16e. La variable marche pourrait ne jamais valoir 17 et le programme ne s'arr\u00eaterait pas. Seul le programme B convient. 2. Accumulation Question 2.1 Question On cherche \u00e0 d\u00e9terminer le plus petit entier n n tel que la somme 1 + 2 + 3 + \\cdots +n 1 + 2 + 3 + \\cdots +n soit sup\u00e9rieure \u00e0 1000. Parmi les 4 programmes suivants, lequel permet d'afficher la valeur de n n cherch\u00e9e ? Programme A : somme = 0 n = 0 while somme > 1000 : n = n + 1 somme = somme + n print ( n ) Programme B : somme = 0 n = 0 while somme >= 1000 : somme = somme + n n = n + 1 print ( n ) Programme C : somme = 0 n = 0 while somme < 1000 : n = n + 1 somme = somme + n print ( n ) Programme D : somme = 0 n = 0 while somme < 1000 : somme = somme + n n = n + 1 print ( n ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Les corps de boucles des programmes A et B ne sont jamais ex\u00e9cut\u00e9s car les expressions somme > 1000 et somme >= 1000 sont \u00e9valu\u00e9es \u00e0 False puisque somme vaut 0 lors de l'\u00e9valuation. La seule diff\u00e9rence entre les programmes C et D est l'ordre des instructions somme = somme + n et n = n + 1 . Dans le programme D, n est incr\u00e9ment\u00e9 1 apr\u00e8s avoir \u00e9t\u00e9 ajout\u00e9 \u00e0 somme : lorsque la valeur de somme sera sup\u00e9rieure ou \u00e9gale \u00e0 1000, mettant fin \u00e0 la boucle, la valeur de n ne sera pas la derni\u00e8re ajout\u00e9e \u00e0 somme . L'instruction print(n) n'affichera pas la bonne valeur. Dans le programme C, n est incr\u00e9ment\u00e9 avant d'\u00eatre ajout\u00e9 \u00e0 somme , et le probl\u00e8me pr\u00e9c\u00e9dent ne se pose plus. Question 2.2 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? i = 1 while i <= 100 : i = 2 * i print ( i ) Propositions de r\u00e9ponses 1 64 100 128 Solution 1 64 100 128 Arguments La variable i prend successivement les valeurs 1, 2, 4, 8, 16, 32, 64. Pour toutes ces valeurs, l'expression i <= 100 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution i prend la valeur 128, ce qui fait sortir de la boucle. 3. Entrer dans la boucle et en sortir Question 3.1 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 5 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 7 10 Aucune : la boucle ne termine pas Solution 5 7 10 Aucune : la boucle ne termine pas Arguments L'expression a < 5 est \u00e9valu\u00e9e \u00e0 False lorque a vaut 5 : le corps de la boucle n'est jamais ex\u00e9cut\u00e9. Question 3.2 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 9 11 Aucune : la boucle ne termine pas Solution 5 9 11 Aucune : la boucle ne termine pas Arguments La variable a prend successivement les valeurs 5, 7 et 9. Pour toutes ces valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution a prend la valeur 11, ce qui fait sortir de la boucle. Question 3.3 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a - 2 print ( a ) Propositions de r\u00e9ponses 5 3 1 Aucune : la boucle ne termine pas Solution 5 3 1 Aucune : la boucle ne termine pas Arguments La variable a prend les valeurs 5, 3 ,1, -1, -3, etc. Pour toutes les valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Les valeurs de a sont d\u00e9croissantes, et aucune valeur prise par a ne permettra de sortir de la boucle. incr\u00e9menter : augmenter d'une unit\u00e9 \u21a9 \u21a9 \u21a9","title":"Questions"},{"location":"python/boucles_non_bornees_questions/#questions-boucles-non-bornees","text":"","title":"Questions : boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_questions/#1-aleatoire","text":"Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint .","title":"1. Al\u00e9atoire"},{"location":"python/boucles_non_bornees_questions/#question-11","text":"Question On simule le tirage al\u00e9atoire d'un d\u00e9, jusqu'\u00e0 ce qu'on obtienne un 6. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires ? (un premier 6 au 3e lancer doit faire afficher la valeur 3). Programme A : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme B : from random import randint de = randint ( 1 , 6 ) compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme C : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de == 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur - 1 ) Programme D : from random import randint de = 0 compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur + 1 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le premier lancer peut donner lieu \u00e0 un 6 : le compteur doit \u00eatre initialis\u00e9 \u00e0 1 d\u00e8s qu'un lancer est simul\u00e9. Ensuite il faut incr\u00e9menter 1 le compteur \u00e0 chaque fois qu'un lancer est simul\u00e9. De cette fa\u00e7on, compteur contient exactement le nombre de lancers jusqu'au premier 6.","title":"Question 1.1"},{"location":"python/boucles_non_bornees_questions/#question-12","text":"Question Une grenouille monte l'escalier de 17 marches qui m\u00e8ne \u00e0 la terrasse. A chacun de ses bonds, elle grimpe al\u00e9atoirement d'une ou de deux marches. On simule son trajet \u00e0 l'aide d'un programme. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de bonds qui ont \u00e9t\u00e9 n\u00e9cessaires pour atteindre la terrasse ? Programme A : from random import randint marche = 0 compteur = 1 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme B : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme C : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + bond marche = marche + bond print ( compteur ) Programme D : from random import randint marche = 0 compteur = 0 while marche != 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le programme A initialise la variable compteur \u00e0 1 alors que marche est initialis\u00e9 \u00e0 0. Le programme C n'incr\u00e9mente 1 pas correctement compteur : chaque bond ne compte que pour 1. Le programme D teste si on atteint exactement la 17e marche, or notre simulation pourrait induire un bond de 2 marches \u00e0 partir de la 16e. La variable marche pourrait ne jamais valoir 17 et le programme ne s'arr\u00eaterait pas. Seul le programme B convient.","title":"Question 1.2"},{"location":"python/boucles_non_bornees_questions/#2-accumulation","text":"","title":"2. Accumulation"},{"location":"python/boucles_non_bornees_questions/#question-21","text":"Question On cherche \u00e0 d\u00e9terminer le plus petit entier n n tel que la somme 1 + 2 + 3 + \\cdots +n 1 + 2 + 3 + \\cdots +n soit sup\u00e9rieure \u00e0 1000. Parmi les 4 programmes suivants, lequel permet d'afficher la valeur de n n cherch\u00e9e ? Programme A : somme = 0 n = 0 while somme > 1000 : n = n + 1 somme = somme + n print ( n ) Programme B : somme = 0 n = 0 while somme >= 1000 : somme = somme + n n = n + 1 print ( n ) Programme C : somme = 0 n = 0 while somme < 1000 : n = n + 1 somme = somme + n print ( n ) Programme D : somme = 0 n = 0 while somme < 1000 : somme = somme + n n = n + 1 print ( n ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Les corps de boucles des programmes A et B ne sont jamais ex\u00e9cut\u00e9s car les expressions somme > 1000 et somme >= 1000 sont \u00e9valu\u00e9es \u00e0 False puisque somme vaut 0 lors de l'\u00e9valuation. La seule diff\u00e9rence entre les programmes C et D est l'ordre des instructions somme = somme + n et n = n + 1 . Dans le programme D, n est incr\u00e9ment\u00e9 1 apr\u00e8s avoir \u00e9t\u00e9 ajout\u00e9 \u00e0 somme : lorsque la valeur de somme sera sup\u00e9rieure ou \u00e9gale \u00e0 1000, mettant fin \u00e0 la boucle, la valeur de n ne sera pas la derni\u00e8re ajout\u00e9e \u00e0 somme . L'instruction print(n) n'affichera pas la bonne valeur. Dans le programme C, n est incr\u00e9ment\u00e9 avant d'\u00eatre ajout\u00e9 \u00e0 somme , et le probl\u00e8me pr\u00e9c\u00e9dent ne se pose plus.","title":"Question 2.1"},{"location":"python/boucles_non_bornees_questions/#question-22","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? i = 1 while i <= 100 : i = 2 * i print ( i ) Propositions de r\u00e9ponses 1 64 100 128 Solution 1 64 100 128 Arguments La variable i prend successivement les valeurs 1, 2, 4, 8, 16, 32, 64. Pour toutes ces valeurs, l'expression i <= 100 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution i prend la valeur 128, ce qui fait sortir de la boucle.","title":"Question 2.2"},{"location":"python/boucles_non_bornees_questions/#3-entrer-dans-la-boucle-et-en-sortir","text":"","title":"3. Entrer dans la boucle et en sortir"},{"location":"python/boucles_non_bornees_questions/#question-31","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 5 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 7 10 Aucune : la boucle ne termine pas Solution 5 7 10 Aucune : la boucle ne termine pas Arguments L'expression a < 5 est \u00e9valu\u00e9e \u00e0 False lorque a vaut 5 : le corps de la boucle n'est jamais ex\u00e9cut\u00e9.","title":"Question 3.1"},{"location":"python/boucles_non_bornees_questions/#question-32","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 9 11 Aucune : la boucle ne termine pas Solution 5 9 11 Aucune : la boucle ne termine pas Arguments La variable a prend successivement les valeurs 5, 7 et 9. Pour toutes ces valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution a prend la valeur 11, ce qui fait sortir de la boucle.","title":"Question 3.2"},{"location":"python/boucles_non_bornees_questions/#question-33","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a - 2 print ( a ) Propositions de r\u00e9ponses 5 3 1 Aucune : la boucle ne termine pas Solution 5 3 1 Aucune : la boucle ne termine pas Arguments La variable a prend les valeurs 5, 3 ,1, -1, -3, etc. Pour toutes les valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Les valeurs de a sont d\u00e9croissantes, et aucune valeur prise par a ne permettra de sortir de la boucle. incr\u00e9menter : augmenter d'une unit\u00e9 \u21a9 \u21a9 \u21a9","title":"Question 3.3"},{"location":"python/fonctions/","text":"Fonctions Les fonctions permettent de d\u00e9composer un programme en plusieurs \u00e9l\u00e9ments plus simples, plus lisibles et que l'on peut combiner. Une fonction associe un bloc d'instructions \u00e0 un nom. L'utilisation d'une fonction n\u00e9cessite deux \u00e9tapes : sa d\u00e9claration : on d\u00e9finit le nom de la fonction, ses param\u00e8tres et les instructions \u00e0 ex\u00e9cuter ; son appel : on ex\u00e9cute la fonction pour des valeurs explicites des param\u00e8tres. La d\u00e9claration d'une fonction La syntaxe de la d\u00e9claration d'une fonction est : def nom_de_la_fonction ( parametres ): bloc_instructions La d\u00e9finition d'une fonction commence par le mot-cl\u00e9 def . Les param\u00e8tres sont s\u00e9par\u00e9s par des virgules. Il peut ne pas y en avoir : dans ce cas on conserve tout de m\u00eame les parenth\u00e8ses. La premi\u00e8re ligne se termine par un double point. Le bloc bloc_instructions est indent\u00e9. On l'appelle le corps de la fonction. Il est fr\u00e9quent (mais pas obligatoire) que la fonction renvoie une valeur : on utilise pour cela le mot-cl\u00e9 return . En l'absence de return la fonction peut par exemple r\u00e9aliser des affichages, des trac\u00e9s ou \u00e9crire dans un fichier. Elle renverra alors implicitement None . Exemple 1 : une fonction \u00e0 valeur num\u00e9rique def f ( x , y ): return x ** 2 - y ** 2 Cette fonction s'appelle f , elle demande deux param\u00e8tres et elle renvoie la diff\u00e9rence des carr\u00e9s des param\u00e8tres. Exemple 2 : une fonction \u00e0 valeur bool\u00e9enne def validation ( mot ): return mot == 'secret123' Cette fonction s'appelle validation , elle demande un seul param\u00e8tre et elle renvoie True si le param\u00e8tre est \u00e9gal \u00e0 la chaine 'secret123' et False sinon. L'appel d'une fonction La syntaxe de l'appel d'une fonction est : nom_de_la_fonction ( valeurs_des_parametres ) Lors de la d\u00e9finition d'une fonction, le type des param\u00e8tres n'est pas pr\u00e9cis\u00e9. Lors de l'appel de la fonction, il est n\u00e9cessaire que les instructions ex\u00e9cut\u00e9es soient compatibles avec les types des valeurs des param\u00e8tres. Exemple 1 : fonction f 1er cas : f ( 5 , 3 ) 16 Les param\u00e8tres x et y de f prennent respectivement les valeurs 5 et 3. La fonction renvoie la valeur 5*5 - 3*3, soit 16. 2e cas : f ( 'a' , 'b' ) TypeError: unsupported operand type(s) for Pow: 'str' and 'int' Les param\u00e8tres x et y de f prennent respectivement pour valeurs les chaines de caract\u00e8res 'a' et 'b'. Comme l'op\u00e9rateur ** 2 n'a pas de signification pour une chaine de caract\u00e8res, l'appel de la fonction avec ces valeurs renvoie une erreur. Exemple 2 : fonction validation 1er cas : validation ( 'mot_de_passe123' ) False Le param\u00e8tre mot de la fonction validation prend la valeur 'mot_de_passe123'. La fonction renvoie la valeur de 'mot_de_passe123' == 'secret123', soit False . 2e cas : validation ( 123 ) False Le param\u00e8tre mot de la fonction validation prend la valeur 123, qui est un entier et non une chaine de caract\u00e8res. N\u00e9anmoins l'ex\u00e9cution de la fonction ne d\u00e9clenche pas d'erreur : elle renvoie la valeur de 123 == 'secret123', qui est False . Fonctions anonymes On peut construire une fonction dont le corps est limit\u00e9 \u00e0 une expression \u00e0 l'aide d'une lambda-expression . On \u00e9crit le mot-cl\u00e9 lambda suivi des param\u00e8tres de la fonction, d'un double-point : et de l'expression de la fonction. Exemple lambda x : x ** 2. # d\u00e9finition de la fonction carr\u00e9 <function __main__.<lambda>(x)> ( lambda x : x ** 2 )( 7 ) # image de 7 par la fonction carr\u00e9 49 Pour approfondir La documentation python pr\u00e9sente d'autres notions li\u00e9es aux fonctions : Valeur par d\u00e9faut des param\u00e8tres Les param\u00e8tres nomm\u00e9s Listes de param\u00e8tres arbitraires S\u00e9paration des listes de param\u00e8tres Cha\u00eenes de documentation Annotations de fonctions","title":"Fonctions"},{"location":"python/fonctions/#fonctions","text":"Les fonctions permettent de d\u00e9composer un programme en plusieurs \u00e9l\u00e9ments plus simples, plus lisibles et que l'on peut combiner. Une fonction associe un bloc d'instructions \u00e0 un nom. L'utilisation d'une fonction n\u00e9cessite deux \u00e9tapes : sa d\u00e9claration : on d\u00e9finit le nom de la fonction, ses param\u00e8tres et les instructions \u00e0 ex\u00e9cuter ; son appel : on ex\u00e9cute la fonction pour des valeurs explicites des param\u00e8tres.","title":"Fonctions"},{"location":"python/fonctions/#la-declaration-dune-fonction","text":"La syntaxe de la d\u00e9claration d'une fonction est : def nom_de_la_fonction ( parametres ): bloc_instructions La d\u00e9finition d'une fonction commence par le mot-cl\u00e9 def . Les param\u00e8tres sont s\u00e9par\u00e9s par des virgules. Il peut ne pas y en avoir : dans ce cas on conserve tout de m\u00eame les parenth\u00e8ses. La premi\u00e8re ligne se termine par un double point. Le bloc bloc_instructions est indent\u00e9. On l'appelle le corps de la fonction. Il est fr\u00e9quent (mais pas obligatoire) que la fonction renvoie une valeur : on utilise pour cela le mot-cl\u00e9 return . En l'absence de return la fonction peut par exemple r\u00e9aliser des affichages, des trac\u00e9s ou \u00e9crire dans un fichier. Elle renverra alors implicitement None . Exemple 1 : une fonction \u00e0 valeur num\u00e9rique def f ( x , y ): return x ** 2 - y ** 2 Cette fonction s'appelle f , elle demande deux param\u00e8tres et elle renvoie la diff\u00e9rence des carr\u00e9s des param\u00e8tres. Exemple 2 : une fonction \u00e0 valeur bool\u00e9enne def validation ( mot ): return mot == 'secret123' Cette fonction s'appelle validation , elle demande un seul param\u00e8tre et elle renvoie True si le param\u00e8tre est \u00e9gal \u00e0 la chaine 'secret123' et False sinon.","title":"La d\u00e9claration d'une fonction"},{"location":"python/fonctions/#lappel-dune-fonction","text":"La syntaxe de l'appel d'une fonction est : nom_de_la_fonction ( valeurs_des_parametres ) Lors de la d\u00e9finition d'une fonction, le type des param\u00e8tres n'est pas pr\u00e9cis\u00e9. Lors de l'appel de la fonction, il est n\u00e9cessaire que les instructions ex\u00e9cut\u00e9es soient compatibles avec les types des valeurs des param\u00e8tres. Exemple 1 : fonction f 1er cas : f ( 5 , 3 ) 16 Les param\u00e8tres x et y de f prennent respectivement les valeurs 5 et 3. La fonction renvoie la valeur 5*5 - 3*3, soit 16. 2e cas : f ( 'a' , 'b' ) TypeError: unsupported operand type(s) for Pow: 'str' and 'int' Les param\u00e8tres x et y de f prennent respectivement pour valeurs les chaines de caract\u00e8res 'a' et 'b'. Comme l'op\u00e9rateur ** 2 n'a pas de signification pour une chaine de caract\u00e8res, l'appel de la fonction avec ces valeurs renvoie une erreur. Exemple 2 : fonction validation 1er cas : validation ( 'mot_de_passe123' ) False Le param\u00e8tre mot de la fonction validation prend la valeur 'mot_de_passe123'. La fonction renvoie la valeur de 'mot_de_passe123' == 'secret123', soit False . 2e cas : validation ( 123 ) False Le param\u00e8tre mot de la fonction validation prend la valeur 123, qui est un entier et non une chaine de caract\u00e8res. N\u00e9anmoins l'ex\u00e9cution de la fonction ne d\u00e9clenche pas d'erreur : elle renvoie la valeur de 123 == 'secret123', qui est False .","title":"L'appel d'une fonction"},{"location":"python/fonctions/#fonctions-anonymes","text":"On peut construire une fonction dont le corps est limit\u00e9 \u00e0 une expression \u00e0 l'aide d'une lambda-expression . On \u00e9crit le mot-cl\u00e9 lambda suivi des param\u00e8tres de la fonction, d'un double-point : et de l'expression de la fonction. Exemple lambda x : x ** 2. # d\u00e9finition de la fonction carr\u00e9 <function __main__.<lambda>(x)> ( lambda x : x ** 2 )( 7 ) # image de 7 par la fonction carr\u00e9 49","title":"Fonctions anonymes"},{"location":"python/fonctions/#pour-approfondir","text":"La documentation python pr\u00e9sente d'autres notions li\u00e9es aux fonctions : Valeur par d\u00e9faut des param\u00e8tres Les param\u00e8tres nomm\u00e9s Listes de param\u00e8tres arbitraires S\u00e9paration des listes de param\u00e8tres Cha\u00eenes de documentation Annotations de fonctions","title":"Pour approfondir"},{"location":"python/fonctions_questions/","text":"Questions : fonctions 1. Fonctions et math\u00e9matiques Question 1.1 Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer le maximum des 2 param\u00e8tres ? Fonction A : def maximum ( a , b ): if a > b : resultat = a else : resultat = b return resultat Fonction B : def maximum ( a , b ): if a >= b : resultat = a else : resultat = b return resultat Fonction C : def maximum ( a , b ): if a > b : resultat = a if a < b : resultat = b return resultat Fonction D : def maximum ( a , b ): return a if a > b else b Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, toutes conviennent sauf la C : lorsque les 2 param\u00e8tres sont \u00e9gaux la C ne renvoie rien. La syntaxe de la D est particuli\u00e8re, mais usuelle en Python. Question 1.2 Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer la liste des valeurs de la table de multiplication d'un entier (c'est \u00e0 dire les produits de cet entier par les entiers de 1 \u00e0 10) ? Fonction A : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table . append ( n * i ) return table Fonction B : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + n * i return table_multiplication Fonction C : def table_multiplication ( n ): table = [] for i in range ( 10 ): table . append ( n * i ) return table Fonction D : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + [ n * i ] return table Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La proposition B essaie d'utiliser le symbole + entre une liste et un entier, ce qui provoque une erreur. Par ailleurs elle renvoie la fonction plut\u00f4t que la liste, ce qui ne r\u00e9pond pas \u00e0 la question pos\u00e9e. La fonction C n'utilise pas les bons entiers : range(10) engendre les entiers de 0 \u00e0 9, et non de 1 \u00e0 10. Les fonctions A et D sont correctes. 2. Avec le symbole + Question 2.1 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( 5 , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des nombres, le symbole + est un op\u00e9rateur d'addition. Question 2.2 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , '6' )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des chaines de caract\u00e8res, le symbole + est un op\u00e9rateur de concat\u00e9nation. L'affichage produit est la chaine de caract\u00e8res '56' et non l'entier 56. Question 2.3 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont un entier pour l'un et une chaine de caract\u00e8res pour l'autre, le symbole + n'a pas de signification. L'affichage produit est le message d'erreur : TypeError: cannot concatenate 'str' and 'int' objects 3. Trac\u00e9s en boucle : des fonctions sans return Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 3.1 Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def carre ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 4 ) : carre ( t ) t . right ( 120 ) Programme B : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 30 ) Programme C : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 120 ) Programme D : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( tortue ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La fonction carre prend en param\u00e8tre une tortue. Cette fonction doit faire tracer 4 c\u00f4t\u00e9s ( range(4) ) et les angles d'un carr\u00e9 font 90\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu. Question 3.2 Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def hexagone ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( t ) t . left ( 60 ) Programme B : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 60 ) Programme C : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( tortue ) t . left ( 120 ) Programme D : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ). La fonction hexagone prend en param\u00e8tre une tortue et lui fait tracer 6 c\u00f4t\u00e9s ( range(6) ). Les angles internes de l'hexagone font 120\u00b0 donc la tortue doit pivoter de 180 - 120 = 60\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Questions"},{"location":"python/fonctions_questions/#questions-fonctions","text":"","title":"Questions : fonctions"},{"location":"python/fonctions_questions/#1-fonctions-et-mathematiques","text":"","title":"1. Fonctions et math\u00e9matiques"},{"location":"python/fonctions_questions/#question-11","text":"Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer le maximum des 2 param\u00e8tres ? Fonction A : def maximum ( a , b ): if a > b : resultat = a else : resultat = b return resultat Fonction B : def maximum ( a , b ): if a >= b : resultat = a else : resultat = b return resultat Fonction C : def maximum ( a , b ): if a > b : resultat = a if a < b : resultat = b return resultat Fonction D : def maximum ( a , b ): return a if a > b else b Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, toutes conviennent sauf la C : lorsque les 2 param\u00e8tres sont \u00e9gaux la C ne renvoie rien. La syntaxe de la D est particuli\u00e8re, mais usuelle en Python.","title":"Question 1.1"},{"location":"python/fonctions_questions/#question-12","text":"Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer la liste des valeurs de la table de multiplication d'un entier (c'est \u00e0 dire les produits de cet entier par les entiers de 1 \u00e0 10) ? Fonction A : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table . append ( n * i ) return table Fonction B : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + n * i return table_multiplication Fonction C : def table_multiplication ( n ): table = [] for i in range ( 10 ): table . append ( n * i ) return table Fonction D : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + [ n * i ] return table Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La proposition B essaie d'utiliser le symbole + entre une liste et un entier, ce qui provoque une erreur. Par ailleurs elle renvoie la fonction plut\u00f4t que la liste, ce qui ne r\u00e9pond pas \u00e0 la question pos\u00e9e. La fonction C n'utilise pas les bons entiers : range(10) engendre les entiers de 0 \u00e0 9, et non de 1 \u00e0 10. Les fonctions A et D sont correctes.","title":"Question 1.2"},{"location":"python/fonctions_questions/#2-avec-le-symbole","text":"","title":"2. Avec le symbole +"},{"location":"python/fonctions_questions/#question-21","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( 5 , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des nombres, le symbole + est un op\u00e9rateur d'addition.","title":"Question 2.1"},{"location":"python/fonctions_questions/#question-22","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , '6' )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des chaines de caract\u00e8res, le symbole + est un op\u00e9rateur de concat\u00e9nation. L'affichage produit est la chaine de caract\u00e8res '56' et non l'entier 56.","title":"Question 2.2"},{"location":"python/fonctions_questions/#question-23","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont un entier pour l'un et une chaine de caract\u00e8res pour l'autre, le symbole + n'a pas de signification. L'affichage produit est le message d'erreur : TypeError: cannot concatenate 'str' and 'int' objects","title":"Question 2.3"},{"location":"python/fonctions_questions/#3-traces-en-boucle-des-fonctions-sans-return","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"3. Trac\u00e9s en boucle : des fonctions sans return"},{"location":"python/fonctions_questions/#question-31","text":"Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def carre ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 4 ) : carre ( t ) t . right ( 120 ) Programme B : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 30 ) Programme C : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 120 ) Programme D : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( tortue ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La fonction carre prend en param\u00e8tre une tortue. Cette fonction doit faire tracer 4 c\u00f4t\u00e9s ( range(4) ) et les angles d'un carr\u00e9 font 90\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.1"},{"location":"python/fonctions_questions/#question-32","text":"Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def hexagone ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( t ) t . left ( 60 ) Programme B : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 60 ) Programme C : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( tortue ) t . left ( 120 ) Programme D : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ). La fonction hexagone prend en param\u00e8tre une tortue et lui fait tracer 6 c\u00f4t\u00e9s ( range(6) ). Les angles internes de l'hexagone font 120\u00b0 donc la tortue doit pivoter de 180 - 120 = 60\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.2"},{"location":"python/instructions_conditionnelles/","text":"Instructions conditionnelles Les instructions conditionnelles permettent de s\u00e9lectionner le bloc d'instructions \u00e0 ex\u00e9cuter selon la valeur d'une expression bool\u00e9enne. L'instruction if La syntaxe de l'instruction if est : if expression : bloc_instructions_1 bloc_instructions_2 o\u00f9 expression a pour valeur True ou False . Il s'agit de l'expression de la clause if . Si expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, sinon, il est ignor\u00e9. Dans tous les cas, si le bloc bloc_instructions_2 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : l'expression de la clause if a pour valeur True nb = 17 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 34 est un nombre pair nb % 2 != 0 est une expression qui vaut True lorsque nb vaut 17. L'instruction nb = nb * 2 est ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 34. Exemple : l'expression de la clause if a pour valeur False nb = 18 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 18 est un nombre pair nb % 2 != 0 est une expression qui vaut False lorsque nb vaut 18. L'instruction nb = nb * 2 est ignor\u00e9e et la valeur de nb n'est pas modifi\u00e9e. L'instruction if \u2026 else La syntaxe de l'instruction if \u2026 else est : if expression : bloc_instructions_1 else : bloc_instructions_2 bloc_instructions_3 o\u00f9 expression a pour valeur True ou False . Lorsque expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_2 est ignor\u00e9. Lorsque expression a pour valeur False , le bloc bloc_instructions_1 est ignor\u00e9, et le bloc bloc_instructions_2 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , mais jamais les 2. Dans tous les cas, si le bloc bloc_instructions_3 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 5 if nb % 2 == 0 : print ( nb , \"est un nombre pair\" ) else : print ( nb , \"est un nombre impair\" ) 5 est un nombre impair nb % 2 == 0 est une expression qui vaut False lorsque nb vaut 5. L'instruction print(nb, \"est un nombre pair\") est ignor\u00e9e mais print(nb, \"est un nombre impair\") est ex\u00e9cut\u00e9e. L'instruction if \u2026 elif \u2026 else Lorsque l'on souhaite disposer de plus d'une alternative, l'instruction if \u2026 elif \u2026 else permet de conditionner l'ex\u00e9cution de plusieurs blocs d'instructions par la valeur de plusieurs expressions bool\u00e9ennes. elif est \u00e9quivalent \u00e0 else if . On peut ajouter autant de clauses elif que n\u00e9cessaires. La syntaxe de l'instruction if \u2026 elif \u2026 else est : if expression1 : bloc_instructions_1 elif expression2 : bloc_instructions_2 else : bloc_instructions_3 bloc_instructions_4 o\u00f9 expression1 et expression2 ont pour valeur True ou False . Lorsque expression1 a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et les blocs bloc_instructions_2 et bloc_instructions_3 sont ignor\u00e9s. Lorsque expression1 a pour valeur False : le bloc bloc_instructions_1 est ignor\u00e9, si expression2 a pour valeur True , le bloc bloc_instructions_2 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_3 est ignor\u00e9 ; si expression2 a pour valeur False , le bloc bloc_instructions_2 est ignor\u00e9, et le bloc bloc_instructions_3 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , soit le bloc bloc_instructions_3 , mais toujours un seul parmi les 3. Dans tous les cas, si le bloc bloc_instructions_4 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 15 if nb <= 10 : print ( nb , \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\" ) elif nb >= 20 : print ( nb , \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\" ) else : print ( nb , \"est strictement compris entre 10 et 20\" ) 15 est strictement compris entre 10 et 20 nb <= 10 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\") est ignor\u00e9e. nb >= 20 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\") est aussi ignor\u00e9e. L'instruction print(nb, \"est strictement compris entre 10 et 20\") est donc ex\u00e9cut\u00e9e.","title":"Instructions conditionnelles"},{"location":"python/instructions_conditionnelles/#instructions-conditionnelles","text":"Les instructions conditionnelles permettent de s\u00e9lectionner le bloc d'instructions \u00e0 ex\u00e9cuter selon la valeur d'une expression bool\u00e9enne.","title":"Instructions conditionnelles"},{"location":"python/instructions_conditionnelles/#linstruction-if","text":"La syntaxe de l'instruction if est : if expression : bloc_instructions_1 bloc_instructions_2 o\u00f9 expression a pour valeur True ou False . Il s'agit de l'expression de la clause if . Si expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, sinon, il est ignor\u00e9. Dans tous les cas, si le bloc bloc_instructions_2 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : l'expression de la clause if a pour valeur True nb = 17 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 34 est un nombre pair nb % 2 != 0 est une expression qui vaut True lorsque nb vaut 17. L'instruction nb = nb * 2 est ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 34. Exemple : l'expression de la clause if a pour valeur False nb = 18 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 18 est un nombre pair nb % 2 != 0 est une expression qui vaut False lorsque nb vaut 18. L'instruction nb = nb * 2 est ignor\u00e9e et la valeur de nb n'est pas modifi\u00e9e.","title":"L'instruction if"},{"location":"python/instructions_conditionnelles/#linstruction-if-else","text":"La syntaxe de l'instruction if \u2026 else est : if expression : bloc_instructions_1 else : bloc_instructions_2 bloc_instructions_3 o\u00f9 expression a pour valeur True ou False . Lorsque expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_2 est ignor\u00e9. Lorsque expression a pour valeur False , le bloc bloc_instructions_1 est ignor\u00e9, et le bloc bloc_instructions_2 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , mais jamais les 2. Dans tous les cas, si le bloc bloc_instructions_3 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 5 if nb % 2 == 0 : print ( nb , \"est un nombre pair\" ) else : print ( nb , \"est un nombre impair\" ) 5 est un nombre impair nb % 2 == 0 est une expression qui vaut False lorsque nb vaut 5. L'instruction print(nb, \"est un nombre pair\") est ignor\u00e9e mais print(nb, \"est un nombre impair\") est ex\u00e9cut\u00e9e.","title":"L'instruction if \u2026 else"},{"location":"python/instructions_conditionnelles/#linstruction-if-elif-else","text":"Lorsque l'on souhaite disposer de plus d'une alternative, l'instruction if \u2026 elif \u2026 else permet de conditionner l'ex\u00e9cution de plusieurs blocs d'instructions par la valeur de plusieurs expressions bool\u00e9ennes. elif est \u00e9quivalent \u00e0 else if . On peut ajouter autant de clauses elif que n\u00e9cessaires. La syntaxe de l'instruction if \u2026 elif \u2026 else est : if expression1 : bloc_instructions_1 elif expression2 : bloc_instructions_2 else : bloc_instructions_3 bloc_instructions_4 o\u00f9 expression1 et expression2 ont pour valeur True ou False . Lorsque expression1 a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et les blocs bloc_instructions_2 et bloc_instructions_3 sont ignor\u00e9s. Lorsque expression1 a pour valeur False : le bloc bloc_instructions_1 est ignor\u00e9, si expression2 a pour valeur True , le bloc bloc_instructions_2 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_3 est ignor\u00e9 ; si expression2 a pour valeur False , le bloc bloc_instructions_2 est ignor\u00e9, et le bloc bloc_instructions_3 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , soit le bloc bloc_instructions_3 , mais toujours un seul parmi les 3. Dans tous les cas, si le bloc bloc_instructions_4 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 15 if nb <= 10 : print ( nb , \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\" ) elif nb >= 20 : print ( nb , \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\" ) else : print ( nb , \"est strictement compris entre 10 et 20\" ) 15 est strictement compris entre 10 et 20 nb <= 10 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\") est ignor\u00e9e. nb >= 20 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\") est aussi ignor\u00e9e. L'instruction print(nb, \"est strictement compris entre 10 et 20\") est donc ex\u00e9cut\u00e9e.","title":"L'instruction if \u2026 elif \u2026 else"},{"location":"python/instructions_conditionnelles_questions/","text":"Questions : instructions conditionnelles Question 1 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 else : nb = nb * 2 print ( nb ) Propositions de r\u00e9ponses 15 30 75 150 Solution 15 30 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30. Question 2 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 elif nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 30 45 75 150 Solution 30 45 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'expression de la clause elif , nb % 5 == 0 , a pour valeur True quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30. Question 3 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 12 if nb % 2 == 0 : nb = nb * 5 if nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 24 36 60 120 Solution 24 36 60 120 Arguments L'expression de la clause du premier if , nb % 2 == 0 , a pour valeur True quand nb vaut 12. L'instruction nb = nb * 5 est donc ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 60. L'expression de la clause du second if , nb % 5 == 0 , a pour valeur True quand nb vaut 60. L'instruction nb = nb * 2 , est donc aussi ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 120. Cet exemple montre qu'il faut attentivement distinguer les instructions if \u2026 elif des instructions if successives.","title":"Questions"},{"location":"python/instructions_conditionnelles_questions/#questions-instructions-conditionnelles","text":"","title":"Questions : instructions conditionnelles"},{"location":"python/instructions_conditionnelles_questions/#question-1","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 else : nb = nb * 2 print ( nb ) Propositions de r\u00e9ponses 15 30 75 150 Solution 15 30 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30.","title":"Question 1"},{"location":"python/instructions_conditionnelles_questions/#question-2","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 elif nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 30 45 75 150 Solution 30 45 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'expression de la clause elif , nb % 5 == 0 , a pour valeur True quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30.","title":"Question 2"},{"location":"python/instructions_conditionnelles_questions/#question-3","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 12 if nb % 2 == 0 : nb = nb * 5 if nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 24 36 60 120 Solution 24 36 60 120 Arguments L'expression de la clause du premier if , nb % 2 == 0 , a pour valeur True quand nb vaut 12. L'instruction nb = nb * 5 est donc ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 60. L'expression de la clause du second if , nb % 5 == 0 , a pour valeur True quand nb vaut 60. L'instruction nb = nb * 2 , est donc aussi ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 120. Cet exemple montre qu'il faut attentivement distinguer les instructions if \u2026 elif des instructions if successives.","title":"Question 3"},{"location":"python/operateurs/","text":"Op\u00e9rateurs Les op\u00e9rateurs sont des symboles ou des mots r\u00e9serv\u00e9s, utilis\u00e9s pour r\u00e9aliser des op\u00e9rations entre des op\u00e9randes . Un op\u00e9rande est une variable, un litt\u00e9ral ou bien une expression. Une expression est une suite valide d'op\u00e9rateurs et d'op\u00e9randes. Op\u00e9rateurs arithm\u00e9tiques Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs num\u00e9riques est envisag\u00e9 ici. + Addition L'expression a + b a pour valeur la somme des deux op\u00e9randes a et b . a = 10 b = 3 a + b 13 - Soustraction L'expression a - b a pour valeur la diff\u00e9rence des deux op\u00e9randes a et b . a = 10 b = 3 a - b 7 * Multiplication L'expression a * b a pour valeur le produit des deux op\u00e9randes a et b . a = 10 b = 3 a * b 30 / Division L'expression a / b a pour valeur le quotient d\u00e9cimal dans la division de a par b . a = 10 b = 3 a / b 3.3333333333333335 % Modulo L'expression a % b a pour valeur le reste dans la division enti\u00e8re de a par b . a = 10 b = 3 a % b 1 // Division enti\u00e8re L'expression a // b a pour valeur le quotient dans la division enti\u00e8re de a par b . a = 10 b = 3 a // b 3 ** Exposant L'expression a ** b a pour valeur a exposant b : a b . a = 10 b = 3 a ** b 1000 Op\u00e9rateurs de comparaison Les op\u00e9rateurs de comparaison (ou relationnels) sont utilis\u00e9s pour comparer les valeurs de deux op\u00e9randes. L'expression s'\u00e9crit sous la forme d'une relation (de comparaison) : elle vaut True si les valeurs des op\u00e9randes v\u00e9rifient la relation et False sinon. == signifie \"est \u00e9gal \u00e0 \". Exemple : 2 * 3 == 5 vaut False != signifie \"n'est pas \u00e9gal \u00e0 \". Exemple : 2 * 3 != 5 vaut True > signifie \"est sup\u00e9rieur \u00e0 \". Exemple : 2 * 3 > 5 vaut True >= signifie \"est sup\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 >= 5 vaut True < signifie \"est inf\u00e9rieur \u00e0 \". Exemple : 2 * 3 < 5 vaut False <= signifie \"est inf\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 < 5 vaut False Op\u00e9rateurs logiques Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs bool\u00e9ennes est envisag\u00e9 ici. and ET logique L'expression a and b vaut True si (et seulement si) les deux op\u00e9randes a et b valent True . Exemple : 2 * 3 > 5 and 2 + 3 == 5 vaut True or OU logique L'expression a or b vaut True si (et seulement si) au moins l'un des deux op\u00e9randes a et b vaut True . Exemple : 2 * 3 < 5 or 2 + 3 == 5 vaut True not NON logique (op\u00e9rateur unaire 1 ) L'expression not a vaut True si a vaut False ; elle vaut False sinon. Exemple : not (2 * 3 < 5) vaut True Op\u00e9rateurs binaires Les op\u00e9rateurs binaires (ou bit \u00e0 bit) appliquent des op\u00e9rateurs logiques sur les bits de l'\u00e9criture binaire des op\u00e9randes. & Et bit \u00e0 bit a & b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un ET logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a & b 160 # soit 1010 0000 en binaire | Ou bit \u00e0 bit a | b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a | b 250 # soit 1111 1010 en binaire ^ Ou exclusif bit \u00e0 bit (xor) a ^ b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU exclusif (XOR) entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a ^ b 90 # soit 0101 1010 en binaire ~ Inversion bit \u00e0 bit (op\u00e9rateur unaire 1 ) ~ a : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un NON sur les bits de l'\u00e9criture binaire de a . Exemple : a = 240 # soit 1111 0000 en binaire ~ a 15 # soit 0000 1111 en binaire >> D\u00e9calage bit \u00e0 bit droite a >> b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la droite. Exemple : a = 48 # soit 0011 0000 en binaire a >> 2 12 # soit 0000 1100 en binaire << D\u00e9calage bit \u00e0 bit gauche a << b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la gauche. Exemple : a = 48 # soit 0011 0000 en binaire a << 2 192 # soit 1100 0000 en binaire Op\u00e9rateurs d'affectation Les op\u00e9rateurs d\u2019affectation sont utilis\u00e9s pour attribuer une valeur \u00e0 une variable. La variable est l'op\u00e9rande de gauche. La valeur est l'op\u00e9rande de droite : il est \u00e9valu\u00e9 avant l'affectation. En dehors de l'affectation \u00e0 l'aide du symbole = , les autres op\u00e9rateurs, dits d'affectation augment\u00e9e, combinent une op\u00e9ration arithm\u00e9rique ou binaire et une affectation de valeur \u00e0 une variable, pr\u00e9alablement initialis\u00e9e. = Op\u00e9rateur d'affectation Exemples : x = 2 : affecte \u00e0 x la valeur 2 . x = 2*3 + 5 : affecte \u00e0 x la valeur 11 . x = y : affecte \u00e0 x la valeur de y (qui doit avoir \u00e9t\u00e9 initialis\u00e9e pr\u00e9alablement) += Exemple : x += 2 : augmente la valeur de x de 2 . \u00c9quivalent \u00e0 x = x + 2 -= Exemple : x -= 2 : diminue la valeur de x de 2 . \u00c9quivalent \u00e0 x = x - 2 *= Exemple : x *= 2 : multiplie la valeur de x par 2 . \u00c9quivalent \u00e0 x = x * 2 /= Exemple : x /= 2 : divise la valeur de x par 2 . \u00c9quivalent \u00e0 x = x / 2 %= Exemple : x %= 2 : remplace x par le reste de la division de la valeur de x par 2 . \u00c9quivalent \u00e0 x = x % 2 //= Exemple : x //= 2 : divise la valeur de x par 2 (quotient entier). \u00c9quivalent \u00e0 x = x // 2 **= Exemple : x **= 2 : \u00e9l\u00e8ve x \u00e0 la puissance 2 . \u00c9quivalent \u00e0 x = x ** 2 &= Exemple : x &= 2 \u00c9quivalent \u00e0 x = x & 2 |= Exemple : x |= 2 \u00c9quivalent \u00e0 x = x | 2 ^= Exemple : x ^= 2 \u00c9quivalent \u00e0 x = x ^ 2 >>= Exemple : x >>= 2 \u00c9quivalent \u00e0 x = x >> 2 <<= Exemple : x <<= 2 \u00c9quivalent \u00e0 x = x << 2 Op\u00e9rateurs sp\u00e9ciaux Le langage Python offre des types d'op\u00e9rateurs sp\u00e9ciaux, tels que l'op\u00e9rateur d'identit\u00e9 ou l'op\u00e9rateur d'appartenance. Op\u00e9rateur d'identit\u00e9 is et is not sont les op\u00e9rateurs d'identit\u00e9 en Python. Ils permettent de v\u00e9rifier si deux valeurs (ou variables) r\u00e9f\u00e9rencent (ou non) le m\u00eame emplacement m\u00e9moire. Deux variables de m\u00eame valeur ne sont pas n\u00e9cessairement identiques. is a is b vaut True si les op\u00e9randes a et b r\u00e9f\u00e9rencent le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = tableau1 tableau1 is tableau2 True is not a is not b vaut True si les op\u00e9randes a et b ne r\u00e9f\u00e9rencent pas le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = [ 1 , 2 , 3 ] tableau1 is not tableau2 True Op\u00e9rateur d'appartenance in et not in sont les op\u00e9rateurs d'appartenance en Python. Ils sont utilis\u00e9s pour v\u00e9rifier si une valeur est pr\u00e9sente (ou non) dans une s\u00e9quence (cha\u00eene, liste, tuple, set et dictionnaire). in a in b vaut True si l'op\u00e9rande a se trouve dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 2 a in tableau True not in a not in b vaut True si l'op\u00e9rande a ne se trouve pas dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 4 a not in tableau True Priorit\u00e9s des op\u00e9rateurs Liste des op\u00e9rateurs, de la priorit\u00e9 la plus haute \u00e0 la plus basse : ** * / // % + - < <= > >= == != = not and or op\u00e9rateur ne n\u00e9cessitant qu'un op\u00e9rande \u21a9 \u21a9","title":"Op\u00e9rateurs"},{"location":"python/operateurs/#operateurs","text":"Les op\u00e9rateurs sont des symboles ou des mots r\u00e9serv\u00e9s, utilis\u00e9s pour r\u00e9aliser des op\u00e9rations entre des op\u00e9randes . Un op\u00e9rande est une variable, un litt\u00e9ral ou bien une expression. Une expression est une suite valide d'op\u00e9rateurs et d'op\u00e9randes.","title":"Op\u00e9rateurs"},{"location":"python/operateurs/#operateurs-arithmetiques","text":"Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs num\u00e9riques est envisag\u00e9 ici. + Addition L'expression a + b a pour valeur la somme des deux op\u00e9randes a et b . a = 10 b = 3 a + b 13 - Soustraction L'expression a - b a pour valeur la diff\u00e9rence des deux op\u00e9randes a et b . a = 10 b = 3 a - b 7 * Multiplication L'expression a * b a pour valeur le produit des deux op\u00e9randes a et b . a = 10 b = 3 a * b 30 / Division L'expression a / b a pour valeur le quotient d\u00e9cimal dans la division de a par b . a = 10 b = 3 a / b 3.3333333333333335 % Modulo L'expression a % b a pour valeur le reste dans la division enti\u00e8re de a par b . a = 10 b = 3 a % b 1 // Division enti\u00e8re L'expression a // b a pour valeur le quotient dans la division enti\u00e8re de a par b . a = 10 b = 3 a // b 3 ** Exposant L'expression a ** b a pour valeur a exposant b : a b . a = 10 b = 3 a ** b 1000","title":"Op\u00e9rateurs arithm\u00e9tiques"},{"location":"python/operateurs/#operateurs-de-comparaison","text":"Les op\u00e9rateurs de comparaison (ou relationnels) sont utilis\u00e9s pour comparer les valeurs de deux op\u00e9randes. L'expression s'\u00e9crit sous la forme d'une relation (de comparaison) : elle vaut True si les valeurs des op\u00e9randes v\u00e9rifient la relation et False sinon. == signifie \"est \u00e9gal \u00e0 \". Exemple : 2 * 3 == 5 vaut False != signifie \"n'est pas \u00e9gal \u00e0 \". Exemple : 2 * 3 != 5 vaut True > signifie \"est sup\u00e9rieur \u00e0 \". Exemple : 2 * 3 > 5 vaut True >= signifie \"est sup\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 >= 5 vaut True < signifie \"est inf\u00e9rieur \u00e0 \". Exemple : 2 * 3 < 5 vaut False <= signifie \"est inf\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 < 5 vaut False","title":"Op\u00e9rateurs de comparaison"},{"location":"python/operateurs/#operateurs-logiques","text":"Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs bool\u00e9ennes est envisag\u00e9 ici. and ET logique L'expression a and b vaut True si (et seulement si) les deux op\u00e9randes a et b valent True . Exemple : 2 * 3 > 5 and 2 + 3 == 5 vaut True or OU logique L'expression a or b vaut True si (et seulement si) au moins l'un des deux op\u00e9randes a et b vaut True . Exemple : 2 * 3 < 5 or 2 + 3 == 5 vaut True not NON logique (op\u00e9rateur unaire 1 ) L'expression not a vaut True si a vaut False ; elle vaut False sinon. Exemple : not (2 * 3 < 5) vaut True","title":"Op\u00e9rateurs logiques"},{"location":"python/operateurs/#operateurs-binaires","text":"Les op\u00e9rateurs binaires (ou bit \u00e0 bit) appliquent des op\u00e9rateurs logiques sur les bits de l'\u00e9criture binaire des op\u00e9randes. & Et bit \u00e0 bit a & b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un ET logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a & b 160 # soit 1010 0000 en binaire | Ou bit \u00e0 bit a | b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a | b 250 # soit 1111 1010 en binaire ^ Ou exclusif bit \u00e0 bit (xor) a ^ b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU exclusif (XOR) entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a ^ b 90 # soit 0101 1010 en binaire ~ Inversion bit \u00e0 bit (op\u00e9rateur unaire 1 ) ~ a : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un NON sur les bits de l'\u00e9criture binaire de a . Exemple : a = 240 # soit 1111 0000 en binaire ~ a 15 # soit 0000 1111 en binaire >> D\u00e9calage bit \u00e0 bit droite a >> b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la droite. Exemple : a = 48 # soit 0011 0000 en binaire a >> 2 12 # soit 0000 1100 en binaire << D\u00e9calage bit \u00e0 bit gauche a << b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la gauche. Exemple : a = 48 # soit 0011 0000 en binaire a << 2 192 # soit 1100 0000 en binaire","title":"Op\u00e9rateurs binaires"},{"location":"python/operateurs/#operateurs-daffectation","text":"Les op\u00e9rateurs d\u2019affectation sont utilis\u00e9s pour attribuer une valeur \u00e0 une variable. La variable est l'op\u00e9rande de gauche. La valeur est l'op\u00e9rande de droite : il est \u00e9valu\u00e9 avant l'affectation. En dehors de l'affectation \u00e0 l'aide du symbole = , les autres op\u00e9rateurs, dits d'affectation augment\u00e9e, combinent une op\u00e9ration arithm\u00e9rique ou binaire et une affectation de valeur \u00e0 une variable, pr\u00e9alablement initialis\u00e9e. = Op\u00e9rateur d'affectation Exemples : x = 2 : affecte \u00e0 x la valeur 2 . x = 2*3 + 5 : affecte \u00e0 x la valeur 11 . x = y : affecte \u00e0 x la valeur de y (qui doit avoir \u00e9t\u00e9 initialis\u00e9e pr\u00e9alablement) += Exemple : x += 2 : augmente la valeur de x de 2 . \u00c9quivalent \u00e0 x = x + 2 -= Exemple : x -= 2 : diminue la valeur de x de 2 . \u00c9quivalent \u00e0 x = x - 2 *= Exemple : x *= 2 : multiplie la valeur de x par 2 . \u00c9quivalent \u00e0 x = x * 2 /= Exemple : x /= 2 : divise la valeur de x par 2 . \u00c9quivalent \u00e0 x = x / 2 %= Exemple : x %= 2 : remplace x par le reste de la division de la valeur de x par 2 . \u00c9quivalent \u00e0 x = x % 2 //= Exemple : x //= 2 : divise la valeur de x par 2 (quotient entier). \u00c9quivalent \u00e0 x = x // 2 **= Exemple : x **= 2 : \u00e9l\u00e8ve x \u00e0 la puissance 2 . \u00c9quivalent \u00e0 x = x ** 2 &= Exemple : x &= 2 \u00c9quivalent \u00e0 x = x & 2 |= Exemple : x |= 2 \u00c9quivalent \u00e0 x = x | 2 ^= Exemple : x ^= 2 \u00c9quivalent \u00e0 x = x ^ 2 >>= Exemple : x >>= 2 \u00c9quivalent \u00e0 x = x >> 2 <<= Exemple : x <<= 2 \u00c9quivalent \u00e0 x = x << 2","title":"Op\u00e9rateurs d'affectation"},{"location":"python/operateurs/#operateurs-speciaux","text":"Le langage Python offre des types d'op\u00e9rateurs sp\u00e9ciaux, tels que l'op\u00e9rateur d'identit\u00e9 ou l'op\u00e9rateur d'appartenance.","title":"Op\u00e9rateurs sp\u00e9ciaux"},{"location":"python/operateurs/#operateur-didentite","text":"is et is not sont les op\u00e9rateurs d'identit\u00e9 en Python. Ils permettent de v\u00e9rifier si deux valeurs (ou variables) r\u00e9f\u00e9rencent (ou non) le m\u00eame emplacement m\u00e9moire. Deux variables de m\u00eame valeur ne sont pas n\u00e9cessairement identiques. is a is b vaut True si les op\u00e9randes a et b r\u00e9f\u00e9rencent le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = tableau1 tableau1 is tableau2 True is not a is not b vaut True si les op\u00e9randes a et b ne r\u00e9f\u00e9rencent pas le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = [ 1 , 2 , 3 ] tableau1 is not tableau2 True","title":"Op\u00e9rateur d'identit\u00e9"},{"location":"python/operateurs/#operateur-dappartenance","text":"in et not in sont les op\u00e9rateurs d'appartenance en Python. Ils sont utilis\u00e9s pour v\u00e9rifier si une valeur est pr\u00e9sente (ou non) dans une s\u00e9quence (cha\u00eene, liste, tuple, set et dictionnaire). in a in b vaut True si l'op\u00e9rande a se trouve dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 2 a in tableau True not in a not in b vaut True si l'op\u00e9rande a ne se trouve pas dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 4 a not in tableau True","title":"Op\u00e9rateur d'appartenance"},{"location":"python/operateurs/#priorites-des-operateurs","text":"Liste des op\u00e9rateurs, de la priorit\u00e9 la plus haute \u00e0 la plus basse : ** * / // % + - < <= > >= == != = not and or op\u00e9rateur ne n\u00e9cessitant qu'un op\u00e9rande \u21a9 \u21a9","title":"Priorit\u00e9s des op\u00e9rateurs"},{"location":"python/pep8/","text":"Bonnes pratiques en programmation python \u00c9crire un texte dans une langue n\u00e9cessite le respect de r\u00e8gles typographiques concernant notamment l'usage des majuscules, des espaces, de la ponctuation, des paragraphes, etc. Il en est souvent de m\u00eame pour les langages , comme les langages de programmation. Des propositions d'am\u00e9liorations concernant le langage Python sont r\u00e9guli\u00e8rement publi\u00e9es : les Python Enhancement Proposal (PEP). L'une de ces propositions, la PEP 8 : Style Guide for Python Code , consiste en un nombre important de recommandations sur la syntaxe Python. Seules quelques-unes sont pr\u00e9sent\u00e9es ici. 1. Mise en page Longueur des lignes : une ligne doit contenir 79 caract\u00e8res au maximum. Indentation : les blocs d'instructions sont \u00e0 indenter de 4 espaces. 2. R\u00e8gles de nommage Les noms de variable, fonction ou classe ne doivent pas contenir d'accent. Les caract\u00e8res autoris\u00e9s sont les lettres, les chiffres et le tiret bas : _ Variables et fonctions Les noms de variables et de fonctions sont \u00e0 \u00e9crire avec des lettres minuscules et le tiret bas. Constantes Les noms des constantes sont \u00e0 \u00e9crire avec des lettres capitales et le tiret bas. Classes Les noms des classes sont \u00e0 \u00e9crire avec des lettres minuscules avec majuscules en d\u00e9but de mot. Exemples Variables compteur mon_tableau Fonctions jouer () racine_carree ( x ) Constantes CLE NB_POINTS Classes MaClasse MaSuperClasse Info Le style recommand\u00e9 pour nommer les variables et les fonctions en Python est appel\u00e9 snake_case . Le style recommand\u00e9 pour nommer les classes en Python est appel\u00e9 CamelCase . 3. Espaces Les espaces suivent la syntaxe anglo-saxonne et non fran\u00e7aise. Ainsi les caract\u00e8res ; , : et , s'\u00e9crivent avec un espace apr\u00e8s mais pas d'espace avant. Autour des op\u00e9rateurs Il est recommand\u00e9 de toujours entourer les op\u00e9rateurs suivants ( = , += , -= , *= , /= , == , != , >= , not , in , and , or , etc.) d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Les op\u00e9rateurs suivants ( + , - , * , / ) sont \u00e0 entourer en r\u00e8gle g\u00e9n\u00e9rale d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Lorsqu'une expression comporte des op\u00e9rations de diff\u00e9rentes priorit\u00e9s, on peut r\u00e9server les espaces \u00e0 l'op\u00e9rateur de plus faible priorit\u00e9. Exemples compteur = 0 compteur = compteur + 1 compteur += 1 x = 2 * x + 1 Autour des parenth\u00e8ses Il n'y a pas d'espace : apr\u00e8s les parenth\u00e8ses, accolades et crochets ouvrants ; avant les parenth\u00e8ses, accolades et crochets fermants ; juste avant la parenth\u00e8se ouvrante d'une fonction ou le crochet ouvrant d'une liste ou d'un dictionnaire. Exemples ma_fonction ( x ) mon_dictionnaire = { \"valeur\" : 42 , \"type\" : \"r\u00e9ponse\" } mon_tableau = ( 'a' , 'ab' , 'ac' ) mon_tableau [ 0 ] mon_dictionnaire [ \"valeur\" ] 4. Docstrings Une docstring (\u00ab cha\u00eene de documentation \u00bb en fran\u00e7ais) est un texte qui documente un \u00e9l\u00e9ment du code comme par exemple les fonctions. Elle est situ\u00e9e en d\u00e9but de d\u00e9finition, indent\u00e9e comme le code, et se compose de trois guillemets ouvrants, puis du commentaire r\u00e9dig\u00e9 sous forme de phrases compl\u00e8tes et enfin de trois guillements fermants. Toutes les fonctions et classes devraient disposer d'une docstring . Exemples def est_premier ( nombre ): \"\"\" nombre est un entier est_premier(nombre) vaut True si nombre est premier, et False sinon \"\"\" ...","title":"Bonnes pratiques"},{"location":"python/pep8/#bonnes-pratiques-en-programmation-python","text":"\u00c9crire un texte dans une langue n\u00e9cessite le respect de r\u00e8gles typographiques concernant notamment l'usage des majuscules, des espaces, de la ponctuation, des paragraphes, etc. Il en est souvent de m\u00eame pour les langages , comme les langages de programmation. Des propositions d'am\u00e9liorations concernant le langage Python sont r\u00e9guli\u00e8rement publi\u00e9es : les Python Enhancement Proposal (PEP). L'une de ces propositions, la PEP 8 : Style Guide for Python Code , consiste en un nombre important de recommandations sur la syntaxe Python. Seules quelques-unes sont pr\u00e9sent\u00e9es ici.","title":"Bonnes pratiques en programmation python"},{"location":"python/pep8/#1-mise-en-page","text":"Longueur des lignes : une ligne doit contenir 79 caract\u00e8res au maximum. Indentation : les blocs d'instructions sont \u00e0 indenter de 4 espaces.","title":"1. Mise en page"},{"location":"python/pep8/#2-regles-de-nommage","text":"Les noms de variable, fonction ou classe ne doivent pas contenir d'accent. Les caract\u00e8res autoris\u00e9s sont les lettres, les chiffres et le tiret bas : _","title":"2. R\u00e8gles de nommage"},{"location":"python/pep8/#variables-et-fonctions","text":"Les noms de variables et de fonctions sont \u00e0 \u00e9crire avec des lettres minuscules et le tiret bas.","title":"Variables et fonctions"},{"location":"python/pep8/#constantes","text":"Les noms des constantes sont \u00e0 \u00e9crire avec des lettres capitales et le tiret bas.","title":"Constantes"},{"location":"python/pep8/#classes","text":"Les noms des classes sont \u00e0 \u00e9crire avec des lettres minuscules avec majuscules en d\u00e9but de mot. Exemples Variables compteur mon_tableau Fonctions jouer () racine_carree ( x ) Constantes CLE NB_POINTS Classes MaClasse MaSuperClasse Info Le style recommand\u00e9 pour nommer les variables et les fonctions en Python est appel\u00e9 snake_case . Le style recommand\u00e9 pour nommer les classes en Python est appel\u00e9 CamelCase .","title":"Classes"},{"location":"python/pep8/#3-espaces","text":"Les espaces suivent la syntaxe anglo-saxonne et non fran\u00e7aise. Ainsi les caract\u00e8res ; , : et , s'\u00e9crivent avec un espace apr\u00e8s mais pas d'espace avant.","title":"3. Espaces"},{"location":"python/pep8/#autour-des-operateurs","text":"Il est recommand\u00e9 de toujours entourer les op\u00e9rateurs suivants ( = , += , -= , *= , /= , == , != , >= , not , in , and , or , etc.) d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Les op\u00e9rateurs suivants ( + , - , * , / ) sont \u00e0 entourer en r\u00e8gle g\u00e9n\u00e9rale d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Lorsqu'une expression comporte des op\u00e9rations de diff\u00e9rentes priorit\u00e9s, on peut r\u00e9server les espaces \u00e0 l'op\u00e9rateur de plus faible priorit\u00e9. Exemples compteur = 0 compteur = compteur + 1 compteur += 1 x = 2 * x + 1","title":"Autour des op\u00e9rateurs"},{"location":"python/pep8/#autour-des-parentheses","text":"Il n'y a pas d'espace : apr\u00e8s les parenth\u00e8ses, accolades et crochets ouvrants ; avant les parenth\u00e8ses, accolades et crochets fermants ; juste avant la parenth\u00e8se ouvrante d'une fonction ou le crochet ouvrant d'une liste ou d'un dictionnaire. Exemples ma_fonction ( x ) mon_dictionnaire = { \"valeur\" : 42 , \"type\" : \"r\u00e9ponse\" } mon_tableau = ( 'a' , 'ab' , 'ac' ) mon_tableau [ 0 ] mon_dictionnaire [ \"valeur\" ]","title":"Autour des parenth\u00e8ses"},{"location":"python/pep8/#4-docstrings","text":"Une docstring (\u00ab cha\u00eene de documentation \u00bb en fran\u00e7ais) est un texte qui documente un \u00e9l\u00e9ment du code comme par exemple les fonctions. Elle est situ\u00e9e en d\u00e9but de d\u00e9finition, indent\u00e9e comme le code, et se compose de trois guillemets ouvrants, puis du commentaire r\u00e9dig\u00e9 sous forme de phrases compl\u00e8tes et enfin de trois guillements fermants. Toutes les fonctions et classes devraient disposer d'une docstring . Exemples def est_premier ( nombre ): \"\"\" nombre est un entier est_premier(nombre) vaut True si nombre est premier, et False sinon \"\"\" ...","title":"4. Docstrings"},{"location":"python/type/","text":"Types todo","title":"Types"},{"location":"python/type/#types","text":"todo","title":"Types"},{"location":"snt/snt/","text":"essai test graph TD A --> B digraph hierarchy { nodesep=1 // Increases the separation between nodes node [color=Grey,fontname=Optima,shape=box] // All nodes will this shape and colour edge [color=Lightblue] // All the lines look like this Test->{rep1 rep2 rep3}; rep1->\"fichier1.txt\"; rep2->rep5; rep3->{rep6 rep7}; rep7->\"fichier1.txt \"; {rank=same; } // Put them on the same level }","title":"essai"},{"location":"snt/snt/#essai","text":"test graph TD A --> B digraph hierarchy { nodesep=1 // Increases the separation between nodes node [color=Grey,fontname=Optima,shape=box] // All nodes will this shape and colour edge [color=Lightblue] // All the lines look like this Test->{rep1 rep2 rep3}; rep1->\"fichier1.txt\"; rep2->rep5; rep3->{rep6 rep7}; rep7->\"fichier1.txt \"; {rank=same; } // Put them on the same level }","title":"essai"},{"location":"thymio/th_scratch/","text":"Programmer Thymio avec Scratch 3 Thymio suite propose de programmer Thymio avec une extension de Scratch 3. Cette extension ajoute une s\u00e9rie de blocs pour programmer le robot. Pour programmer Thymio avec Scratch : Ins\u00e9rer le dongle USB de Thymio ou connecter Thymio par c\u00e2ble USB \u00e0 un ordinateur Allumer Thymio (appui sur le bouton central) Lancer Thymio suite Choisir Scratch parmi les applications propos\u00e9es S\u00e9lectionner le Thymio \u00e0 utiliser Cliquer sur Programmer avec Scratch L'interface de Scratch s'ouvre dans un navigateur. Dans la liste des types de blocs sur la gauche, l'ic\u00f4ne Thymio permet de disposer de nouveaux blocs d'instruction. Ces blocs n'agissent pas sur le lutin de Scratch mais sur le Thymio connect\u00e9 ! Pour tester si tout fonctionne, double-cliquer sur une instruction, par exemple : ou Si Thymio change de couleur ou pivote l\u00e9g\u00e8rement, c'est que tout fonctionne correctement !","title":"Programmer Thymio avec Scratch"},{"location":"thymio/th_scratch/#programmer-thymio-avec-scratch-3","text":"Thymio suite propose de programmer Thymio avec une extension de Scratch 3. Cette extension ajoute une s\u00e9rie de blocs pour programmer le robot. Pour programmer Thymio avec Scratch : Ins\u00e9rer le dongle USB de Thymio ou connecter Thymio par c\u00e2ble USB \u00e0 un ordinateur Allumer Thymio (appui sur le bouton central) Lancer Thymio suite Choisir Scratch parmi les applications propos\u00e9es S\u00e9lectionner le Thymio \u00e0 utiliser Cliquer sur Programmer avec Scratch L'interface de Scratch s'ouvre dans un navigateur. Dans la liste des types de blocs sur la gauche, l'ic\u00f4ne Thymio permet de disposer de nouveaux blocs d'instruction. Ces blocs n'agissent pas sur le lutin de Scratch mais sur le Thymio connect\u00e9 ! Pour tester si tout fonctionne, double-cliquer sur une instruction, par exemple : ou Si Thymio change de couleur ou pivote l\u00e9g\u00e8rement, c'est que tout fonctionne correctement !","title":"Programmer Thymio avec Scratch 3"},{"location":"thymio/thymio/","text":"Le robot Thymio Pr\u00e9sentation Thymio est un robot \u00e9ducatif. Il a \u00e9t\u00e9 d\u00e9velopp\u00e9 en 2011 par l\u2019\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne. Thymio poss\u00e8de deux roues qui lui permettent de se d\u00e9placer. Il est dot\u00e9 de LEDS pour l'\u00e9clairer de toutes les couleurs. Il est \u00e9quip\u00e9 d'un micro et d'un haut-parleur, et de capteurs divers : capteurs de distance ou de luminosit\u00e9, capteur de temp\u00e9rature, acc\u00e9l\u00e9rom\u00e8tre. Il poss\u00e8de \u00e9galement des attaches LEGO \u00ae et un crochet pour ajouter des accessoires. Modes pr\u00e9-programm\u00e9s Il poss\u00e8de six comportements pr\u00e9-programm\u00e9s accessibles d\u00e8s l\u2019ouverture de la bo\u00eete et sans programmation. Programmer Thymio Thymio est fourni avec une suite logicielle, Thymio suite permettant de programmer le robot : - en VPL (langage de programmation visuel) - avec Blockly (langage de programmation par blocs) - avec Scratch (langage de programmation par blocs) - avec Aseba (langage de programmation textuel) Une autre interface de programmation est \u00e9galement disponible : Blockly4Thymio . Cette interface de programmation par blocs dispose d'instructions r\u00e9dig\u00e9es en fran\u00e7ais, faciles \u00e0 appr\u00e9hender, et en partie diff\u00e9rentes du jeu d'instruction de Blockly. On trouvera par exemple des instructions permettant d'avancer d'une certaine longueur ou de tourner d'une certaine mesure d'angle. \u00c0 noter : la version 13 du firmware du Thymio ne semble pas fonctionner avec Blockly4Thymio, mais il est possible de revenir \u00e0 la version 12 qui assure la compatibilit\u00e9 . R\u00e9glage / calibrage de Thymio Les versions 9 et suivantes du firmware permettent de r\u00e9aliser des r\u00e9glages sur le Thymio. Pour entrer dans le menu de configuration, appuyer 3 secondes sur les boutons gauche et droite d'un Thymio non connect\u00e9 \u00e0 un ordinateur (ni c\u00e2ble, ni dongle USB). Trois nouvelles couleurs (orange, vert clair, mauve) indiquent les trois modes que l'on peut faire d\u00e9filer avec les fl\u00e8ches gauche/droite et s\u00e9lectionner avec le bouton central. R\u00e9glage du volume Choisir la couleur orange du Thymio et s\u00e9lectionner ce mode en appuyant sur le bouton central. Appuyer sur les boutons \"avant\" et \"arri\u00e8re\" pour s\u00e9lectionner le niveau sonore souhait\u00e9. \u00c9teindre le Thymio pour sauvegarder le r\u00e9glage. R\u00e9glage des vitesses des 2 moteurs Ce r\u00e9glage peut s'av\u00e9rer n\u00e9cessaire si Thymio n'avance pas \"droit\". Choisir le mode vert clair dans le menu des modes de r\u00e9glage. Les boutons \"avant\" et \"arri\u00e8re\" font bouger le robot vers l'avant et vers l'arri\u00e8re \u00e0 diff\u00e9rentes vitesses suivant le nombre de pressions. Essayer d'aller \u00e0 des vitesses diff\u00e9rentes (niveau 1 et 2) pour le calibrer. Les boutons \"gauche\" et \"droite\" permettent d'augmenter ou de diminuer la correction. Si le robot va vers la droite, appuyer sur le bouton gauche pour corriger la direction jusqu'\u00e0 ce qu'il aille droit, et inversement. Appuyer sur le bouton central pour arr\u00eater les moteurs et enregistrer les valeurs de correction dans le robot. \u00c9teindre le robot. Appairage Thymio-dongle USB Ce r\u00e9glage est \u00e0 r\u00e9aliser une fois lorsqu'on utilise plusieurs Thymio et que l'on souhaite que chaque Thymio communique avec un seul dongle USB. Commencer avec un Thymio \u00e9teint, non connect\u00e9 \u00e0 l\u2019ordinateur via le c\u00e2ble USB. Brancher le dongle dans un port USB de l\u2019ordinateur Lancer WirelessThymio Network Configurator (t\u00e9l\u00e9charg\u00e9 avec Aseba ou Thymio Suite) Choisir un canal : 0, 1 ou 2 Choisir un identificateur de r\u00e9seau (un identificateur diff\u00e9rent pour chaque Thymio) Ne pas modifier l'identificateur de n\u0153ud du dongle Allumer le Thymio Sur l\u2019ordinateur, cliquer sur activer le pairage Appuyer sur les fl\u00e8ches droite et gauche du Thymio pendant 3 s (menu r\u00e9glages) puis appuyer sur touche droite jusqu\u2019\u00e0 trouver le mode Mauve, valider avec le bouton central Le dongle USB et le Thymio doivent clignoter \u00e0 la m\u00eame fr\u00e9quence : si c'est le cas : \u00c9teindre le Thymio Sur l\u2019ordinateur, cliquer sur enregistrer dans le dongle USB Fermer WirelessThymio Network Configurator , m\u00eame s\u2019il y a un autre Thymio \u00e0 configurer.","title":"Le robot Thymio"},{"location":"thymio/thymio/#le-robot-thymio","text":"","title":"Le robot Thymio"},{"location":"thymio/thymio/#presentation","text":"Thymio est un robot \u00e9ducatif. Il a \u00e9t\u00e9 d\u00e9velopp\u00e9 en 2011 par l\u2019\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne. Thymio poss\u00e8de deux roues qui lui permettent de se d\u00e9placer. Il est dot\u00e9 de LEDS pour l'\u00e9clairer de toutes les couleurs. Il est \u00e9quip\u00e9 d'un micro et d'un haut-parleur, et de capteurs divers : capteurs de distance ou de luminosit\u00e9, capteur de temp\u00e9rature, acc\u00e9l\u00e9rom\u00e8tre. Il poss\u00e8de \u00e9galement des attaches LEGO \u00ae et un crochet pour ajouter des accessoires.","title":"Pr\u00e9sentation"},{"location":"thymio/thymio/#modes-pre-programmes","text":"Il poss\u00e8de six comportements pr\u00e9-programm\u00e9s accessibles d\u00e8s l\u2019ouverture de la bo\u00eete et sans programmation.","title":"Modes pr\u00e9-programm\u00e9s"},{"location":"thymio/thymio/#programmer-thymio","text":"Thymio est fourni avec une suite logicielle, Thymio suite permettant de programmer le robot : - en VPL (langage de programmation visuel) - avec Blockly (langage de programmation par blocs) - avec Scratch (langage de programmation par blocs) - avec Aseba (langage de programmation textuel) Une autre interface de programmation est \u00e9galement disponible : Blockly4Thymio . Cette interface de programmation par blocs dispose d'instructions r\u00e9dig\u00e9es en fran\u00e7ais, faciles \u00e0 appr\u00e9hender, et en partie diff\u00e9rentes du jeu d'instruction de Blockly. On trouvera par exemple des instructions permettant d'avancer d'une certaine longueur ou de tourner d'une certaine mesure d'angle. \u00c0 noter : la version 13 du firmware du Thymio ne semble pas fonctionner avec Blockly4Thymio, mais il est possible de revenir \u00e0 la version 12 qui assure la compatibilit\u00e9 .","title":"Programmer Thymio"},{"location":"thymio/thymio/#reglage-calibrage-de-thymio","text":"Les versions 9 et suivantes du firmware permettent de r\u00e9aliser des r\u00e9glages sur le Thymio. Pour entrer dans le menu de configuration, appuyer 3 secondes sur les boutons gauche et droite d'un Thymio non connect\u00e9 \u00e0 un ordinateur (ni c\u00e2ble, ni dongle USB). Trois nouvelles couleurs (orange, vert clair, mauve) indiquent les trois modes que l'on peut faire d\u00e9filer avec les fl\u00e8ches gauche/droite et s\u00e9lectionner avec le bouton central.","title":"R\u00e9glage / calibrage de Thymio"},{"location":"thymio/thymio/#reglage-du-volume","text":"Choisir la couleur orange du Thymio et s\u00e9lectionner ce mode en appuyant sur le bouton central. Appuyer sur les boutons \"avant\" et \"arri\u00e8re\" pour s\u00e9lectionner le niveau sonore souhait\u00e9. \u00c9teindre le Thymio pour sauvegarder le r\u00e9glage.","title":"R\u00e9glage du volume"},{"location":"thymio/thymio/#reglage-des-vitesses-des-2-moteurs","text":"Ce r\u00e9glage peut s'av\u00e9rer n\u00e9cessaire si Thymio n'avance pas \"droit\". Choisir le mode vert clair dans le menu des modes de r\u00e9glage. Les boutons \"avant\" et \"arri\u00e8re\" font bouger le robot vers l'avant et vers l'arri\u00e8re \u00e0 diff\u00e9rentes vitesses suivant le nombre de pressions. Essayer d'aller \u00e0 des vitesses diff\u00e9rentes (niveau 1 et 2) pour le calibrer. Les boutons \"gauche\" et \"droite\" permettent d'augmenter ou de diminuer la correction. Si le robot va vers la droite, appuyer sur le bouton gauche pour corriger la direction jusqu'\u00e0 ce qu'il aille droit, et inversement. Appuyer sur le bouton central pour arr\u00eater les moteurs et enregistrer les valeurs de correction dans le robot. \u00c9teindre le robot.","title":"R\u00e9glage des vitesses des 2 moteurs"},{"location":"thymio/thymio/#appairage-thymio-dongle-usb","text":"Ce r\u00e9glage est \u00e0 r\u00e9aliser une fois lorsqu'on utilise plusieurs Thymio et que l'on souhaite que chaque Thymio communique avec un seul dongle USB. Commencer avec un Thymio \u00e9teint, non connect\u00e9 \u00e0 l\u2019ordinateur via le c\u00e2ble USB. Brancher le dongle dans un port USB de l\u2019ordinateur Lancer WirelessThymio Network Configurator (t\u00e9l\u00e9charg\u00e9 avec Aseba ou Thymio Suite) Choisir un canal : 0, 1 ou 2 Choisir un identificateur de r\u00e9seau (un identificateur diff\u00e9rent pour chaque Thymio) Ne pas modifier l'identificateur de n\u0153ud du dongle Allumer le Thymio Sur l\u2019ordinateur, cliquer sur activer le pairage Appuyer sur les fl\u00e8ches droite et gauche du Thymio pendant 3 s (menu r\u00e9glages) puis appuyer sur touche droite jusqu\u2019\u00e0 trouver le mode Mauve, valider avec le bouton central Le dongle USB et le Thymio doivent clignoter \u00e0 la m\u00eame fr\u00e9quence : si c'est le cas : \u00c9teindre le Thymio Sur l\u2019ordinateur, cliquer sur enregistrer dans le dongle USB Fermer WirelessThymio Network Configurator , m\u00eame s\u2019il y a un autre Thymio \u00e0 configurer.","title":"Appairage Thymio-dongle USB"}]}