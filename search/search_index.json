{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur Carnets.info Ce site pr\u00e9sente quelques documents utilis\u00e9s dans le cadre de : - l'enseignement de NSI 1 , en 1\u00e8re g\u00e9n\u00e9rale, - l'enseignement de SNT 2 en 2nde, - ou en formation. Num\u00e9rique et sciences informatiques \u21a9 Sciences du num\u00e9rique et technologie \u21a9","title":"Accueil"},{"location":"#bienvenue-sur-carnetsinfo","text":"Ce site pr\u00e9sente quelques documents utilis\u00e9s dans le cadre de : - l'enseignement de NSI 1 , en 1\u00e8re g\u00e9n\u00e9rale, - l'enseignement de SNT 2 en 2nde, - ou en formation. Num\u00e9rique et sciences informatiques \u21a9 Sciences du num\u00e9rique et technologie \u21a9","title":"Bienvenue sur Carnets.info"},{"location":"about/","text":"\u00c0 propos Site r\u00e9alis\u00e9 par Nathalie Weibel, enseignante dans l'acad\u00e9mie de Normandie","title":"\u00c0 propos"},{"location":"about/#a-propos","text":"Site r\u00e9alis\u00e9 par Nathalie Weibel, enseignante dans l'acad\u00e9mie de Normandie","title":"\u00c0 propos"},{"location":"memomd/","text":"M\u00e9mo Markdown Markdown a \u00e9t\u00e9 cr\u00e9\u00e9 par John Gruber en 2004. Markdown est con\u00e7u pour \u00eatre aussi facile \u00e0 lire et \u00e0 \u00e9crire que possible. Il est ais\u00e9ment convertible en HTML. Les fichiers Markdown poss\u00e8dent l\u2019extension .md . Markdown est \u00e9galement le langage des cellules de texte d'un notebook Jupyter. Voici la plupart des \u00e9l\u00e9ments de la syntaxe Markdown et leur \u00e9quivalent en HTML. Titres Markdown # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 #### Titre de niveau 4 ##### Titre de niveau 5 ###### Titre de niveau 6 HTML < h1 > Titre de niveau 1 </ h1 > < h2 > Titre de niveau 2 </ h2 > < h3 > Titre de niveau 3 </ h3 > < h4 > Titre de niveau 4 </ h4 > < h5 > Titre de niveau 5 </ h5 > < h6 > Titre de niveau 6 </ h6 > Emphase Markdown *Texte en italique* **Texte en gras** ~~Texte barr\u00e9~~ HTML < p >< em > Texte en italique </ em ></ p > < p >< strong > Texte en gras </ strong > </ p > < p >< s > Texte barr\u00e9 </ s ></ p > Aper\u00e7u Texte en italique Texte en gras Texte barr\u00e9 Listes Listes \u00e0 puces Markdown * \u00c9l\u00e9ment 1 * \u00c9l\u00e9ment 2 * Sous-\u00e9l\u00e9ment 1 * Sous \u00e9l\u00e9ment 2 * \u00c9l\u00e9ment 3 HTML < ul > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ul > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ul > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Listes ordonn\u00e9es Markdown 1. \u00c9l\u00e9ment 1 2. \u00c9l\u00e9ment 2 1. Sous-\u00e9l\u00e9ment 1 2. Sous \u00e9l\u00e9ment 2 3. \u00c9l\u00e9ment 3 HTML < ol > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ol > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ol > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ol > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Remarque : la valeur num\u00e9rique des entr\u00e9es des \u00e9l\u00e9ments n'a pas d'importance : Markdown 1. \u00c9l\u00e9ment 1 1. \u00c9l\u00e9ment 2 4. \u00c9l\u00e9ment 3 Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 \u00c9l\u00e9ment 3 Listes \u00e0 cocher Markdown - [x] \u00c9l\u00e9ment 1, coch\u00e9 - [ ] \u00c9l\u00e9ment 2, non-coch\u00e9 - [x] Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 - [ ] Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 - [ ] \u00c9l\u00e9ment 3, non-coch\u00e9 HTML < ul > < li > < label > < input type = \"checkbox\" checked > \u00c9l\u00e9ment 1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 2, non-coch\u00e9 </ label > </ li > < ul > < li > < label > < input type = \"checkbox\" checked > Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 </ label > </ li > </ ul > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 3, non-coch\u00e9 </ label > </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1, coch\u00e9 \u00c9l\u00e9ment 2, non-coch\u00e9 Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 \u00c9l\u00e9ment 3, non-coch\u00e9 Citations Markdown > Voici une citation > sur plusieurs lignes HTML < blockquote > < p > Voici une citation </ p > < p > sur plusieurs lignes </ p > </ blockquote > Aper\u00e7u Voici une citation sur plusieurs lignes S\u00e9parateurs horizontaux Markdown --- ou *** ou ___ HTML < hr /> Aper\u00e7u Liens Markdown [ Ceci est le texte du lien ]( https://www.carnets.info ) [ Ceci est un lien avec un titre au survol ]( https://www.carnets.info \"Le titre du lien\" ) Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : <https://www.carnets.info> HTML < p >< a href = \"https://www.carnets.info\" > Ceci est le texte du lien </ a ></ p > < p >< a href = \"https://www.carnets.info\" title = \"Le titre du lien\" > Ceci est un lien avec un titre au survol </ a ></ p > < p > Ceci est un lien automatique : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > < p > On rencontre aussi cette syntaxe : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > Aper\u00e7u Ceci est le texte du lien Ceci est un lien avec un titre au survol Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : https://www.carnets.info Images Markdown ![ logo Markdown ]( https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Markdown\" ) HTML < img src = \"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt = \"logo Markdown\" title = \"Logo Markdown\" > Aper\u00e7u Tableaux Markdown Titre colonne 1 (gauche) | Titre colonne 2 (centr\u00e9) | Titre colonne 3 (centr\u00e9) :--- | :---: | :---: Celule 1.1 | Celule 1.2 | Celule 1.3 Celule 2.1 | Celule 2.2 | Celule 2.3 HTML < table > < thead > < tr > < th > Titre colonne 1 </ th > < th > Titre colonne 2 </ th > < th > Titre colonne 3 </ th > </ tr > </ thead > < tbody > < tr > < td > Celule 1.1 </ td > < td > Celule 1.2 </ td > < td > Celule 1.3 </ td > </ tr > < tr > < td > Celule 2.1 </ td > < td > Celule 2.2 </ td > < td > Celule 2.3 </ td > </ tr > </ tbody > </ table > Aper\u00e7u Titre colonne 1 (gauche) Titre colonne 2 (centr\u00e9) Titre colonne 3 (centr\u00e9) Celule 1.1 Celule 1.2 Celule 1.3 Celule 2.1 Celule 2.2 Celule 2.3 Code Code en ligne Markdown insertion de code en ligne : `print(\"Hello World!\")` HTML < p > insertion de code en ligne : < code > print(\"Hello World!\") </ code ></ p > Aper\u00e7u insertion de code en ligne : print(\"Hello World!\") Bloc de code Markdown ```python print ( \"Hello World!\" ) ``` HTML < pre > print(\"Hello World!\") </ pre > Aper\u00e7u print ( \"Hello World!\" ) Formules LaTeX (MathJax) Markdown Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : $x^2 + 3x -7 = 0$ Mode bloc (display) : On trouve : $$x = \\frac{-3 \\pm \\sqrt{37}}{2}$$ Aper\u00e7u Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : x^2 + 3x -7 = 0 x^2 + 3x -7 = 0 Mode bloc (display) : On trouve : x = \\frac{-3 \\pm \\sqrt{37}}{2} x = \\frac{-3 \\pm \\sqrt{37}}{2} Caract\u00e8res sp\u00e9cifiques Tirets Il n'y a pas de balise Markdown sp\u00e9cifique pour r\u00e9aliser des tirets cadratins ou demi-cadratins. On utilise des balises HTML pour cr\u00e9er ces tirets. tiret long ou tiret cadratin : HTML &mdash; Aper\u00e7u \u2014 tiret moyen ou tiret demi-cadratin HTML &ndash; Aper\u00e7u \u2013 Touches clavier Markdown <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> Aper\u00e7u Ctrl + Alt + Del Notes de bas de page Markdown Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page[^a]. Et une autre[^b]. On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois[^b]. [ ^a ]: Les notes de bas de page peuvent \u00eatre **mises en forme**, et sur plusieurs lignes. [ ^b ]: Autre note de bas de page. Aper\u00e7u : Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page 1 . Et une autre 2 . On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois 2 . Les notes de bas de page peuvent \u00eatre mises en forme , et sur plusieurs lignes. \u21a9 Autre note de bas de page. \u21a9 \u21a9","title":"M\u00e9mo Markdown"},{"location":"memomd/#memo-markdown","text":"Markdown a \u00e9t\u00e9 cr\u00e9\u00e9 par John Gruber en 2004. Markdown est con\u00e7u pour \u00eatre aussi facile \u00e0 lire et \u00e0 \u00e9crire que possible. Il est ais\u00e9ment convertible en HTML. Les fichiers Markdown poss\u00e8dent l\u2019extension .md . Markdown est \u00e9galement le langage des cellules de texte d'un notebook Jupyter. Voici la plupart des \u00e9l\u00e9ments de la syntaxe Markdown et leur \u00e9quivalent en HTML.","title":"M\u00e9mo Markdown"},{"location":"memomd/#titres","text":"Markdown # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 #### Titre de niveau 4 ##### Titre de niveau 5 ###### Titre de niveau 6 HTML < h1 > Titre de niveau 1 </ h1 > < h2 > Titre de niveau 2 </ h2 > < h3 > Titre de niveau 3 </ h3 > < h4 > Titre de niveau 4 </ h4 > < h5 > Titre de niveau 5 </ h5 > < h6 > Titre de niveau 6 </ h6 >","title":"Titres"},{"location":"memomd/#emphase","text":"Markdown *Texte en italique* **Texte en gras** ~~Texte barr\u00e9~~ HTML < p >< em > Texte en italique </ em ></ p > < p >< strong > Texte en gras </ strong > </ p > < p >< s > Texte barr\u00e9 </ s ></ p > Aper\u00e7u Texte en italique Texte en gras Texte barr\u00e9","title":"Emphase"},{"location":"memomd/#listes","text":"","title":"Listes"},{"location":"memomd/#listes-a-puces","text":"Markdown * \u00c9l\u00e9ment 1 * \u00c9l\u00e9ment 2 * Sous-\u00e9l\u00e9ment 1 * Sous \u00e9l\u00e9ment 2 * \u00c9l\u00e9ment 3 HTML < ul > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ul > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ul > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3","title":"Listes \u00e0 puces"},{"location":"memomd/#listes-ordonnees","text":"Markdown 1. \u00c9l\u00e9ment 1 2. \u00c9l\u00e9ment 2 1. Sous-\u00e9l\u00e9ment 1 2. Sous \u00e9l\u00e9ment 2 3. \u00c9l\u00e9ment 3 HTML < ol > < li > \u00c9l\u00e9ment 1 </ li > < li > \u00c9l\u00e9ment 2 < ol > < li > Sous-\u00e9l\u00e9ment 1 </ li > < li > Sous \u00e9l\u00e9ment 2 </ li > </ ol > </ li > < li > \u00c9l\u00e9ment 3 </ li > </ ol > Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 Sous-\u00e9l\u00e9ment 1 Sous \u00e9l\u00e9ment 2 \u00c9l\u00e9ment 3 Remarque : la valeur num\u00e9rique des entr\u00e9es des \u00e9l\u00e9ments n'a pas d'importance : Markdown 1. \u00c9l\u00e9ment 1 1. \u00c9l\u00e9ment 2 4. \u00c9l\u00e9ment 3 Aper\u00e7u \u00c9l\u00e9ment 1 \u00c9l\u00e9ment 2 \u00c9l\u00e9ment 3","title":"Listes ordonn\u00e9es"},{"location":"memomd/#listes-a-cocher","text":"Markdown - [x] \u00c9l\u00e9ment 1, coch\u00e9 - [ ] \u00c9l\u00e9ment 2, non-coch\u00e9 - [x] Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 - [ ] Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 - [ ] \u00c9l\u00e9ment 3, non-coch\u00e9 HTML < ul > < li > < label > < input type = \"checkbox\" checked > \u00c9l\u00e9ment 1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 2, non-coch\u00e9 </ label > </ li > < ul > < li > < label > < input type = \"checkbox\" checked > Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 </ label > </ li > < li > < label > < input type = \"checkbox\" > Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 </ label > </ li > </ ul > < li > < label > < input type = \"checkbox\" > \u00c9l\u00e9ment 3, non-coch\u00e9 </ label > </ li > </ ul > Aper\u00e7u \u00c9l\u00e9ment 1, coch\u00e9 \u00c9l\u00e9ment 2, non-coch\u00e9 Sous-\u00e9l\u00e9ment 2.1, coch\u00e9 Sous-\u00e9l\u00e9ment 2.2, non-coch\u00e9 \u00c9l\u00e9ment 3, non-coch\u00e9","title":"Listes \u00e0 cocher"},{"location":"memomd/#citations","text":"Markdown > Voici une citation > sur plusieurs lignes HTML < blockquote > < p > Voici une citation </ p > < p > sur plusieurs lignes </ p > </ blockquote > Aper\u00e7u Voici une citation sur plusieurs lignes","title":"Citations"},{"location":"memomd/#separateurs-horizontaux","text":"Markdown --- ou *** ou ___ HTML < hr /> Aper\u00e7u","title":"S\u00e9parateurs horizontaux"},{"location":"memomd/#liens","text":"Markdown [ Ceci est le texte du lien ]( https://www.carnets.info ) [ Ceci est un lien avec un titre au survol ]( https://www.carnets.info \"Le titre du lien\" ) Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : <https://www.carnets.info> HTML < p >< a href = \"https://www.carnets.info\" > Ceci est le texte du lien </ a ></ p > < p >< a href = \"https://www.carnets.info\" title = \"Le titre du lien\" > Ceci est un lien avec un titre au survol </ a ></ p > < p > Ceci est un lien automatique : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > < p > On rencontre aussi cette syntaxe : < a href = \"https://www.carnets.info\" > https://www.carnets.info </ a ></ p > Aper\u00e7u Ceci est le texte du lien Ceci est un lien avec un titre au survol Ceci est un lien automatique : https://www.carnets.info On rencontre aussi cette syntaxe : https://www.carnets.info","title":"Liens"},{"location":"memomd/#images","text":"Markdown ![ logo Markdown ]( https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Markdown\" ) HTML < img src = \"https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png\" alt = \"logo Markdown\" title = \"Logo Markdown\" > Aper\u00e7u","title":"Images"},{"location":"memomd/#tableaux","text":"Markdown Titre colonne 1 (gauche) | Titre colonne 2 (centr\u00e9) | Titre colonne 3 (centr\u00e9) :--- | :---: | :---: Celule 1.1 | Celule 1.2 | Celule 1.3 Celule 2.1 | Celule 2.2 | Celule 2.3 HTML < table > < thead > < tr > < th > Titre colonne 1 </ th > < th > Titre colonne 2 </ th > < th > Titre colonne 3 </ th > </ tr > </ thead > < tbody > < tr > < td > Celule 1.1 </ td > < td > Celule 1.2 </ td > < td > Celule 1.3 </ td > </ tr > < tr > < td > Celule 2.1 </ td > < td > Celule 2.2 </ td > < td > Celule 2.3 </ td > </ tr > </ tbody > </ table > Aper\u00e7u Titre colonne 1 (gauche) Titre colonne 2 (centr\u00e9) Titre colonne 3 (centr\u00e9) Celule 1.1 Celule 1.2 Celule 1.3 Celule 2.1 Celule 2.2 Celule 2.3","title":"Tableaux"},{"location":"memomd/#code","text":"","title":"Code"},{"location":"memomd/#code-en-ligne","text":"Markdown insertion de code en ligne : `print(\"Hello World!\")` HTML < p > insertion de code en ligne : < code > print(\"Hello World!\") </ code ></ p > Aper\u00e7u insertion de code en ligne : print(\"Hello World!\")","title":"Code en ligne"},{"location":"memomd/#bloc-de-code","text":"Markdown ```python print ( \"Hello World!\" ) ``` HTML < pre > print(\"Hello World!\") </ pre > Aper\u00e7u print ( \"Hello World!\" )","title":"Bloc de code"},{"location":"memomd/#formules-latex-mathjax","text":"Markdown Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : $x^2 + 3x -7 = 0$ Mode bloc (display) : On trouve : $$x = \\frac{-3 \\pm \\sqrt{37}}{2}$$ Aper\u00e7u Mode en ligne : On cherche les solutions de l'\u00e9quation (E) : x^2 + 3x -7 = 0 x^2 + 3x -7 = 0 Mode bloc (display) : On trouve : x = \\frac{-3 \\pm \\sqrt{37}}{2} x = \\frac{-3 \\pm \\sqrt{37}}{2}","title":"Formules LaTeX (MathJax)"},{"location":"memomd/#caracteres-specifiques","text":"","title":"Caract\u00e8res sp\u00e9cifiques"},{"location":"memomd/#tirets","text":"Il n'y a pas de balise Markdown sp\u00e9cifique pour r\u00e9aliser des tirets cadratins ou demi-cadratins. On utilise des balises HTML pour cr\u00e9er ces tirets. tiret long ou tiret cadratin : HTML &mdash; Aper\u00e7u \u2014 tiret moyen ou tiret demi-cadratin HTML &ndash; Aper\u00e7u \u2013","title":"Tirets"},{"location":"memomd/#touches-clavier","text":"Markdown <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> Aper\u00e7u Ctrl + Alt + Del","title":"Touches clavier"},{"location":"memomd/#notes-de-bas-de-page","text":"Markdown Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page[^a]. Et une autre[^b]. On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois[^b]. [ ^a ]: Les notes de bas de page peuvent \u00eatre **mises en forme**, et sur plusieurs lignes. [ ^b ]: Autre note de bas de page. Aper\u00e7u : Voici une r\u00e9f\u00e9rence \u00e0 une note de bas de page 1 . Et une autre 2 . On peut rappeler une m\u00eame r\u00e9f\u00e9rence plusieurs fois 2 . Les notes de bas de page peuvent \u00eatre mises en forme , et sur plusieurs lignes. \u21a9 Autre note de bas de page. \u21a9 \u21a9","title":"Notes de bas de page"},{"location":"calepyn/calepyn/","text":"Acc\u00e8s \u00e0 mes calepyns , par ordre chronologique.","title":"Calepyns"},{"location":"calepyn/doctest/","text":"Effectuer des tests automatis\u00e9s avec doctest dans un notebook Jupyter On peut r\u00e9aliser des tests automatis\u00e9s dans un fichier python gr\u00e2ce \u00e0 la biblioth\u00e8que doctest . La biblioth\u00e8que doctest permet de d\u00e9tecter automatiquement les tests \u00e9crits dans la docstring , ou chaine de documentation, de les lancer et d\u2019afficher un rapport. Les valeurs \u00e0 tester doivent \u00eatre pr\u00e9c\u00e9d\u00e9es de >>> , et le r\u00e9sultat attendu doit \u00eatre en d\u00e9but de ligne suivante. Voici un exemple pour la fonction est_parfait : def est_parfait ( n ) : '''n est un entier strictement positif parfait(n) vaut True si l'entier n est parfait ou False sinon. Un nombre parfait est tel que la somme de ses diviseurs est \u00e9gale \u00e0 son double. >>> est_parfait(2) False >>> est_parfait(6) True >>> est_parfait(27) False >>> est_parfait(28) True ''' assert ( n > 0 and type ( n ) == int ), \"l'argument doit \u00eatre un entier strictement positif\" diviseurs = [ i for i in range ( 1 , n + 1 ) if n % i == 0 ] return sum ( diviseurs ) == 2 * n On ex\u00e9cute dans une cellule du notebook les instructions suivantes : import doctest doctest . testmod () Un rapport concis des tests est alors affich\u00e9 (attention, les tests sont lanc\u00e9s sur l\u2019ensemble du notebook) : TestResults(failed=0, attempted=4) ce qui signifie ici que les 4 tests n'ont donn\u00e9 lieu \u00e0 aucun \u00e9chec. On peut ajouter l\u2019argument verbose=True en \u00e9crivant doctest.testmod(verbose=True) : le rapport produit est alors plus explicite. Trying : est_parfait ( 2 ) Expecting : False ok Trying : est_parfait ( 6 ) Expecting : True ok Trying : est_parfait ( 27 ) Expecting : False ok Trying : est_parfait ( 28 ) Expecting : True ok 1 items had no tests : __main__ 1 items passed all tests : 4 tests in __main__ . est_parfait 4 tests in 2 items . 4 passed and 0 failed . Test passed . TestResults ( failed = 0 , attempted = 4 )","title":"Doctest"},{"location":"calepyn/doctest/#effectuer-des-tests-automatises-avec-doctest-dans-un-notebook-jupyter","text":"On peut r\u00e9aliser des tests automatis\u00e9s dans un fichier python gr\u00e2ce \u00e0 la biblioth\u00e8que doctest . La biblioth\u00e8que doctest permet de d\u00e9tecter automatiquement les tests \u00e9crits dans la docstring , ou chaine de documentation, de les lancer et d\u2019afficher un rapport. Les valeurs \u00e0 tester doivent \u00eatre pr\u00e9c\u00e9d\u00e9es de >>> , et le r\u00e9sultat attendu doit \u00eatre en d\u00e9but de ligne suivante. Voici un exemple pour la fonction est_parfait : def est_parfait ( n ) : '''n est un entier strictement positif parfait(n) vaut True si l'entier n est parfait ou False sinon. Un nombre parfait est tel que la somme de ses diviseurs est \u00e9gale \u00e0 son double. >>> est_parfait(2) False >>> est_parfait(6) True >>> est_parfait(27) False >>> est_parfait(28) True ''' assert ( n > 0 and type ( n ) == int ), \"l'argument doit \u00eatre un entier strictement positif\" diviseurs = [ i for i in range ( 1 , n + 1 ) if n % i == 0 ] return sum ( diviseurs ) == 2 * n On ex\u00e9cute dans une cellule du notebook les instructions suivantes : import doctest doctest . testmod () Un rapport concis des tests est alors affich\u00e9 (attention, les tests sont lanc\u00e9s sur l\u2019ensemble du notebook) : TestResults(failed=0, attempted=4) ce qui signifie ici que les 4 tests n'ont donn\u00e9 lieu \u00e0 aucun \u00e9chec. On peut ajouter l\u2019argument verbose=True en \u00e9crivant doctest.testmod(verbose=True) : le rapport produit est alors plus explicite. Trying : est_parfait ( 2 ) Expecting : False ok Trying : est_parfait ( 6 ) Expecting : True ok Trying : est_parfait ( 27 ) Expecting : False ok Trying : est_parfait ( 28 ) Expecting : True ok 1 items had no tests : __main__ 1 items passed all tests : 4 tests in __main__ . est_parfait 4 tests in 2 items . 4 passed and 0 failed . Test passed . TestResults ( failed = 0 , attempted = 4 )","title":"Effectuer des tests automatis\u00e9s avec doctest dans un notebook Jupyter"},{"location":"microbit/decouvrir_microbit/","text":"La carte micro:bit Qu'est-ce qu'une carte micro:bit ? La carte BBC micro:bit est une carte micro-contr\u00f4leur de 5 cm sur 4 cm, qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion La version 2, distribu\u00e9e \u00e0 partir de fin 2020, comporte \u00e9galement un micro et un haut-parleur. Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles (2 piles AAA - 3V). Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. Programmer la carte micro:bit Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages, dans un navigateur ou \u00e0 l'aide d'un logiciel install\u00e9. Ce site propose des exemples : - de programmation par blocs avec MakeCode ou Vittascience - de programmation par blocs avec Scratch - de programmation Python avec l'\u00e9diteur Python en ligne ou Mu Mettre \u00e0 jour le firmware de la carte micro:bit Le firmware est un logiciel qui est physiquement stock\u00e9 dans la puce de la carte micro:bit mais qui n'est pas modifi\u00e9 lors de l'\u00e9criture de programmes ou lorsque la carte micro:bit est \u00e9teinte. Il est possible de mettre \u00e0 jour le firmware pour utiliser de nouvelles fonctionnalit\u00e9s telles que WebUSB. Conna\u00eetre la version du firmware install\u00e9 Pour conna\u00eetre la version du firmware install\u00e9 sur une carte micro:bit, connecter la carte \u00e0 l'aide du c\u00e2ble USB \u00e0 un ordianateur : elle appara\u00eet dans le gestionnaire de fichiers sous le nom MICROBIT. Ouvrir le fichier DETAILS.TXT du lecteur MICROBIT et rechercher le num\u00e9ro sur la ligne qui commence par \u00ab Interface Version \u00bb. Comment mettre \u00e0 jour le firmware ? D\u00e9connecter le c\u00e2ble USB et la batterie de la carte micro:bit. Maintenir le bouton de r\u00e9initialisation \u00e0 l'arri\u00e8re la carte tout en connectant la carte \u00e0 un ordinateur \u00e0 l'aide du c\u00e2ble USB. Un lecteur devrait appara\u00eetre dans votre gestionnaire de fichiers appel\u00e9 MAINTENANCE (au lieu de MICROBIT). T\u00e9l\u00e9charger le fichier .hex de cette page sur votre ordinateur. Faire glisser et d\u00e9poser le nouveau fichier .hex du firmware sur le lecteur MAINTENANCE et attendre que le voyant jaune \u00e0 l'arri\u00e8re de l'appareil cesse de clignoter. Lorsque la mise \u00e0 niveau est termin\u00e9e, la carte micro:bit se r\u00e9initialise, s\u2019\u00e9jecte de l\u2019ordinateur et r\u00e9appara\u00eet sous le nom MICROBIT habituel. En consultant le fichier DETAILS.TXT qui se trouve sur le lecteur MICROBIT on peut s'assurer que le firmware a le m\u00eame num\u00e9ro de version que celle qui a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9e. Utiliser la fonctionnalit\u00e9 WebUSB Le transfert de programme se fait g\u00e9n\u00e9ralement en t\u00e9l\u00e9chargeant le fichier .hex du programme, puis en le copiant sur la carte. Avec un navigateur Web r\u00e9cent, on peut envoyer ses programmes directement \u00e0 la carte micro:bit \u00e0 partir des \u00e9diteurs MakeCode et Python sans avoir \u00e0 t\u00e9l\u00e9charger, faire glisser et d\u00e9poser des fichiers .hex . Le t\u00e9l\u00e9chargement direct fait gagner du temps et simplifie la mise \u00e0 jour du code sur la carte. Il utilise un processus appel\u00e9 WebUSB, qui \u00e9tablit une connexion entre le navigateur ou l'application et la carte micro:bit via le c\u00e2ble USB. Pour utiliser cette fonctionnalit\u00e9, utiliser un navigateur bas\u00e9 sur Chrome, et une carte micro:bit dont la version de firmware est au moins 243 (si besoin, mettre \u00e0 jour le firmware de la carte). Lorsque cette fonctionnalit\u00e9 est disponible, le navigateur vous proposer de connecter la carte. Une fois la connexion \u00e9tablie, le t\u00e9l\u00e9chargement direct est possible. R\u00e9f\u00e9rences R\u00e9f\u00e9rences le site de la fondation micro:bit le site de documentation technique de la carte l'article micro:bit sur wikipedia la page d\u00e9di\u00e9e \u00e0 micro:bit sur le site de la C2ITice","title":"La carte micro:bit"},{"location":"microbit/decouvrir_microbit/#la-carte-microbit","text":"","title":"La carte micro:bit"},{"location":"microbit/decouvrir_microbit/#quest-ce-quune-carte-microbit","text":"La carte BBC micro:bit est une carte micro-contr\u00f4leur de 5 cm sur 4 cm, qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion La version 2, distribu\u00e9e \u00e0 partir de fin 2020, comporte \u00e9galement un micro et un haut-parleur. Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles (2 piles AAA - 3V). Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles.","title":"Qu'est-ce qu'une carte micro:bit ?"},{"location":"microbit/decouvrir_microbit/#programmer-la-carte-microbit","text":"Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages, dans un navigateur ou \u00e0 l'aide d'un logiciel install\u00e9. Ce site propose des exemples : - de programmation par blocs avec MakeCode ou Vittascience - de programmation par blocs avec Scratch - de programmation Python avec l'\u00e9diteur Python en ligne ou Mu","title":"Programmer la carte micro:bit"},{"location":"microbit/decouvrir_microbit/#mettre-a-jour-le-firmware-de-la-carte-microbit","text":"Le firmware est un logiciel qui est physiquement stock\u00e9 dans la puce de la carte micro:bit mais qui n'est pas modifi\u00e9 lors de l'\u00e9criture de programmes ou lorsque la carte micro:bit est \u00e9teinte. Il est possible de mettre \u00e0 jour le firmware pour utiliser de nouvelles fonctionnalit\u00e9s telles que WebUSB.","title":"Mettre \u00e0 jour le firmware de la carte micro:bit"},{"location":"microbit/decouvrir_microbit/#connaitre-la-version-du-firmware-installe","text":"Pour conna\u00eetre la version du firmware install\u00e9 sur une carte micro:bit, connecter la carte \u00e0 l'aide du c\u00e2ble USB \u00e0 un ordianateur : elle appara\u00eet dans le gestionnaire de fichiers sous le nom MICROBIT. Ouvrir le fichier DETAILS.TXT du lecteur MICROBIT et rechercher le num\u00e9ro sur la ligne qui commence par \u00ab Interface Version \u00bb.","title":"Conna\u00eetre la version du firmware install\u00e9"},{"location":"microbit/decouvrir_microbit/#comment-mettre-a-jour-le-firmware","text":"D\u00e9connecter le c\u00e2ble USB et la batterie de la carte micro:bit. Maintenir le bouton de r\u00e9initialisation \u00e0 l'arri\u00e8re la carte tout en connectant la carte \u00e0 un ordinateur \u00e0 l'aide du c\u00e2ble USB. Un lecteur devrait appara\u00eetre dans votre gestionnaire de fichiers appel\u00e9 MAINTENANCE (au lieu de MICROBIT). T\u00e9l\u00e9charger le fichier .hex de cette page sur votre ordinateur. Faire glisser et d\u00e9poser le nouveau fichier .hex du firmware sur le lecteur MAINTENANCE et attendre que le voyant jaune \u00e0 l'arri\u00e8re de l'appareil cesse de clignoter. Lorsque la mise \u00e0 niveau est termin\u00e9e, la carte micro:bit se r\u00e9initialise, s\u2019\u00e9jecte de l\u2019ordinateur et r\u00e9appara\u00eet sous le nom MICROBIT habituel. En consultant le fichier DETAILS.TXT qui se trouve sur le lecteur MICROBIT on peut s'assurer que le firmware a le m\u00eame num\u00e9ro de version que celle qui a \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9e.","title":"Comment mettre \u00e0 jour le firmware ?"},{"location":"microbit/decouvrir_microbit/#utiliser-la-fonctionnalite-webusb","text":"Le transfert de programme se fait g\u00e9n\u00e9ralement en t\u00e9l\u00e9chargeant le fichier .hex du programme, puis en le copiant sur la carte. Avec un navigateur Web r\u00e9cent, on peut envoyer ses programmes directement \u00e0 la carte micro:bit \u00e0 partir des \u00e9diteurs MakeCode et Python sans avoir \u00e0 t\u00e9l\u00e9charger, faire glisser et d\u00e9poser des fichiers .hex . Le t\u00e9l\u00e9chargement direct fait gagner du temps et simplifie la mise \u00e0 jour du code sur la carte. Il utilise un processus appel\u00e9 WebUSB, qui \u00e9tablit une connexion entre le navigateur ou l'application et la carte micro:bit via le c\u00e2ble USB. Pour utiliser cette fonctionnalit\u00e9, utiliser un navigateur bas\u00e9 sur Chrome, et une carte micro:bit dont la version de firmware est au moins 243 (si besoin, mettre \u00e0 jour le firmware de la carte). Lorsque cette fonctionnalit\u00e9 est disponible, le navigateur vous proposer de connecter la carte. Une fois la connexion \u00e9tablie, le t\u00e9l\u00e9chargement direct est possible.","title":"Utiliser la fonctionnalit\u00e9 WebUSB"},{"location":"microbit/decouvrir_microbit/#references","text":"R\u00e9f\u00e9rences le site de la fondation micro:bit le site de documentation technique de la carte l'article micro:bit sur wikipedia la page d\u00e9di\u00e9e \u00e0 micro:bit sur le site de la C2ITice","title":"R\u00e9f\u00e9rences"},{"location":"microbit/makecode/","text":"bient\u00f4t","title":"Programmer la carte avec MakeCode"},{"location":"microbit/python/","text":"D\u00e9couvrir la carte micro:bit 1. Qu'est qu'une carte micro:bit ? La carte BBC micro:bit est une carte micro-contr\u00f4leur qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles. 2. Programmer la carte micro:bit Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch. 2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs} 2.2 Programmer la carte avec Scratch L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer 2.3 Programmer la carte micro:bit en Python Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019. 3. Documents de formation sur la carte micro:bit Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"Programmer la carte avec Python"},{"location":"microbit/python/#decouvrir-la-carte-microbit","text":"","title":"D\u00e9couvrir la carte micro:bit"},{"location":"microbit/python/#1-quest-quune-carte-microbit","text":"La carte BBC micro:bit est une carte micro-contr\u00f4leur qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles.","title":"1. Qu'est qu'une carte micro:bit ?"},{"location":"microbit/python/#2-programmer-la-carte-microbit","text":"Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch.","title":"2. Programmer la carte micro:bit"},{"location":"microbit/python/#21-programmer-la-carte-avec-lediteur-blocks-de-makecode-pour-microbit","text":"Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs}","title":"2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit"},{"location":"microbit/python/#22-programmer-la-carte-avec-scratch","text":"L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer","title":"2.2 Programmer la carte avec Scratch"},{"location":"microbit/python/#23-programmer-la-carte-microbit-en-python","text":"Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019.","title":"2.3 Programmer la carte micro:bit en Python"},{"location":"microbit/python/#3-documents-de-formation-sur-la-carte-microbit","text":"Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"3. Documents de formation sur la carte micro:bit"},{"location":"microbit/scratch/","text":"Utiliser la carte micro:bit avec Scratch 1. Qu'est qu'une carte micro:bit ? On peut connecter une carte micro:bit \u00e0 Scratch et cr\u00e9er des projets cr\u00e9atifs qui combinent le num\u00e9rique et le monde physique. Illustration d'une carte micro:bit. Pr\u00e9-requis Windows 10 version 1709+ macOS 10.13+ ChromeOS Android 6.0+ Bluetooth Scratch Link Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles. 2. Programmer la carte micro:bit Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch. 2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs} 2.2 Programmer la carte avec Scratch L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer 2.3 Programmer la carte micro:bit en Python Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019. 3. Documents de formation sur la carte micro:bit Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"Programmer la carte avec Scratch"},{"location":"microbit/scratch/#utiliser-la-carte-microbit-avec-scratch","text":"","title":"Utiliser la carte micro:bit avec Scratch"},{"location":"microbit/scratch/#1-quest-quune-carte-microbit","text":"On peut connecter une carte micro:bit \u00e0 Scratch et cr\u00e9er des projets cr\u00e9atifs qui combinent le num\u00e9rique et le monde physique. Illustration d'une carte micro:bit. Pr\u00e9-requis Windows 10 version 1709+ macOS 10.13+ ChromeOS Android 6.0+ Bluetooth Scratch Link Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles.","title":"1. Qu'est qu'une carte micro:bit ?"},{"location":"microbit/scratch/#2-programmer-la-carte-microbit","text":"Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch.","title":"2. Programmer la carte micro:bit"},{"location":"microbit/scratch/#21-programmer-la-carte-avec-lediteur-blocks-de-makecode-pour-microbit","text":"Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs}","title":"2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit"},{"location":"microbit/scratch/#22-programmer-la-carte-avec-scratch","text":"L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer","title":"2.2 Programmer la carte avec Scratch"},{"location":"microbit/scratch/#23-programmer-la-carte-microbit-en-python","text":"Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019.","title":"2.3 Programmer la carte micro:bit en Python"},{"location":"microbit/scratch/#3-documents-de-formation-sur-la-carte-microbit","text":"Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"3. Documents de formation sur la carte micro:bit"},{"location":"microbit/vittascience/","text":"D\u00e9couvrir la carte micro:bit 1. Qu'est qu'une carte micro:bit ? La carte BBC micro:bit est une carte micro-contr\u00f4leur qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles. 2. Programmer la carte micro:bit Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch. 2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs} 2.2 Programmer la carte avec Scratch L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer 2.3 Programmer la carte micro:bit en Python Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019. 3. Documents de formation sur la carte micro:bit Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"Programmer la carte sur Vittascience"},{"location":"microbit/vittascience/#decouvrir-la-carte-microbit","text":"","title":"D\u00e9couvrir la carte micro:bit"},{"location":"microbit/vittascience/#1-quest-quune-carte-microbit","text":"La carte BBC micro:bit est une carte micro-contr\u00f4leur qui a \u00e9t\u00e9 con\u00e7ue \u2014 notamment par la BBC \u2014 dans un objectif p\u00e9dagogique. Elle se programme \u00e0 l'aide de diff\u00e9rentes interfaces et diff\u00e9rents langages, permettant \u00e0 des \u00e9l\u00e8ves de tous niveaux d\u2019aborder la robotique et d'interagir avec le monde r\u00e9el. Elle comporte : 25 LEDs, deux boutons A et B programmables, un bouton de r\u00e9initialisation, des capteurs de lumi\u00e8re et de temp\u00e9rature, des capteurs de mouvements (acc\u00e9l\u00e9rom\u00e8tre et boussole), des broches de connexion Les programmes se transf\u00e8rent dans la carte depuis un ordinateur \u00e0 l'aide d'un c\u00e2ble USB connect\u00e9 au port micro-USB ou sans fil par Bluetooth. Une liaison radio est \u00e9galement disponible pour faire communiquer plusieurs cartes micro:bit entre elles. L'alimentation se fait par le port micro-USB lorsqu'il est connect\u00e9 \u00e0 un ordinateur ou \u00e0 l'aide de piles.","title":"1. Qu'est qu'une carte micro:bit ?"},{"location":"microbit/vittascience/#2-programmer-la-carte-microbit","text":"Plusieurs interfaces permettent de programmer la carte, dans diff\u00e9rents langages. Deux interfaces sont actuellement d\u00e9velopp\u00e9es et qualifi\u00e9es d' officielles par le projet micro:bit : les blocs JavaScript de MakeCode et Python. En parall\u00e8le, d'autres \u00e9diteurs sont r\u00e9alis\u00e9s de fa\u00e7on ind\u00e9pendante pour programmer la carte micro:bit, dont l'interface s'appuyant sur Scratch.","title":"2. Programmer la carte micro:bit"},{"location":"microbit/vittascience/#21-programmer-la-carte-avec-lediteur-blocks-de-makecode-pour-microbit","text":"Cette interface , d\u00e9velopp\u00e9e par MakeCode en partenariat avec micro:bit, se trouve en ligne et s'utilise directement dans un navigateur. Elle est sans doute id\u00e9ale pour d\u00e9buter : aucun pr\u00e9-requis n'est n\u00e9cessaire, et on peut param\u00e9trer l'affichage en fran\u00e7ais. L'utilisateur manipule et emboite des blocs pour cr\u00e9er son programme. Celui-ci est ensuite \u00e0 t\u00e9l\u00e9charger pour \u00eatre copi\u00e9 dans la carte micro:bit. Le format du fichier t\u00e9l\u00e9charg\u00e9 est .hex : c'est \u00e0 la fois le fichier \u00e0 copier dans la carte pour qu'elle l'ex\u00e9cute et celui \u00e0 sauvegarder pour ouvrir ult\u00e9rieurement le programme dans l'\u00e9diteur. Depuis la version 249 du firmware , le navigateur Chrome (versions 65 et +) propose d'appairer la carte, permettant le t\u00e9l\u00e9chargement du programme en un clic, en utilisant la norme WebUSB. Le navigateur conserve par d\u00e9faut les donn\u00e9es des programmes r\u00e9alis\u00e9s et une ouverture ult\u00e9rieure de l'\u00e9diteur affiche le dernier programme par d\u00e9faut. image \u00e0 ins\u00e9rer Cette interface dispose d'un simulateur de la carte micro:bit qui permet d'observer le fonctionnement du programme et effectuer les premi\u00e8res corrections. On trouve de nombreux [exemples de r\u00e9f\u00e9rence-> https://makecode.microbit.org/reference ] sur le site de l'\u00e9diteur, ainsi qu'un [guide de d\u00e9marrage rapide-> https://microbit.org/fr/guide/quick/ ]. La commission Inter IREM TICE a publi\u00e9 un [guide-> http://www.univ-irem.fr/IMG/pdf/microbit-tomcac1.pdf ] (19 pages, pdf) intitul\u00e9 {Carte micro-contr\u00f4leur micro:bit, tome 1 - Prise en main et programmation par blocs}","title":"2.1 Programmer la carte avec l'\u00e9diteur Blocks de MakeCode pour micro:bit"},{"location":"microbit/vittascience/#22-programmer-la-carte-avec-scratch","text":"L'[interface de programmation Scratch-> https://beta.scratch.mit.edu ] est l'un des [{\u00e9diteurs tiers}-> https://microbit.org/fr/code-alternative-editors/ ] de micro:bit. Elle s'appuie sur la version Scratch 3 et s'utilise dans un navigateur, sur ordinateur. La connexion avec la carte micro:bit utilise le bluetooth. L'installation de l'interface compl\u00e8te est un peu plus longue que pour les autres interfaces, mais le t\u00e9l\u00e9chargement de chacune des versions du programme r\u00e9alis\u00e9 est imm\u00e9diat, gr\u00e2ce \u00e0 la liaison bluetooth. Un seul fichier .hex est \u00e0 t\u00e9l\u00e9charger sur la carte au d\u00e9but, et il s'agit toujours du m\u00eame fichier. Ensuite l'ex\u00e9cution du code se fait comme habituellement dans Scratch : double-clic sur un bloc d'instructions, drapeau vert, etc. Lancer {Scratch Link}, \u00e0 installer au pr\u00e9alable [(lien de t\u00e9l\u00e9chargement et instructions) -> https://scratch.mit.edu/microbit ] Connecter la carte \u00e0 l'aide du c\u00e2ble USB et copier-glisser le code .hex du fichier scratch-microbit.hex sur la carte micro:bit Alimenter la carte micro:bit, \u00e0 l'aide de piles ou du c\u00e2ble USB. Ouvrir dans un navigateur l'[interface de programmation Scratch 3-> https://beta.scratch.mit.edu ] Cliquer sur l'ic\u00f4ne d'ajout d'extension et choisir l'extension {micro:bit}. Choisir ensuite la carte micro:bit \u00e0 connecter. Dix nouveaux blocs d'instructions apparaissent pour programmer la carte. (Toutes les fonctionnalit\u00e9s ne sont pas encore accessibles.) image \u00e0 ins\u00e9rer La carte peut \u00eatre programm\u00e9e en utilisant ses propres capteurs et actionneurs, mais la possibilit\u00e9 suppl\u00e9mentaire offerte par Scratch, c'est que la carte peut \u00eatre utilis\u00e9e pour interagir avec des lutins classiques de Scratch sur \u00e9cran. Par exemple, dans le programme [Crabe et diamants-> https://scratch.mit.edu/projects/281329767/ ] disponible en ligne, le crabe se d\u00e9place horizontalement en fonction de l'inclinaison de la carte, et tente d'attraper des diamants lorsqu'on appuie sur les boutons de la carte. Sur cet autre exemple, [Roulis et tangage-> https://scratch.mit.edu/projects/281208861/ ], les valeurs des inclinaisons de la carte sont utilis\u00e9es pour une visualisation en temps r\u00e9el : une \"courbe\" donne l'angle de tangage (avant-arri\u00e8re) et l'autre donne l'angle de roulis (gauche-droite). image \u00e0 ins\u00e9rer image \u00e0 ins\u00e9rer","title":"2.2 Programmer la carte avec Scratch"},{"location":"microbit/vittascience/#23-programmer-la-carte-microbit-en-python","text":"Plusieurs interfaces co-existent pour programmer la carte en Python : un [article->art232] est d\u00e9di\u00e9 \u00e0 la pr\u00e9sentation de ces diff\u00e9rentes interfaces, susceptibles d'int\u00e9resser les enseignants de lyc\u00e9e pour l'enseignement de sciences du num\u00e9rique et technologie (SNT), suivi par tous les \u00e9l\u00e8ves de seconde g\u00e9n\u00e9rale et technologique \u00e0 partir de septembre 2019.","title":"2.3 Programmer la carte micro:bit en Python"},{"location":"microbit/vittascience/#3-documents-de-formation-sur-la-carte-microbit","text":"Lancers de d\u00e9s (MakeCode et python) : Labyrinthe (Scratch) : [projet initial-> https://scratch.mit.edu/projects/355161324/ ] [\u00e9nonc\u00e9-> https://ncloud.zaclys.com/index.php/s/Ji5HrjqEckfjnxA ] [ exemples de programmes-> https://ncloud.zaclys.com/index.php/s/WNR6NgbM89gDTyj ]","title":"3. Documents de formation sur la carte micro:bit"},{"location":"nsi_premiere/qcm_nsi/","text":"QCM NSI G\u00e9n\u00e9rateur de QCM portant sur l'un des sept th\u00e8mes du programme de 1ere NSI.","title":"QCM NSI"},{"location":"nsi_premiere/qcm_nsi/#qcm-nsi","text":"G\u00e9n\u00e9rateur de QCM portant sur l'un des sept th\u00e8mes du programme de 1ere NSI.","title":"QCM NSI"},{"location":"nsi_premiere/tour_de_cartes/","text":"Un tour de cartes D'apr\u00e8s un exercice du concours Castor informatique suisse Le jeu de 7 familles de l'informatique est un jeu de cartes compos\u00e9 de 42 cartes r\u00e9parties en 7 familles, repr\u00e9sentant des personnes c\u00e9l\u00e8bres dans l'histoire de l'informatique. Il a \u00e9t\u00e9 publi\u00e9 par interstice.info . On aligne quelques cartes du jeu sur une seule rang\u00e9e et on consid\u00e8re la r\u00e8gle suivante : Lors d\u2019un tour, on examine les cartes en commen\u00e7ant par celle la plus \u00e0 droite : \u2014 Si la carte est face vers le haut, on la retourne \u00e0 l\u2019envers et s'il reste des cartes \u00e0 sa gauche, on passe \u00e0 la carte suivante. \u2014 Si la carte est face vers le bas, on la retourne \u00e0 l\u2019endroit et on ne fait rien sur les cartes \u00e0 sa gauche. Voici un exemple : Situation de d\u00e9part : Situation apr\u00e8s un tour : Voici l'\u00e9nonc\u00e9 du probl\u00e8me : On extrait la famille Algorithmes & programmation du jeu (t\u00e9l\u00e9charger les cartes \u00e0 imprimer ) et on range les 6 cartes, face vers le haut, dans l'ordre croissant, de droite \u00e0 gauche (elles sont num\u00e9rot\u00e9es en binaire de 001 \u00e0 110). Puis on les retourne toutes. On applique alors la r\u00e8gle pr\u00e9c\u00e9dente pendant 16 tours. Question Quelle(s) carte(s) est(sont) face vers le haut \u00e0 l'issue des 16 tours ?","title":"Tour de cartes"},{"location":"nsi_premiere/tour_de_cartes/#un-tour-de-cartes","text":"D'apr\u00e8s un exercice du concours Castor informatique suisse Le jeu de 7 familles de l'informatique est un jeu de cartes compos\u00e9 de 42 cartes r\u00e9parties en 7 familles, repr\u00e9sentant des personnes c\u00e9l\u00e8bres dans l'histoire de l'informatique. Il a \u00e9t\u00e9 publi\u00e9 par interstice.info . On aligne quelques cartes du jeu sur une seule rang\u00e9e et on consid\u00e8re la r\u00e8gle suivante : Lors d\u2019un tour, on examine les cartes en commen\u00e7ant par celle la plus \u00e0 droite : \u2014 Si la carte est face vers le haut, on la retourne \u00e0 l\u2019envers et s'il reste des cartes \u00e0 sa gauche, on passe \u00e0 la carte suivante. \u2014 Si la carte est face vers le bas, on la retourne \u00e0 l\u2019endroit et on ne fait rien sur les cartes \u00e0 sa gauche. Voici un exemple : Situation de d\u00e9part : Situation apr\u00e8s un tour : Voici l'\u00e9nonc\u00e9 du probl\u00e8me : On extrait la famille Algorithmes & programmation du jeu (t\u00e9l\u00e9charger les cartes \u00e0 imprimer ) et on range les 6 cartes, face vers le haut, dans l'ordre croissant, de droite \u00e0 gauche (elles sont num\u00e9rot\u00e9es en binaire de 001 \u00e0 110). Puis on les retourne toutes. On applique alors la r\u00e8gle pr\u00e9c\u00e9dente pendant 16 tours. Question Quelle(s) carte(s) est(sont) face vers le haut \u00e0 l'issue des 16 tours ?","title":"Un tour de cartes"},{"location":"python/boucles_bornees/","text":"Boucles born\u00e9es Les boucles born\u00e9es servent \u00e0 ex\u00e9cuter certaines instructions d'un programme de mani\u00e8re r\u00e9p\u00e9titive, un nombre pr\u00e9d\u00e9fini de fois. Par exemple pour r\u00e9p\u00e9ter quatre fois un bloc d'instructions, on peut \u00e9crire : for i in range ( 4 ): bloc d 'instructions Exemple : for i in range ( 4 ): print ( \"Bienvenue !\" ) Bienvenue ! Bienvenue ! Bienvenue ! Bienvenue ! En premi\u00e8re approche, on peut se contenter de la syntaxe : for i in range ( n ) : bloc d 'instructions pour r\u00e9p\u00e9ter n fois un bloc d'instructions. Mais les deux instructions que cette syntaxe combine : for ... in et range() permettent de nombreuses possibilit\u00e9s. L'instruction for La boucle born\u00e9e (ou instruction for ) permet d\u2019it\u00e9rer sur les \u00e9l\u00e9ments d\u2019une s\u00e9quence (liste, chaine de caract\u00e8res, etc.) dans l'ordre dans lequel les \u00e9l\u00e9ments apparaissent dans la s\u00e9quence. Exemple : liste_mots = [ 'anthracite' , 'blanc' , 'cyan' ] for mot in liste_mots : print ( mot ) anthracite blanc cyan La syntaxe de la boucle for est : for iterateur in sequence : instructions L'it\u00e9rateur est une variable \u00e0 laquelle il faut donner un nom, et qui prend successivement les valeurs des \u00e9l\u00e9ments de la s\u00e9quence. Le bloc d'instructions \u00e0 ex\u00e9cuter dans le corps de la boucle est \u00e0 indenter. La fonction range() Pour it\u00e9rer sur une suite de nombres, on utilise la fonction range() . Exemple : for i in range ( 4 ): print ( i , i ** 2 ) 0 0 1 1 2 4 3 9 Ici i prend successivement les valeurs 0, 1, 2, puis 3 et pour chaque valeur de i on affiche i et son carr\u00e9. La syntaxe g\u00e9n\u00e9rale est range(debut, fin, pas) . La liste des valeurs g\u00e9n\u00e9r\u00e9es commence avec la valeur debut ; les valeurs suivantes sont g\u00e9n\u00e9r\u00e9es en augmentant de la valeur pas et la liste s'arr\u00eate juste avant d'atteindre ou d\u00e9passer la valeur fin . debut est un param\u00e8tre facultatif : sa valeur par d\u00e9faut est 0 . pas est aussi un param\u00e8tre facultatif. Il vaut 1 par d\u00e9faut ; il faut donner les 3 param\u00e8tres de range() pour modifier sa valeur. La syntaxe range(valeur) est donc \u00e9quivalente \u00e0 range(0, valeur, 1) et g\u00e9n\u00e8re la liste les entiers de 0 \u00e0 valeur - 1. Exemple : range(10) g\u00e9n\u00e8re la liste 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 range(4, 10) g\u00e9n\u00e8re la liste 4, 5, 6, 7, 8, 9 range(1, 12, 3) g\u00e9n\u00e8re la liste 1, 4, 7, 10 range(5, -10, -3) g\u00e9n\u00e8re la liste 5, 2, -1, -4, -7 Info L'objet renvoy\u00e9 par range() se comporte presque comme une liste, mais n'en est pas une. Cet objet g\u00e9n\u00e8re les \u00e9l\u00e9ments de la s\u00e9quence au fur et \u00e0 mesure de l'it\u00e9ration, sans r\u00e9ellement produire la liste en tant que telle. It\u00e9rer sur les indices d'une s\u00e9quence Pour it\u00e9rer sur les indices d'une s\u00e9quence, on peut combiner les fonctions range() et len() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for i in range ( len ( couleurs )): print ( i , couleurs [ i ]) 0 anthracite 1 blanc 2 cyan Mais il existe une instruction sp\u00e9cifique pour cela : dans une boucle sur une s\u00e9quence, l'indice et la valeur correspondante peuvent \u00eatre r\u00e9cup\u00e9r\u00e9s en m\u00eame temps en utilisant la fonction enumerate() . Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for indice , valeur in enumerate ( couleurs ): print ( indice , valeur ) 0 anthracite 1 blanc 2 cyan It\u00e9rer sur plusieurs s\u00e9quences Pour faire une boucle sur deux s\u00e9quences ou plus en m\u00eame temps, les \u00e9l\u00e9ments peuvent \u00eatre associ\u00e9s en utilisant la fonction zip() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] codes_hex = [ '#303030' , '#FFFFFF' , '#00FFFF' ] for couleur , code in zip ( couleurs , codes_hex ): print ( couleur , code ) anthracite #303030 blanc #FFFFFF cyan #00FFFF","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees/#boucles-bornees","text":"Les boucles born\u00e9es servent \u00e0 ex\u00e9cuter certaines instructions d'un programme de mani\u00e8re r\u00e9p\u00e9titive, un nombre pr\u00e9d\u00e9fini de fois. Par exemple pour r\u00e9p\u00e9ter quatre fois un bloc d'instructions, on peut \u00e9crire : for i in range ( 4 ): bloc d 'instructions Exemple : for i in range ( 4 ): print ( \"Bienvenue !\" ) Bienvenue ! Bienvenue ! Bienvenue ! Bienvenue ! En premi\u00e8re approche, on peut se contenter de la syntaxe : for i in range ( n ) : bloc d 'instructions pour r\u00e9p\u00e9ter n fois un bloc d'instructions. Mais les deux instructions que cette syntaxe combine : for ... in et range() permettent de nombreuses possibilit\u00e9s.","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees/#linstruction-for","text":"La boucle born\u00e9e (ou instruction for ) permet d\u2019it\u00e9rer sur les \u00e9l\u00e9ments d\u2019une s\u00e9quence (liste, chaine de caract\u00e8res, etc.) dans l'ordre dans lequel les \u00e9l\u00e9ments apparaissent dans la s\u00e9quence. Exemple : liste_mots = [ 'anthracite' , 'blanc' , 'cyan' ] for mot in liste_mots : print ( mot ) anthracite blanc cyan La syntaxe de la boucle for est : for iterateur in sequence : instructions L'it\u00e9rateur est une variable \u00e0 laquelle il faut donner un nom, et qui prend successivement les valeurs des \u00e9l\u00e9ments de la s\u00e9quence. Le bloc d'instructions \u00e0 ex\u00e9cuter dans le corps de la boucle est \u00e0 indenter.","title":"L'instruction for"},{"location":"python/boucles_bornees/#la-fonction-range","text":"Pour it\u00e9rer sur une suite de nombres, on utilise la fonction range() . Exemple : for i in range ( 4 ): print ( i , i ** 2 ) 0 0 1 1 2 4 3 9 Ici i prend successivement les valeurs 0, 1, 2, puis 3 et pour chaque valeur de i on affiche i et son carr\u00e9. La syntaxe g\u00e9n\u00e9rale est range(debut, fin, pas) . La liste des valeurs g\u00e9n\u00e9r\u00e9es commence avec la valeur debut ; les valeurs suivantes sont g\u00e9n\u00e9r\u00e9es en augmentant de la valeur pas et la liste s'arr\u00eate juste avant d'atteindre ou d\u00e9passer la valeur fin . debut est un param\u00e8tre facultatif : sa valeur par d\u00e9faut est 0 . pas est aussi un param\u00e8tre facultatif. Il vaut 1 par d\u00e9faut ; il faut donner les 3 param\u00e8tres de range() pour modifier sa valeur. La syntaxe range(valeur) est donc \u00e9quivalente \u00e0 range(0, valeur, 1) et g\u00e9n\u00e8re la liste les entiers de 0 \u00e0 valeur - 1. Exemple : range(10) g\u00e9n\u00e8re la liste 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 range(4, 10) g\u00e9n\u00e8re la liste 4, 5, 6, 7, 8, 9 range(1, 12, 3) g\u00e9n\u00e8re la liste 1, 4, 7, 10 range(5, -10, -3) g\u00e9n\u00e8re la liste 5, 2, -1, -4, -7 Info L'objet renvoy\u00e9 par range() se comporte presque comme une liste, mais n'en est pas une. Cet objet g\u00e9n\u00e8re les \u00e9l\u00e9ments de la s\u00e9quence au fur et \u00e0 mesure de l'it\u00e9ration, sans r\u00e9ellement produire la liste en tant que telle.","title":"La fonction range()"},{"location":"python/boucles_bornees/#iterer-sur-les-indices-dune-sequence","text":"Pour it\u00e9rer sur les indices d'une s\u00e9quence, on peut combiner les fonctions range() et len() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for i in range ( len ( couleurs )): print ( i , couleurs [ i ]) 0 anthracite 1 blanc 2 cyan Mais il existe une instruction sp\u00e9cifique pour cela : dans une boucle sur une s\u00e9quence, l'indice et la valeur correspondante peuvent \u00eatre r\u00e9cup\u00e9r\u00e9s en m\u00eame temps en utilisant la fonction enumerate() . Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] for indice , valeur in enumerate ( couleurs ): print ( indice , valeur ) 0 anthracite 1 blanc 2 cyan","title":"It\u00e9rer sur les indices d'une s\u00e9quence"},{"location":"python/boucles_bornees/#iterer-sur-plusieurs-sequences","text":"Pour faire une boucle sur deux s\u00e9quences ou plus en m\u00eame temps, les \u00e9l\u00e9ments peuvent \u00eatre associ\u00e9s en utilisant la fonction zip() : Exemple : couleurs = [ 'anthracite' , 'blanc' , 'cyan' ] codes_hex = [ '#303030' , '#FFFFFF' , '#00FFFF' ] for couleur , code in zip ( couleurs , codes_hex ): print ( couleur , code ) anthracite #303030 blanc #FFFFFF cyan #00FFFF","title":"It\u00e9rer sur plusieurs s\u00e9quences"},{"location":"python/boucles_bornees_exercices/","text":"Exercices : boucles born\u00e9es 1. Affichage Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne. Exercice 1.1 Afficher sur une ligne \"la table de multiplication de 8\", c'est \u00e0 dire les produits : 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 . Exercice 1.2 Afficher sur 10 lignes les \"tables de multiplication\" des entiers de 1 \u00e0 10. 2. Somme Exercice 2.1 Calculer la somme des entiers de 1 \u00e0 100. Exercice 2.2 Calculer la somme des cubes des entiers de 1 \u00e0 100. Comparer le r\u00e9sultat au carr\u00e9 de la somme des entiers de 1 \u00e0 100. 3. Calculs en boucle Exercice 3.1 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 50 ): resultat = resultat + 2 Exercice 3.2 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 5 ): resultat = resultat * 2 Exercice 3.3 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 1 , 5 ): resultat = resultat + i Exercice 3.4 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 1 , 5 ): resultat = resultat * i 4. Trac\u00e9s en boucle Exercice 4.1 R\u00e9aliser la figure suivante : Exercice 4.2 R\u00e9aliser la figure suivante : Exercice 4.3 R\u00e9aliser la figure suivante : Exercice 4.4 R\u00e9aliser la figure suivante : Exercice 4.5 R\u00e9aliser la figure suivante : Exercice 4.6 R\u00e9aliser la figure suivante : Exercice 4.7 R\u00e9aliser la figure suivante :","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees_exercices/#exercices-boucles-bornees","text":"","title":"Exercices : boucles born\u00e9es"},{"location":"python/boucles_bornees_exercices/#1-affichage","text":"Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne.","title":"1. Affichage"},{"location":"python/boucles_bornees_exercices/#exercice-11","text":"Afficher sur une ligne \"la table de multiplication de 8\", c'est \u00e0 dire les produits : 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 1 \\times 8, 2 \\times 8, \\ldots, 10 \\times 8 .","title":"Exercice 1.1"},{"location":"python/boucles_bornees_exercices/#exercice-12","text":"Afficher sur 10 lignes les \"tables de multiplication\" des entiers de 1 \u00e0 10.","title":"Exercice 1.2"},{"location":"python/boucles_bornees_exercices/#2-somme","text":"","title":"2. Somme"},{"location":"python/boucles_bornees_exercices/#exercice-21","text":"Calculer la somme des entiers de 1 \u00e0 100.","title":"Exercice 2.1"},{"location":"python/boucles_bornees_exercices/#exercice-22","text":"Calculer la somme des cubes des entiers de 1 \u00e0 100. Comparer le r\u00e9sultat au carr\u00e9 de la somme des entiers de 1 \u00e0 100.","title":"Exercice 2.2"},{"location":"python/boucles_bornees_exercices/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_bornees_exercices/#exercice-31","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 50 ): resultat = resultat + 2","title":"Exercice 3.1"},{"location":"python/boucles_bornees_exercices/#exercice-32","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 5 ): resultat = resultat * 2","title":"Exercice 3.2"},{"location":"python/boucles_bornees_exercices/#exercice-33","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 0 for i in range ( 1 , 5 ): resultat = resultat + i","title":"Exercice 3.3"},{"location":"python/boucles_bornees_exercices/#exercice-34","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? resultat = 1 for i in range ( 1 , 5 ): resultat = resultat * i","title":"Exercice 3.4"},{"location":"python/boucles_bornees_exercices/#4-traces-en-boucle","text":"","title":"4. Trac\u00e9s en boucle"},{"location":"python/boucles_bornees_exercices/#exercice-41","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.1"},{"location":"python/boucles_bornees_exercices/#exercice-42","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.2"},{"location":"python/boucles_bornees_exercices/#exercice-43","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.3"},{"location":"python/boucles_bornees_exercices/#exercice-44","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.4"},{"location":"python/boucles_bornees_exercices/#exercice-45","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.5"},{"location":"python/boucles_bornees_exercices/#exercice-46","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.6"},{"location":"python/boucles_bornees_exercices/#exercice-47","text":"R\u00e9aliser la figure suivante :","title":"Exercice 4.7"},{"location":"python/boucles_bornees_imbriquees_questions/","text":"Questions : boucles born\u00e9es imbriqu\u00e9es 1. Trac\u00e9 de motifs Info L'instruction print('*') affiche un caract\u00e8re * et passe \u00e0 la ligne suivante. L'instruction print('*', end='') affiche un caract\u00e8re * et ne passe pas \u00e0 la ligne. L'instruction print() n'affiche aucun caract\u00e8re et passe \u00e0 la ligne. Question 1.1 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? **** **** **** **** **** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 4 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 4 ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 4 \u00e9toiles. Question 1.2 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? * ** *** **** ***** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 1 \u00e0 5 \u00e9toiles. Le nombre d'\u00e9toiles trac\u00e9es vaut 1 sur la premi\u00e8re ligne, 2 sur la 2e, etc. Seule la boucle for j in range(i + 1) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4. Question 1.3 Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? ***** **** *** ** * Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 5 \u00e0 1 \u00e9toile(s). Le nombre d'\u00e9toiles trac\u00e9es vaut 5 sur la premi\u00e8re ligne, 4 sur la 2e, etc. Seule la boucle for j in range(5 - i) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4. 2. Questions num\u00e9riques Question 2.1 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( 3 ): total = total + 1 Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i : - j prend les valeurs 0 \u00e0 2 soit 3 valeurs. - La variable total est augment\u00e9e 3 fois de la quantit\u00e9 1 Finalement, total vaut 0 + 4*3 = 12 Question 2.2 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( i ): total = total + i Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 la valeur de i , soit de 1. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 2 fois de la valeur de i , soit de 2*2 = 4. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 3 fois de la valeur de i , soit de 3*3 = 9. Finalement, total vaut 0 + 1 + 2*2 + 3*3 = 14. valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 i = 0 X X X i = 1 1 X X i = 2 2 2 X i = 3 3 3 3 Question 2.3 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 5 ): for j in range ( i ): total = total + j Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 4. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 de 0. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 = 1. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 = 3. Quand i = 4 , j prend les valeurs 0, 1, 2 et 3, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 + 3 = 6 Finalement, total vaut 0 + 1 + 3 + 6 = 10 valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 j = 3 i = 0 X X X X i = 1 0 X X X i = 2 0 1 X X i = 3 0 1 2 X i = 4 0 1 2 3 3. Trac\u00e9s en boucles Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 3.1 Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_carre in range ( 4 ) : for nb_cote in range ( 3 ) : t . forward ( 100 ) t . left ( 90 ) t . right ( 120 ) Boucle B : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 30 ) Boucle C : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 120 ) t . left ( 90 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 carr\u00e9s \u00e0 tracer ( range(3) ) et chaque carr\u00e9 poss\u00e8de 4 c\u00f4t\u00e9s ( range(4) ). Les angles du carr\u00e9 font 90\u00b0 et chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu. Question 3.2 Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle B : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle C : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ) et chaque hexagone poss\u00e8de 6 c\u00f4t\u00e9s ( range(6) ). Les angles de l'hexagone font 120\u00b0 (donc la tortue doit pivoter de 180 - 120 = 60\u00b0) et chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Boucles born\u00e9es imbriqu\u00e9es"},{"location":"python/boucles_bornees_imbriquees_questions/#questions-boucles-bornees-imbriquees","text":"","title":"Questions : boucles born\u00e9es imbriqu\u00e9es"},{"location":"python/boucles_bornees_imbriquees_questions/#1-trace-de-motifs","text":"Info L'instruction print('*') affiche un caract\u00e8re * et passe \u00e0 la ligne suivante. L'instruction print('*', end='') affiche un caract\u00e8re * et ne passe pas \u00e0 la ligne. L'instruction print() n'affiche aucun caract\u00e8re et passe \u00e0 la ligne.","title":"1. Trac\u00e9 de motifs"},{"location":"python/boucles_bornees_imbriquees_questions/#question-11","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? **** **** **** **** **** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 4 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 4 ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 4 \u00e9toiles.","title":"Question 1.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-12","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? * ** *** **** ***** Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 1 \u00e0 5 \u00e9toiles. Le nombre d'\u00e9toiles trac\u00e9es vaut 1 sur la premi\u00e8re ligne, 2 sur la 2e, etc. Seule la boucle for j in range(i + 1) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4.","title":"Question 1.2"},{"location":"python/boucles_bornees_imbriquees_questions/#question-13","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher le motif ci-dessous ? ***** **** *** ** * Programme A : for i in range ( 5 ): for j in range ( i ): print ( '*' , end = '' ) print () Programme B : for i in range ( 5 ): for j in range ( i + 1 ): print ( '*' , end = '' ) print () Programme C : for i in range ( 5 ): for j in range ( 5 ): print ( '*' , end = '' ) print () Programme D : for i in range ( 5 ): for j in range ( 5 - i ): print ( '*' , end = '' ) print () Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le motif comporte 5 lignes, chacune \u00e9tant compos\u00e9e de 5 \u00e0 1 \u00e9toile(s). Le nombre d'\u00e9toiles trac\u00e9es vaut 5 sur la premi\u00e8re ligne, 4 sur la 2e, etc. Seule la boucle for j in range(5 - i) permet de tracer le nombre correct d'\u00e9toiles, lorsque i varie de 0 \u00e0 4.","title":"Question 1.3"},{"location":"python/boucles_bornees_imbriquees_questions/#2-questions-numeriques","text":"","title":"2. Questions num\u00e9riques"},{"location":"python/boucles_bornees_imbriquees_questions/#question-21","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( 3 ): total = total + 1 Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i : - j prend les valeurs 0 \u00e0 2 soit 3 valeurs. - La variable total est augment\u00e9e 3 fois de la quantit\u00e9 1 Finalement, total vaut 0 + 4*3 = 12","title":"Question 2.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-22","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): for j in range ( i ): total = total + i Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 3. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 la valeur de i , soit de 1. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 2 fois de la valeur de i , soit de 2*2 = 4. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 3 fois de la valeur de i , soit de 3*3 = 9. Finalement, total vaut 0 + 1 + 2*2 + 3*3 = 14. valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 i = 0 X X X i = 1 1 X X i = 2 2 2 X i = 3 3 3 3","title":"Question 2.2"},{"location":"python/boucles_bornees_imbriquees_questions/#question-23","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 5 ): for j in range ( i ): total = total + j Propositions de r\u00e9ponses 10 12 14 20 Solution 10 12 14 20 Arguments i prend les valeurs 0 \u00e0 4. Quand i = 0 , j ne prend aucune valeur et total n'est pas augment\u00e9. Quand i = 1 , j prend la valeur 0 et total est augment\u00e9 de 0. Quand i = 2 , j prend les valeurs 0 puis 1, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 = 1. Quand i = 3 , j prend les valeurs 0, 1 et 2, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 = 3. Quand i = 4 , j prend les valeurs 0, 1, 2 et 3, et total est augment\u00e9 \u00e0 chaque fois de la valeur de j , soit de 0 + 1 + 2 + 3 = 6 Finalement, total vaut 0 + 1 + 3 + 6 = 10 valeurs ajout\u00e9es \u00e0 total j = 0 j = 1 j = 2 j = 3 i = 0 X X X X i = 1 0 X X X i = 2 0 1 X X i = 3 0 1 2 X i = 4 0 1 2 3","title":"Question 2.3"},{"location":"python/boucles_bornees_imbriquees_questions/#3-traces-en-boucles","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"3. Trac\u00e9s en boucles"},{"location":"python/boucles_bornees_imbriquees_questions/#question-31","text":"Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_carre in range ( 4 ) : for nb_cote in range ( 3 ) : t . forward ( 100 ) t . left ( 90 ) t . right ( 120 ) Boucle B : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 30 ) Boucle C : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 90 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_carre in range ( 3 ) : for nb_cote in range ( 4 ) : t . forward ( 100 ) t . left ( 120 ) t . left ( 90 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 carr\u00e9s \u00e0 tracer ( range(3) ) et chaque carr\u00e9 poss\u00e8de 4 c\u00f4t\u00e9s ( range(4) ). Les angles du carr\u00e9 font 90\u00b0 et chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.1"},{"location":"python/boucles_bornees_imbriquees_questions/#question-32","text":"Question Parmi les boucles imbriqu\u00e9es suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle B : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 120 ) t . left ( 60 ) Boucle C : t = Turtle () for nb_poly in range ( 6 ) : for nb_cote in range ( 3 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Boucle D : t = Turtle () for nb_poly in range ( 3 ) : for nb_cote in range ( 6 ) : t . forward ( 80 ) t . left ( 60 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ) et chaque hexagone poss\u00e8de 6 c\u00f4t\u00e9s ( range(6) ). Les angles de l'hexagone font 120\u00b0 (donc la tortue doit pivoter de 180 - 120 = 60\u00b0) et chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.2"},{"location":"python/boucles_bornees_questions/","text":"Questions : boucles born\u00e9es 1. Affichage Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne. Question 1.1 Question Parmi les 4 boucles suivantes, lesquelles permettent d'afficher sur une seule ligne les entiers de 1 \u00e0 10, s\u00e9par\u00e9s par un espace et rang\u00e9s dans l'ordre croissant ? 1 2 3 4 5 6 7 8 9 10 Boucle A : for i in range ( 10 ): print ( i ) Boucle B : for i in range ( 10 ): print ( i , end = ' ' ) Boucle C : for i in range ( 1 , 11 ): print ( i , end = ' ' ) Boucle D : for i in range ( 10 ): print ( i + 1 , end = ' ' ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, celles qui conviennent consistent : - soit \u00e0 faire varier i de 1 \u00e0 10 ( range(1,11) ) et afficher i ; - soit \u00e0 faire varier i de 0 \u00e0 9 ( range(10) ) et afficher i + 1 . Question 1.2 Question mots = [ 'syst\u00e8me' , 'syst\u00e9matique' , 'syst\u00e9mique' ] Parmi les 4 boucles suivantes, lesquelles permettent d'afficher chaque mot de la liste mots ainsi que son nombre de lettres ? syst\u00e8me comporte 7 lettres syst\u00e9matique comporte 12 lettres syst\u00e9mique comporte 10 lettres Boucle A : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , i , \"lettres\" ) Boucle B : for mot in mots : print ( mot , \"comporte\" , len ( mot ), \"lettres\" ) Boucle C : for mot in mots : print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Boucle D : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La solution B parcourt directement les \u00e9l\u00e9ments de la liste mots et affiche leur valeur et leur nombre de lettres, \u00e0 l'aide de la fonction len() . La solution D parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et affiche leur valeur et leur nombre de lettres. 2. Somme Question 2.1 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 98 , 76 , 54 , 32 , 10 ] Parmi les 4 programmes suivants, lesquels permettent d'afficher la somme des valeurs de la liste nombres ? Programme A : for i in range ( len ( nombres )): somme = 0 somme = somme + nombres [ i ] print ( somme ) Programme B : somme = 0 for i in range ( len ( nombres )): somme = somme + nombres [ i ] print ( somme ) Programme C : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Programme D : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution B parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et ajoute chacun d'eux \u00e0 la variable somme . La solution D parcourt directement les \u00e9l\u00e9ments de la liste et ajoute chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet de la liste de valeurs. Question 2.2 Question Parmi les 4 programmes suivants, lequel permet d'afficher la somme des carr\u00e9s des entiers de 1 \u00e0 10 ? Programme A : for i in range ( 11 ): print ( i ** 2 ) Programme B : somme = 0 for i in range ( 1 , 10 ): somme = somme + i ** 2 print ( somme ) Programme C : somme = 0 for i in range ( 1 , 11 ): somme = somme + i ** 2 print ( somme ) Programme D : somme = 0 for i in range ( 11 ): somme = i ** 2 print ( somme ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution C parcourt la liste des entiers de 1 \u00e0 10 compris, et ajoute le carr\u00e9 de chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet des dix entiers. 3. Calculs en boucle Question 3.1 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + 3 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i , la variable total est augment\u00e9e de la quantit\u00e9 3. Finalement, total vaut 0 + 4*3 = 12 Question 3.2 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i . Finalement, total vaut 0 + 0 + 1 + 2 + 3 = 6. Question 3.3 Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i ** 2 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i 2 . Finalement, total vaut 0 + 1 + 4 + 9 = 14 4. Boucle avec une condition Question 4.1 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = - 1 for i in range ( len ( nombres )): if nombres [ i ] == cible : reponse = i Propositions de r\u00e9ponses -1 1 2 6 Solution -1 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres[i] == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc affect\u00e9e deux fois. En fin de boucle, la valeur de la variable est celle de la derni\u00e8re affectation, donc l'indice de la derni\u00e8re occurrence de 34 dans nombres . Question 4.2 Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = 0 for nombre in nombres : if nombre == cible : reponse = reponse + 1 Propositions de r\u00e9ponses 0 1 2 6 Solution 0 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc incr\u00e9ment\u00e9e deux fois. En fin de boucle, la valeur de la variable initialis\u00e9e \u00e0 0 est donc 2 . 5. Trac\u00e9s en boucle Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 5.1 Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 60 ) Boucle B : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 60 ) Boucle C : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 120 ) Boucle D : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 6 c\u00f4t\u00e9s et range(6) g\u00e9n\u00e8rera les entiers de 0 \u00e0 5, soit 6 entiers. Les angles \"internes\" de la figure sont de 120\u00b0, la tortue doit donc pivoter de 180 - 120 = 60\u00b0 entre 2 trac\u00e9s. Question 5.2 Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Le programme commence par les instructions suivantes : t = Turtle () # d\u00e9placement sans trac\u00e9 t . penup () t . setposition ( 75 , 150 ) t . pendown () Puis se termine par l'une des boucles suivantes : Boucle A : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 72 ) Boucle B : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 144 ) Boucle C : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 36 ) Boucle D : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 72 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 5 c\u00f4t\u00e9s et range(5) g\u00e9n\u00e8rera les entiers de 0 \u00e0 4, soit 5 entiers. Les angles \"internes\" des pointes de l'\u00e9toile sont de 36\u00b0, la tortue doit donc pivoter de 180 - 36 = 144\u00b0 entre 2 trac\u00e9s.","title":"Boucles born\u00e9es"},{"location":"python/boucles_bornees_questions/#questions-boucles-bornees","text":"","title":"Questions : boucles born\u00e9es"},{"location":"python/boucles_bornees_questions/#1-affichage","text":"Info L'instruction print('a') affiche le caract\u00e8re a et passe \u00e0 la ligne suivante. L'instruction print('a', end = ' ') affiche le caract\u00e8re 'a' suivi d'un espace et ne passe pas \u00e0 la ligne.","title":"1. Affichage"},{"location":"python/boucles_bornees_questions/#question-11","text":"Question Parmi les 4 boucles suivantes, lesquelles permettent d'afficher sur une seule ligne les entiers de 1 \u00e0 10, s\u00e9par\u00e9s par un espace et rang\u00e9s dans l'ordre croissant ? 1 2 3 4 5 6 7 8 9 10 Boucle A : for i in range ( 10 ): print ( i ) Boucle B : for i in range ( 10 ): print ( i , end = ' ' ) Boucle C : for i in range ( 1 , 11 ): print ( i , end = ' ' ) Boucle D : for i in range ( 10 ): print ( i + 1 , end = ' ' ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, celles qui conviennent consistent : - soit \u00e0 faire varier i de 1 \u00e0 10 ( range(1,11) ) et afficher i ; - soit \u00e0 faire varier i de 0 \u00e0 9 ( range(10) ) et afficher i + 1 .","title":"Question 1.1"},{"location":"python/boucles_bornees_questions/#question-12","text":"Question mots = [ 'syst\u00e8me' , 'syst\u00e9matique' , 'syst\u00e9mique' ] Parmi les 4 boucles suivantes, lesquelles permettent d'afficher chaque mot de la liste mots ainsi que son nombre de lettres ? syst\u00e8me comporte 7 lettres syst\u00e9matique comporte 12 lettres syst\u00e9mique comporte 10 lettres Boucle A : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , i , \"lettres\" ) Boucle B : for mot in mots : print ( mot , \"comporte\" , len ( mot ), \"lettres\" ) Boucle C : for mot in mots : print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Boucle D : for i in range ( len ( mots )): print ( mots [ i ], \"comporte\" , len ( mots [ i ]), \"lettres\" ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La solution B parcourt directement les \u00e9l\u00e9ments de la liste mots et affiche leur valeur et leur nombre de lettres, \u00e0 l'aide de la fonction len() . La solution D parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et affiche leur valeur et leur nombre de lettres.","title":"Question 1.2"},{"location":"python/boucles_bornees_questions/#2-somme","text":"","title":"2. Somme"},{"location":"python/boucles_bornees_questions/#question-21","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 98 , 76 , 54 , 32 , 10 ] Parmi les 4 programmes suivants, lesquels permettent d'afficher la somme des valeurs de la liste nombres ? Programme A : for i in range ( len ( nombres )): somme = 0 somme = somme + nombres [ i ] print ( somme ) Programme B : somme = 0 for i in range ( len ( nombres )): somme = somme + nombres [ i ] print ( somme ) Programme C : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Programme D : somme = 0 for valeur in nombres : somme = somme + valeur print ( somme ) Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution B parcourt la liste \u00e0 l'aide des indices des \u00e9l\u00e9ments, et ajoute chacun d'eux \u00e0 la variable somme . La solution D parcourt directement les \u00e9l\u00e9ments de la liste et ajoute chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet de la liste de valeurs.","title":"Question 2.1"},{"location":"python/boucles_bornees_questions/#question-22","text":"Question Parmi les 4 programmes suivants, lequel permet d'afficher la somme des carr\u00e9s des entiers de 1 \u00e0 10 ? Programme A : for i in range ( 11 ): print ( i ** 2 ) Programme B : somme = 0 for i in range ( 1 , 10 ): somme = somme + i ** 2 print ( somme ) Programme C : somme = 0 for i in range ( 1 , 11 ): somme = somme + i ** 2 print ( somme ) Programme D : somme = 0 for i in range ( 11 ): somme = i ** 2 print ( somme ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La valeur de la variable somme est \u00e0 initialiser \u00e0 0 avant le parcours de la liste de nombres. La solution C parcourt la liste des entiers de 1 \u00e0 10 compris, et ajoute le carr\u00e9 de chacun d'eux \u00e0 la variable somme . Enfin, l'affichage de la somme n'est \u00e0 r\u00e9aliser qu'apr\u00e8s le parcours complet des dix entiers.","title":"Question 2.2"},{"location":"python/boucles_bornees_questions/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_bornees_questions/#question-31","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + 3 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3, soit 4 valeurs. Pour chaque valeur de i , la variable total est augment\u00e9e de la quantit\u00e9 3. Finalement, total vaut 0 + 4*3 = 12","title":"Question 3.1"},{"location":"python/boucles_bornees_questions/#question-32","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i . Finalement, total vaut 0 + 0 + 1 + 2 + 3 = 6.","title":"Question 3.2"},{"location":"python/boucles_bornees_questions/#question-33","text":"Question Quelle serait la valeur de la variable total \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? total = 0 for i in range ( 4 ): total = total + i ** 2 Propositions de r\u00e9ponses 6 12 14 30 Solution 6 12 14 30 Arguments i prend les valeurs 0 \u00e0 3. Pour chaque valeur de i , la variable total est augment\u00e9e de la valeur de i 2 . Finalement, total vaut 0 + 1 + 4 + 9 = 14","title":"Question 3.3"},{"location":"python/boucles_bornees_questions/#4-boucle-avec-une-condition","text":"","title":"4. Boucle avec une condition"},{"location":"python/boucles_bornees_questions/#question-41","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = - 1 for i in range ( len ( nombres )): if nombres [ i ] == cible : reponse = i Propositions de r\u00e9ponses -1 1 2 6 Solution -1 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres[i] == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc affect\u00e9e deux fois. En fin de boucle, la valeur de la variable est celle de la derni\u00e8re affectation, donc l'indice de la derni\u00e8re occurrence de 34 dans nombres .","title":"Question 4.1"},{"location":"python/boucles_bornees_questions/#question-42","text":"Question On donne la liste de nombres suivante : nombres = [ 12 , 34 , 56 , 78 , 90 , 12 , 34 , 56 , 78 ] Quelle serait la valeur de la variable reponse \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? cible = 34 reponse = 0 for nombre in nombres : if nombre == cible : reponse = reponse + 1 Propositions de r\u00e9ponses 0 1 2 6 Solution 0 1 2 6 Arguments La valeur cible 34 est pr\u00e9sente deux fois dans le tableau, donc la condition if nombres == cible est v\u00e9rifi\u00e9e deux fois. La variable reponse est donc incr\u00e9ment\u00e9e deux fois. En fin de boucle, la valeur de la variable initialis\u00e9e \u00e0 0 est donc 2 .","title":"Question 4.2"},{"location":"python/boucles_bornees_questions/#5-traces-en-boucle","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"5. Trac\u00e9s en boucle"},{"location":"python/boucles_bornees_questions/#question-51","text":"Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Boucle A : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 60 ) Boucle B : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 60 ) Boucle C : t = Turtle () for i in range ( 6 ) : t . forward ( 100 ) t . left ( 120 ) Boucle D : t = Turtle () for i in range ( 7 ) : t . forward ( 100 ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 6 c\u00f4t\u00e9s et range(6) g\u00e9n\u00e8rera les entiers de 0 \u00e0 5, soit 6 entiers. Les angles \"internes\" de la figure sont de 120\u00b0, la tortue doit donc pivoter de 180 - 120 = 60\u00b0 entre 2 trac\u00e9s.","title":"Question 5.1"},{"location":"python/boucles_bornees_questions/#question-52","text":"Question Parmi les boucles suivantes, laquelle permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Le programme commence par les instructions suivantes : t = Turtle () # d\u00e9placement sans trac\u00e9 t . penup () t . setposition ( 75 , 150 ) t . pendown () Puis se termine par l'une des boucles suivantes : Boucle A : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 72 ) Boucle B : for i in range ( 5 ) : t . forward ( 250 ) t . right ( 144 ) Boucle C : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 36 ) Boucle D : for i in range ( 6 ) : t . forward ( 250 ) t . left ( 72 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La figure comporte 5 c\u00f4t\u00e9s et range(5) g\u00e9n\u00e8rera les entiers de 0 \u00e0 4, soit 5 entiers. Les angles \"internes\" des pointes de l'\u00e9toile sont de 36\u00b0, la tortue doit donc pivoter de 180 - 36 = 144\u00b0 entre 2 trac\u00e9s.","title":"Question 5.2"},{"location":"python/boucles_non_bornees/","text":"Boucles non born\u00e9es L'instruction while La boucle non born\u00e9e (ou boucle while ) permet de r\u00e9p\u00e9ter un bloc d'instructions tant qu'une expression (bool\u00e9enne) est vraie. La syntaxe de la boucle while est : while expression : bloc d_instructions \u00e0 r\u00e9p\u00e9ter o\u00f9 expression a pour valeur True ou False . Le bloc d'instructions est \u00e0 indenter. On utilise g\u00e9n\u00e9ralement cette boucle lorsqu'on ne connait pas le nombre d'it\u00e9rations au pr\u00e9alable. Exemple : La boucle suivante permet d'afficher la plus petite puissance de 2 sup\u00e9rieure \u00e0 nombre . nombre = 999 valeur = 1 while valeur < nombre : valeur = valeur * 2 print ( valeur ) 1024 Boucle infinie Les boucles while pr\u00e9sentent un risque de boucle infinie. Pour que la boucle prenne fin, il faut s'assurer que l'expression qui conditionne l'ex\u00e9cution du corps de la boucle prendra la valeur False , \u00e9ventuellement apr\u00e8s de tr\u00e8s nombreuses \u00e9tapes. Il faut donc s\u2019assurer que la valeur de cette expression est bien modifi\u00e9e par les instructions du corps de la boucle (ou par un \u00e9v\u00e9nement). Exemple : La boucle suivante ne se termine jamais : la variable valeur n'est jamais modifi\u00e9e dans le corps de la boucle. Seule une action de l\u2019utilisateur peut interrompre l'ex\u00e9cution du programme. compteur = 0 valeur = 0 while valeur == 0 : compteur = compteur + 1 print ( compteur ) \u00c0 l'inverse, si l'expression qui conditionne l'ex\u00e9cution du corps de la boucle a pour valeur False d\u00e8s le d\u00e9part, le corps de la boucle n\u2019est jamais ex\u00e9cut\u00e9.","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees/#boucles-non-bornees","text":"","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees/#linstruction-while","text":"La boucle non born\u00e9e (ou boucle while ) permet de r\u00e9p\u00e9ter un bloc d'instructions tant qu'une expression (bool\u00e9enne) est vraie. La syntaxe de la boucle while est : while expression : bloc d_instructions \u00e0 r\u00e9p\u00e9ter o\u00f9 expression a pour valeur True ou False . Le bloc d'instructions est \u00e0 indenter. On utilise g\u00e9n\u00e9ralement cette boucle lorsqu'on ne connait pas le nombre d'it\u00e9rations au pr\u00e9alable. Exemple : La boucle suivante permet d'afficher la plus petite puissance de 2 sup\u00e9rieure \u00e0 nombre . nombre = 999 valeur = 1 while valeur < nombre : valeur = valeur * 2 print ( valeur ) 1024","title":"L'instruction while"},{"location":"python/boucles_non_bornees/#boucle-infinie","text":"Les boucles while pr\u00e9sentent un risque de boucle infinie. Pour que la boucle prenne fin, il faut s'assurer que l'expression qui conditionne l'ex\u00e9cution du corps de la boucle prendra la valeur False , \u00e9ventuellement apr\u00e8s de tr\u00e8s nombreuses \u00e9tapes. Il faut donc s\u2019assurer que la valeur de cette expression est bien modifi\u00e9e par les instructions du corps de la boucle (ou par un \u00e9v\u00e9nement). Exemple : La boucle suivante ne se termine jamais : la variable valeur n'est jamais modifi\u00e9e dans le corps de la boucle. Seule une action de l\u2019utilisateur peut interrompre l'ex\u00e9cution du programme. compteur = 0 valeur = 0 while valeur == 0 : compteur = compteur + 1 print ( compteur ) \u00c0 l'inverse, si l'expression qui conditionne l'ex\u00e9cution du corps de la boucle a pour valeur False d\u00e8s le d\u00e9part, le corps de la boucle n\u2019est jamais ex\u00e9cut\u00e9.","title":"Boucle infinie"},{"location":"python/boucles_non_bornees_exercices/","text":"Exercices : boucles non born\u00e9es 1. Al\u00e9atoire Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint . Exercice 1.1 On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce qu'on obtienne un double (deux 1, deux 2, etc.). Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir le premier double. (Un premier double au 3e lancer doit faire afficher la valeur 3). Exercice 1.2 On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce que la somme des deux d\u00e9s soit \u00e9gale \u00e0 7. Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir une somme des deux d\u00e9s \u00e9gale \u00e0 7. 2. Accumulation Exercice 2.1 On dispose d'une feuille de papier d'\u00e9paisseur 0,1 mm. En supposant qu'on peut plier en 2 cette feuille autant de fois qu'on le souhaite, combien de fois doit-on la plier en deux au minimum pour que l'\u00e9paisseur d\u00e9passe la hauteur de la tour Eiffel (324 m) ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me. Exercice 2.2 Un capital de 1000 euros est d\u00e9pos\u00e9 sur un compte \u00e0 int\u00e9r\u00eats compos\u00e9s \u00e0 4 % : chaque ann\u00e9e le montant disponible sur le compte est augment\u00e9 de 4 %. Si l'on n'effectue ni d\u00e9p\u00f4t ni retrait, combien d'ann\u00e9es faut-il pour que le montant disponible atteigne (ou d\u00e9passe) 2000 euros ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me. 3. Calculs en boucle Exercice 3.1 Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? Comment d\u00e9crire ce que r\u00e9alise ce programme ? resultat = 1 while resultat < 1000 : resultat = resultat * 2 Exercice 3.2 \u00c9crire un programme qui permet de d\u00e9terminer la plus petite puissance de 5 sup\u00e9rieure \u00e0 1000. Le programme ne devra pas utiliser l'op\u00e9rateur python ** . 4. Trac\u00e9s en boucle Exercice 4.1 Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur - 2 Exercice 4.2 Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur / 2","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_exercices/#exercices-boucles-non-bornees","text":"","title":"Exercices : boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_exercices/#1-aleatoire","text":"Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint .","title":"1. Al\u00e9atoire"},{"location":"python/boucles_non_bornees_exercices/#exercice-11","text":"On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce qu'on obtienne un double (deux 1, deux 2, etc.). Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir le premier double. (Un premier double au 3e lancer doit faire afficher la valeur 3).","title":"Exercice 1.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-12","text":"On simule le tirage al\u00e9atoire de deux d\u00e9s, jusqu'\u00e0 ce que la somme des deux d\u00e9s soit \u00e9gale \u00e0 7. Ecrire un programme qui permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires pour obtenir une somme des deux d\u00e9s \u00e9gale \u00e0 7.","title":"Exercice 1.2"},{"location":"python/boucles_non_bornees_exercices/#2-accumulation","text":"","title":"2. Accumulation"},{"location":"python/boucles_non_bornees_exercices/#exercice-21","text":"On dispose d'une feuille de papier d'\u00e9paisseur 0,1 mm. En supposant qu'on peut plier en 2 cette feuille autant de fois qu'on le souhaite, combien de fois doit-on la plier en deux au minimum pour que l'\u00e9paisseur d\u00e9passe la hauteur de la tour Eiffel (324 m) ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me.","title":"Exercice 2.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-22","text":"Un capital de 1000 euros est d\u00e9pos\u00e9 sur un compte \u00e0 int\u00e9r\u00eats compos\u00e9s \u00e0 4 % : chaque ann\u00e9e le montant disponible sur le compte est augment\u00e9 de 4 %. Si l'on n'effectue ni d\u00e9p\u00f4t ni retrait, combien d'ann\u00e9es faut-il pour que le montant disponible atteigne (ou d\u00e9passe) 2000 euros ? \u00c9crire un programme en Python pour r\u00e9soudre ce probl\u00e8me.","title":"Exercice 2.2"},{"location":"python/boucles_non_bornees_exercices/#3-calculs-en-boucle","text":"","title":"3. Calculs en boucle"},{"location":"python/boucles_non_bornees_exercices/#exercice-31","text":"Quelle serait la valeur de la variable resultat \u00e0 l'issue de l'ex\u00e9cution de ces instructions ? Comment d\u00e9crire ce que r\u00e9alise ce programme ? resultat = 1 while resultat < 1000 : resultat = resultat * 2","title":"Exercice 3.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-32","text":"\u00c9crire un programme qui permet de d\u00e9terminer la plus petite puissance de 5 sup\u00e9rieure \u00e0 1000. Le programme ne devra pas utiliser l'op\u00e9rateur python ** .","title":"Exercice 3.2"},{"location":"python/boucles_non_bornees_exercices/#4-traces-en-boucle","text":"","title":"4. Trac\u00e9s en boucle"},{"location":"python/boucles_non_bornees_exercices/#exercice-41","text":"Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur - 2","title":"Exercice 4.1"},{"location":"python/boucles_non_bornees_exercices/#exercice-42","text":"Le programme suivant utilise la tortue du module mobilechelonian dans un notebook Jupyter. S'arr\u00eate-t-il lorsqu'on lance son ex\u00e9cution ? Pourquoi ? from mobilechelonian import Turtle t = Turtle () longueur = 150 while longueur > 0 : t . forward ( longueur ) t . left ( 89 ) longueur = longueur / 2","title":"Exercice 4.2"},{"location":"python/boucles_non_bornees_questions/","text":"Questions : boucles non born\u00e9es 1. Al\u00e9atoire Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint . Question 1.1 Question On simule le tirage al\u00e9atoire d'un d\u00e9, jusqu'\u00e0 ce qu'on obtienne un 6. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires ? (un premier 6 au 3e lancer doit faire afficher la valeur 3). Programme A : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme B : from random import randint de = randint ( 1 , 6 ) compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme C : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de == 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur - 1 ) Programme D : from random import randint de = 0 compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur + 1 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le premier lancer peut donner lieu \u00e0 un 6 : le compteur doit \u00eatre initialis\u00e9 \u00e0 1 d\u00e8s qu'un lancer est simul\u00e9. Ensuite il faut incr\u00e9menter 1 le compteur \u00e0 chaque fois qu'un lancer est simul\u00e9. De cette fa\u00e7on, compteur contient exactement le nombre de lancers jusqu'au premier 6. Question 1.2 Question Une grenouille monte l'escalier de 17 marches qui m\u00e8ne \u00e0 la terrasse. A chacun de ses bonds, elle grimpe al\u00e9atoirement d'une ou de deux marches. On simule son trajet \u00e0 l'aide d'un programme. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de bonds qui ont \u00e9t\u00e9 n\u00e9cessaires pour atteindre la terrasse ? Programme A : from random import randint marche = 0 compteur = 1 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme B : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme C : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + bond marche = marche + bond print ( compteur ) Programme D : from random import randint marche = 0 compteur = 0 while marche != 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le programme A initialise la variable compteur \u00e0 1 alors que marche est initialis\u00e9 \u00e0 0. Le programme C n'incr\u00e9mente 1 pas correctement compteur : chaque bond ne compte que pour 1. Le programme D teste si on atteint exactement la 17e marche, or notre simulation pourrait induire un bond de 2 marches \u00e0 partir de la 16e. La variable marche pourrait ne jamais valoir 17 et le programme ne s'arr\u00eaterait pas. Seul le programme B convient. 2. Accumulation Question 2.1 Question On cherche \u00e0 d\u00e9terminer le plus petit entier n n tel que la somme 1 + 2 + 3 + \\cdots +n 1 + 2 + 3 + \\cdots +n soit sup\u00e9rieure \u00e0 1000. Parmi les 4 programmes suivants, lequel permet d'afficher la valeur de n n cherch\u00e9e ? Programme A : somme = 0 n = 0 while somme > 1000 : n = n + 1 somme = somme + n print ( n ) Programme B : somme = 0 n = 0 while somme >= 1000 : somme = somme + n n = n + 1 print ( n ) Programme C : somme = 0 n = 0 while somme < 1000 : n = n + 1 somme = somme + n print ( n ) Programme D : somme = 0 n = 0 while somme < 1000 : somme = somme + n n = n + 1 print ( n ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Les corps de boucles des programmes A et B ne sont jamais ex\u00e9cut\u00e9s car les expressions somme > 1000 et somme >= 1000 sont \u00e9valu\u00e9es \u00e0 False puisque somme vaut 0 lors de l'\u00e9valuation. La seule diff\u00e9rence entre les programmes C et D est l'ordre des instructions somme = somme + n et n = n + 1 . Dans le programme D, n est incr\u00e9ment\u00e9 1 apr\u00e8s avoir \u00e9t\u00e9 ajout\u00e9 \u00e0 somme : lorsque la valeur de somme sera sup\u00e9rieure ou \u00e9gale \u00e0 1000, mettant fin \u00e0 la boucle, la valeur de n ne sera pas la derni\u00e8re ajout\u00e9e \u00e0 somme . L'instruction print(n) n'affichera pas la bonne valeur. Dans le programme C, n est incr\u00e9ment\u00e9 avant d'\u00eatre ajout\u00e9 \u00e0 somme , et le probl\u00e8me pr\u00e9c\u00e9dent ne se pose plus. Question 2.2 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? i = 1 while i <= 100 : i = 2 * i print ( i ) Propositions de r\u00e9ponses 1 64 100 128 Solution 1 64 100 128 Arguments La variable i prend successivement les valeurs 1, 2, 4, 8, 16, 32, 64. Pour toutes ces valeurs, l'expression i <= 100 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution i prend la valeur 128, ce qui fait sortir de la boucle. 3. Entrer dans la boucle et en sortir Question 3.1 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 5 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 7 10 Aucune : la boucle ne termine pas Solution 5 7 10 Aucune : la boucle ne termine pas Arguments L'expression a < 5 est \u00e9valu\u00e9e \u00e0 False lorque a vaut 5 : le corps de la boucle n'est jamais ex\u00e9cut\u00e9. Question 3.2 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 9 11 Aucune : la boucle ne termine pas Solution 5 9 11 Aucune : la boucle ne termine pas Arguments La variable a prend successivement les valeurs 5, 7 et 9. Pour toutes ces valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution a prend la valeur 11, ce qui fait sortir de la boucle. Question 3.3 Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a - 2 print ( a ) Propositions de r\u00e9ponses 5 3 1 Aucune : la boucle ne termine pas Solution 5 3 1 Aucune : la boucle ne termine pas Arguments La variable a prend les valeurs 5, 3 ,1, -1, -3, etc. Pour toutes les valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Les valeurs de a sont d\u00e9croissantes, et aucune valeur prise par a ne permettra de sortir de la boucle. incr\u00e9menter : augmenter d'une unit\u00e9 \u21a9 \u21a9 \u21a9","title":"Boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_questions/#questions-boucles-non-bornees","text":"","title":"Questions : boucles non born\u00e9es"},{"location":"python/boucles_non_bornees_questions/#1-aleatoire","text":"Info L'instruction randint(1,6) g\u00e9n\u00e8re un entier al\u00e9atoire entre 1 et 6 compris. Cette fonction fait partie du module random . Pour pouvoir l'utiliser on peut \u00e9crire en d\u00e9but de programme : from random import randint .","title":"1. Al\u00e9atoire"},{"location":"python/boucles_non_bornees_questions/#question-11","text":"Question On simule le tirage al\u00e9atoire d'un d\u00e9, jusqu'\u00e0 ce qu'on obtienne un 6. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de coups qui ont \u00e9t\u00e9 n\u00e9cessaires ? (un premier 6 au 3e lancer doit faire afficher la valeur 3). Programme A : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme B : from random import randint de = randint ( 1 , 6 ) compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur ) Programme C : from random import randint de = randint ( 1 , 6 ) compteur = 1 while de == 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur - 1 ) Programme D : from random import randint de = 0 compteur = 0 while de != 6 : de = randint ( 1 , 6 ) compteur = compteur + 1 print ( compteur + 1 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le premier lancer peut donner lieu \u00e0 un 6 : le compteur doit \u00eatre initialis\u00e9 \u00e0 1 d\u00e8s qu'un lancer est simul\u00e9. Ensuite il faut incr\u00e9menter 1 le compteur \u00e0 chaque fois qu'un lancer est simul\u00e9. De cette fa\u00e7on, compteur contient exactement le nombre de lancers jusqu'au premier 6.","title":"Question 1.1"},{"location":"python/boucles_non_bornees_questions/#question-12","text":"Question Une grenouille monte l'escalier de 17 marches qui m\u00e8ne \u00e0 la terrasse. A chacun de ses bonds, elle grimpe al\u00e9atoirement d'une ou de deux marches. On simule son trajet \u00e0 l'aide d'un programme. Parmi les 4 programmes suivants, lequel permet d'afficher le nombre de bonds qui ont \u00e9t\u00e9 n\u00e9cessaires pour atteindre la terrasse ? Programme A : from random import randint marche = 0 compteur = 1 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme B : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Programme C : from random import randint marche = 0 compteur = 0 while marche < 17 : bond = randint ( 1 , 2 ) compteur = compteur + bond marche = marche + bond print ( compteur ) Programme D : from random import randint marche = 0 compteur = 0 while marche != 17 : bond = randint ( 1 , 2 ) compteur = compteur + 1 marche = marche + bond print ( compteur ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Le programme A initialise la variable compteur \u00e0 1 alors que marche est initialis\u00e9 \u00e0 0. Le programme C n'incr\u00e9mente 1 pas correctement compteur : chaque bond ne compte que pour 1. Le programme D teste si on atteint exactement la 17e marche, or notre simulation pourrait induire un bond de 2 marches \u00e0 partir de la 16e. La variable marche pourrait ne jamais valoir 17 et le programme ne s'arr\u00eaterait pas. Seul le programme B convient.","title":"Question 1.2"},{"location":"python/boucles_non_bornees_questions/#2-accumulation","text":"","title":"2. Accumulation"},{"location":"python/boucles_non_bornees_questions/#question-21","text":"Question On cherche \u00e0 d\u00e9terminer le plus petit entier n n tel que la somme 1 + 2 + 3 + \\cdots +n 1 + 2 + 3 + \\cdots +n soit sup\u00e9rieure \u00e0 1000. Parmi les 4 programmes suivants, lequel permet d'afficher la valeur de n n cherch\u00e9e ? Programme A : somme = 0 n = 0 while somme > 1000 : n = n + 1 somme = somme + n print ( n ) Programme B : somme = 0 n = 0 while somme >= 1000 : somme = somme + n n = n + 1 print ( n ) Programme C : somme = 0 n = 0 while somme < 1000 : n = n + 1 somme = somme + n print ( n ) Programme D : somme = 0 n = 0 while somme < 1000 : somme = somme + n n = n + 1 print ( n ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Les corps de boucles des programmes A et B ne sont jamais ex\u00e9cut\u00e9s car les expressions somme > 1000 et somme >= 1000 sont \u00e9valu\u00e9es \u00e0 False puisque somme vaut 0 lors de l'\u00e9valuation. La seule diff\u00e9rence entre les programmes C et D est l'ordre des instructions somme = somme + n et n = n + 1 . Dans le programme D, n est incr\u00e9ment\u00e9 1 apr\u00e8s avoir \u00e9t\u00e9 ajout\u00e9 \u00e0 somme : lorsque la valeur de somme sera sup\u00e9rieure ou \u00e9gale \u00e0 1000, mettant fin \u00e0 la boucle, la valeur de n ne sera pas la derni\u00e8re ajout\u00e9e \u00e0 somme . L'instruction print(n) n'affichera pas la bonne valeur. Dans le programme C, n est incr\u00e9ment\u00e9 avant d'\u00eatre ajout\u00e9 \u00e0 somme , et le probl\u00e8me pr\u00e9c\u00e9dent ne se pose plus.","title":"Question 2.1"},{"location":"python/boucles_non_bornees_questions/#question-22","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? i = 1 while i <= 100 : i = 2 * i print ( i ) Propositions de r\u00e9ponses 1 64 100 128 Solution 1 64 100 128 Arguments La variable i prend successivement les valeurs 1, 2, 4, 8, 16, 32, 64. Pour toutes ces valeurs, l'expression i <= 100 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution i prend la valeur 128, ce qui fait sortir de la boucle.","title":"Question 2.2"},{"location":"python/boucles_non_bornees_questions/#3-entrer-dans-la-boucle-et-en-sortir","text":"","title":"3. Entrer dans la boucle et en sortir"},{"location":"python/boucles_non_bornees_questions/#question-31","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 5 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 7 10 Aucune : la boucle ne termine pas Solution 5 7 10 Aucune : la boucle ne termine pas Arguments L'expression a < 5 est \u00e9valu\u00e9e \u00e0 False lorque a vaut 5 : le corps de la boucle n'est jamais ex\u00e9cut\u00e9.","title":"Question 3.1"},{"location":"python/boucles_non_bornees_questions/#question-32","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a + 2 print ( a ) Propositions de r\u00e9ponses 5 9 11 Aucune : la boucle ne termine pas Solution 5 9 11 Aucune : la boucle ne termine pas Arguments La variable a prend successivement les valeurs 5, 7 et 9. Pour toutes ces valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Lors de la derni\u00e8re ex\u00e9cution a prend la valeur 11, ce qui fait sortir de la boucle.","title":"Question 3.2"},{"location":"python/boucles_non_bornees_questions/#question-33","text":"Question Voici un programme comportant une boucle non born\u00e9e. Quelle est la valeur affich\u00e9e \u00e0 l'issue de l'ex\u00e9cution de ce programme ? a = 5 while a < 10 : a = a - 2 print ( a ) Propositions de r\u00e9ponses 5 3 1 Aucune : la boucle ne termine pas Solution 5 3 1 Aucune : la boucle ne termine pas Arguments La variable a prend les valeurs 5, 3 ,1, -1, -3, etc. Pour toutes les valeurs, l'expression a < 10 est \u00e9valu\u00e9e \u00e0 True et le corps de la boucle est ex\u00e9cut\u00e9. Les valeurs de a sont d\u00e9croissantes, et aucune valeur prise par a ne permettra de sortir de la boucle. incr\u00e9menter : augmenter d'une unit\u00e9 \u21a9 \u21a9 \u21a9","title":"Question 3.3"},{"location":"python/fonctions/","text":"Fonctions Les fonctions permettent de d\u00e9composer un programme en plusieurs \u00e9l\u00e9ments plus simples, plus lisibles et que l'on peut combiner. Une fonction associe un bloc d'instructions \u00e0 un nom. L'utilisation d'une fonction n\u00e9cessite deux \u00e9tapes : sa d\u00e9claration : on d\u00e9finit le nom de la fonction, ses param\u00e8tres et les instructions \u00e0 ex\u00e9cuter ; son appel : on ex\u00e9cute la fonction pour des valeurs explicites des param\u00e8tres. La d\u00e9claration d'une fonction La syntaxe de la d\u00e9claration d'une fonction est : def nom_de_la_fonction ( parametres ): bloc_instructions La d\u00e9finition d'une fonction commence par le mot-cl\u00e9 def . Les param\u00e8tres sont s\u00e9par\u00e9s par des virgules. Il peut ne pas y en avoir : dans ce cas on conserve tout de m\u00eame les parenth\u00e8ses. La premi\u00e8re ligne se termine par un double point. Le bloc bloc_instructions est indent\u00e9. On l'appelle le corps de la fonction. Il est fr\u00e9quent (mais pas obligatoire) que la fonction renvoie une valeur : on utilise pour cela le mot-cl\u00e9 return . En l'absence de return la fonction peut par exemple r\u00e9aliser des affichages, des trac\u00e9s ou \u00e9crire dans un fichier. Elle renverra alors implicitement None . Exemple 1 : une fonction \u00e0 valeur num\u00e9rique def f ( x , y ): return x ** 2 - y ** 2 Cette fonction s'appelle f , elle demande deux param\u00e8tres et elle renvoie la diff\u00e9rence des carr\u00e9s des param\u00e8tres. Exemple 2 : une fonction \u00e0 valeur bool\u00e9enne def validation ( mot ): return mot == 'secret123' Cette fonction s'appelle validation , elle demande un seul param\u00e8tre et elle renvoie True si le param\u00e8tre est \u00e9gal \u00e0 la chaine 'secret123' et False sinon. L'appel d'une fonction La syntaxe de l'appel d'une fonction est : nom_de_la_fonction ( valeurs_des_parametres ) Lors de la d\u00e9finition d'une fonction, le type des param\u00e8tres n'est pas pr\u00e9cis\u00e9. Lors de l'appel de la fonction, il est n\u00e9cessaire que les instructions r\u00e9alis\u00e9es soient compatibles avec les types des valeurs des param\u00e8tres. Exemple 1 : fonction f 1er cas : f ( 5 , 3 ) 16 Les param\u00e8tres x et y de f prennent respectivement les valeurs 5 et 3. La fonction renvoie la valeur 5*5 - 3*3, soit 16. 2e cas : f ( 'a' , 'b' ) TypeError: unsupported operand type(s) for Pow: 'str' and 'int' Les param\u00e8tres x et y de f prennent respectivement pour valeurs les chaines de caract\u00e8res 'a' et 'b'. Comme l'op\u00e9rateur ** 2 n'a pas de signification pour une chaine de carat\u00e8res, l'appel de la fonction avec ces valeurs renvoie une erreur. Exemple 2 : fonction validation 1er cas : validation ( 'mot_de_passe123' ) False Le param\u00e8tre mot de la fonction validation prend la valeur 'mot_de_passe123'. La fonction renvoie la valeur de 'mot_de_passe123' == 'secret123', soit False . 2e cas : validation ( 123 ) False Le param\u00e8tre mot de la fonction validation prend la valeur 123, qui est un entier et non une chaine de caract\u00e8res. N\u00e9anmoins l'ex\u00e9cution de la fonction ne d\u00e9clenche pas d'erreur : elle renvoie la valeur de 123 == 'secret123', qui est False . Pour approfondir La documentation python pr\u00e9sente d'autres notions li\u00e9es aux fonctions : Valeur par d\u00e9faut des arguments Les arguments nomm\u00e9s Listes d'arguments arbitraires S\u00e9paration des listes d'arguments Fonctions anonymes Cha\u00eenes de documentation Annotations de fonctions","title":"Fonctions"},{"location":"python/fonctions/#fonctions","text":"Les fonctions permettent de d\u00e9composer un programme en plusieurs \u00e9l\u00e9ments plus simples, plus lisibles et que l'on peut combiner. Une fonction associe un bloc d'instructions \u00e0 un nom. L'utilisation d'une fonction n\u00e9cessite deux \u00e9tapes : sa d\u00e9claration : on d\u00e9finit le nom de la fonction, ses param\u00e8tres et les instructions \u00e0 ex\u00e9cuter ; son appel : on ex\u00e9cute la fonction pour des valeurs explicites des param\u00e8tres.","title":"Fonctions"},{"location":"python/fonctions/#la-declaration-dune-fonction","text":"La syntaxe de la d\u00e9claration d'une fonction est : def nom_de_la_fonction ( parametres ): bloc_instructions La d\u00e9finition d'une fonction commence par le mot-cl\u00e9 def . Les param\u00e8tres sont s\u00e9par\u00e9s par des virgules. Il peut ne pas y en avoir : dans ce cas on conserve tout de m\u00eame les parenth\u00e8ses. La premi\u00e8re ligne se termine par un double point. Le bloc bloc_instructions est indent\u00e9. On l'appelle le corps de la fonction. Il est fr\u00e9quent (mais pas obligatoire) que la fonction renvoie une valeur : on utilise pour cela le mot-cl\u00e9 return . En l'absence de return la fonction peut par exemple r\u00e9aliser des affichages, des trac\u00e9s ou \u00e9crire dans un fichier. Elle renverra alors implicitement None . Exemple 1 : une fonction \u00e0 valeur num\u00e9rique def f ( x , y ): return x ** 2 - y ** 2 Cette fonction s'appelle f , elle demande deux param\u00e8tres et elle renvoie la diff\u00e9rence des carr\u00e9s des param\u00e8tres. Exemple 2 : une fonction \u00e0 valeur bool\u00e9enne def validation ( mot ): return mot == 'secret123' Cette fonction s'appelle validation , elle demande un seul param\u00e8tre et elle renvoie True si le param\u00e8tre est \u00e9gal \u00e0 la chaine 'secret123' et False sinon.","title":"La d\u00e9claration d'une fonction"},{"location":"python/fonctions/#lappel-dune-fonction","text":"La syntaxe de l'appel d'une fonction est : nom_de_la_fonction ( valeurs_des_parametres ) Lors de la d\u00e9finition d'une fonction, le type des param\u00e8tres n'est pas pr\u00e9cis\u00e9. Lors de l'appel de la fonction, il est n\u00e9cessaire que les instructions r\u00e9alis\u00e9es soient compatibles avec les types des valeurs des param\u00e8tres. Exemple 1 : fonction f 1er cas : f ( 5 , 3 ) 16 Les param\u00e8tres x et y de f prennent respectivement les valeurs 5 et 3. La fonction renvoie la valeur 5*5 - 3*3, soit 16. 2e cas : f ( 'a' , 'b' ) TypeError: unsupported operand type(s) for Pow: 'str' and 'int' Les param\u00e8tres x et y de f prennent respectivement pour valeurs les chaines de caract\u00e8res 'a' et 'b'. Comme l'op\u00e9rateur ** 2 n'a pas de signification pour une chaine de carat\u00e8res, l'appel de la fonction avec ces valeurs renvoie une erreur. Exemple 2 : fonction validation 1er cas : validation ( 'mot_de_passe123' ) False Le param\u00e8tre mot de la fonction validation prend la valeur 'mot_de_passe123'. La fonction renvoie la valeur de 'mot_de_passe123' == 'secret123', soit False . 2e cas : validation ( 123 ) False Le param\u00e8tre mot de la fonction validation prend la valeur 123, qui est un entier et non une chaine de caract\u00e8res. N\u00e9anmoins l'ex\u00e9cution de la fonction ne d\u00e9clenche pas d'erreur : elle renvoie la valeur de 123 == 'secret123', qui est False .","title":"L'appel d'une fonction"},{"location":"python/fonctions/#pour-approfondir","text":"La documentation python pr\u00e9sente d'autres notions li\u00e9es aux fonctions : Valeur par d\u00e9faut des arguments Les arguments nomm\u00e9s Listes d'arguments arbitraires S\u00e9paration des listes d'arguments Fonctions anonymes Cha\u00eenes de documentation Annotations de fonctions","title":"Pour approfondir"},{"location":"python/fonctions_questions/","text":"Questions : fonctions 1. Fonctions et math\u00e9matiques Question 1.1 Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer le maximum des 2 param\u00e8tres ? Fonction A : def maximum ( a , b ): if a > b : resultat = a else : resultat = b return resultat Fonction B : def maximum ( a , b ): if a >= b : resultat = a else : resultat = b return resultat Fonction C : def maximum ( a , b ): if a > b : resultat = a if a < b : resultat = b return resultat Fonction D : def maximum ( a , b ): return a if a > b else b Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, toutes conviennent sauf la C : lorsque les 2 param\u00e8tres sont \u00e9gaux la C ne renvoie rien. La syntaxe de la D est particuli\u00e8re, mais usuelle en Python. Question 1.2 Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer la liste des valeurs de la table de multiplication d'un entier (c'est \u00e0 dire les produits de cet entier par les entiers de 1 \u00e0 10) ? Fonction A : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table . append ( n * i ) return table Fonction B : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + n * i return table_multiplication Fonction C : def table_multiplication ( n ): table = [] for i in range ( 10 ): table . append ( n * i ) return table Fonction D : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + [ n * i ] return table Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La proposition B essaie d'utiliser le symbole + entre une liste et un entier, ce qui provoque une erreur. Par ailleurs elle renvoie la fonction plut\u00f4t que la liste, ce qui ne r\u00e9pond pas \u00e0 la question pos\u00e9e. La fonction C n'utilise pas les bons entiers : range(10) engendre les entiers de 0 \u00e0 9, et non de 1 \u00e0 10. Les fonctions A et D sont correctes. 2. Avec le symbole + Question 2.1 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( 5 , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des nombres, le symbole + est un op\u00e9rateur d'addition. Question 2.2 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , '6' )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des chaines de caract\u00e8res, le symbole + est un op\u00e9rateur de concat\u00e9nation. L'affichage produit est la chaine de caract\u00e8res '56' et non l'entier 56. Question 2.3 Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont un entier pour l'un et une chaine de caract\u00e8res pour l'autre, le symbole + n'a pas de signification. L'affichage produit est le message d'erreur : TypeError: cannot concatenate 'str' and 'int' objects 3. Trac\u00e9s en boucle : des fonctions sans return Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code. Question 3.1 Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def carre ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 4 ) : carre ( t ) t . right ( 120 ) Programme B : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 30 ) Programme C : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 120 ) Programme D : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( tortue ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La fonction carre prend en param\u00e8tre une tortue. Cette fonction doit faire tracer 4 c\u00f4t\u00e9s ( range(4) ) et les angles d'un carr\u00e9 font 90\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu. Question 3.2 Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def hexagone ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( t ) t . left ( 60 ) Programme B : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 60 ) Programme C : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( tortue ) t . left ( 120 ) Programme D : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ). La fonction hexagone prend en param\u00e8tre une tortue et lui fait tracer 6 c\u00f4t\u00e9s ( range(6) ). Les angles internes de l'hexagone font 120\u00b0 donc la tortue doit pivoter de 180 - 120 = 60\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Questions"},{"location":"python/fonctions_questions/#questions-fonctions","text":"","title":"Questions : fonctions"},{"location":"python/fonctions_questions/#1-fonctions-et-mathematiques","text":"","title":"1. Fonctions et math\u00e9matiques"},{"location":"python/fonctions_questions/#question-11","text":"Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer le maximum des 2 param\u00e8tres ? Fonction A : def maximum ( a , b ): if a > b : resultat = a else : resultat = b return resultat Fonction B : def maximum ( a , b ): if a >= b : resultat = a else : resultat = b return resultat Fonction C : def maximum ( a , b ): if a > b : resultat = a if a < b : resultat = b return resultat Fonction D : def maximum ( a , b ): return a if a > b else b Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments Parmi les propositions, toutes conviennent sauf la C : lorsque les 2 param\u00e8tres sont \u00e9gaux la C ne renvoie rien. La syntaxe de la D est particuli\u00e8re, mais usuelle en Python.","title":"Question 1.1"},{"location":"python/fonctions_questions/#question-12","text":"Question Parmi les 4 fonctions suivantes, lesquelles permettent de renvoyer la liste des valeurs de la table de multiplication d'un entier (c'est \u00e0 dire les produits de cet entier par les entiers de 1 \u00e0 10) ? Fonction A : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table . append ( n * i ) return table Fonction B : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + n * i return table_multiplication Fonction C : def table_multiplication ( n ): table = [] for i in range ( 10 ): table . append ( n * i ) return table Fonction D : def table_multiplication ( n ): table = [] for i in range ( 1 , 11 ): table = table + [ n * i ] return table Propositions de r\u00e9ponses A B C D Solutions A B C D Arguments La proposition B essaie d'utiliser le symbole + entre une liste et un entier, ce qui provoque une erreur. Par ailleurs elle renvoie la fonction plut\u00f4t que la liste, ce qui ne r\u00e9pond pas \u00e0 la question pos\u00e9e. La fonction C n'utilise pas les bons entiers : range(10) engendre les entiers de 0 \u00e0 9, et non de 1 \u00e0 10. Les fonctions A et D sont correctes.","title":"Question 1.2"},{"location":"python/fonctions_questions/#2-avec-le-symbole","text":"","title":"2. Avec le symbole +"},{"location":"python/fonctions_questions/#question-21","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( 5 , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des nombres, le symbole + est un op\u00e9rateur d'addition.","title":"Question 2.1"},{"location":"python/fonctions_questions/#question-22","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , '6' )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont des chaines de caract\u00e8res, le symbole + est un op\u00e9rateur de concat\u00e9nation. L'affichage produit est la chaine de caract\u00e8res '56' et non l'entier 56.","title":"Question 2.2"},{"location":"python/fonctions_questions/#question-23","text":"Question On donne la fonction suivante : def plus ( a , b ) return a + b Quel serait l'affichage produit par l'ex\u00e9cution de l'instruction suivante ? print ( plus ( '5' , 6 )) Propositions de r\u00e9ponses 11 5 6 56 Une erreur Solutions 11 5 6 56 Une erreur Arguments Lorsque les param\u00e8tres sont un entier pour l'un et une chaine de caract\u00e8res pour l'autre, le symbole + n'a pas de signification. L'affichage produit est le message d'erreur : TypeError: cannot concatenate 'str' and 'int' objects","title":"Question 2.3"},{"location":"python/fonctions_questions/#3-traces-en-boucle-des-fonctions-sans-return","text":"Les trac\u00e9s suivants ont \u00e9t\u00e9 r\u00e9alis\u00e9s dans un environnement Jupyter, \u00e0 l'aide du module mobilechelonian qui permet d'utiliser l'essentiel des m\u00e9thodes li\u00e9es \u00e0 la tortue. Pour ex\u00e9cuter les codes dans un notebook Jupyter, les instructions sont \u00e0 pr\u00e9c\u00e9der de : from mobilechelonian import Turtle . Dans un environnement standard on pourra utiliser le module turtle , avec quelques adaptations du code.","title":"3. Trac\u00e9s en boucle : des fonctions sans return"},{"location":"python/fonctions_questions/#question-31","text":"Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def carre ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 4 ) : carre ( t ) t . right ( 120 ) Programme B : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 30 ) Programme C : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( t ) t . left ( 120 ) Programme D : def carre ( tortue ): for nb_cote in range ( 4 ) : tortue . forward ( 100 ) tortue . left ( 90 ) t = Turtle () for nb_carre in range ( 3 ) : carre ( tortue ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments La fonction carre prend en param\u00e8tre une tortue. Cette fonction doit faire tracer 4 c\u00f4t\u00e9s ( range(4) ) et les angles d'un carr\u00e9 font 90\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque carr\u00e9 est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.1"},{"location":"python/fonctions_questions/#question-32","text":"Question Parmi les programmes suivants, lequel permet de faire tracer \u00e0 la tortue la figure ci-dessous ? Programme A : def hexagone ( tortue ): for nb_cote in range ( 3 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( t ) t . left ( 60 ) Programme B : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 120 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 60 ) Programme C : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 6 ) : hexagone ( tortue ) t . left ( 120 ) Programme D : def hexagone ( tortue ): for nb_cote in range ( 6 ) : tortue . forward ( 80 ) tortue . left ( 60 ) t = Turtle () for nb_poly in range ( 3 ) : hexagone ( t ) t . left ( 120 ) Propositions de r\u00e9ponses A B C D Solution A B C D Arguments Il y a 3 hexagones r\u00e9guliers \u00e0 tracer ( range(3) ). La fonction hexagone prend en param\u00e8tre une tortue et lui fait tracer 6 c\u00f4t\u00e9s ( range(6) ). Les angles internes de l'hexagone font 120\u00b0 donc la tortue doit pivoter de 180 - 120 = 60\u00b0. Lorsqu'on appelle cette fonction le param\u00e8tre prend pour valeur le nom de la tortue qui doit tracer le carr\u00e9. Dans tous les programmes propos\u00e9s, celle-ci s'appelle t . Chaque hexagone est l'image d'un autre par une rotation d'un tiers d'angle plein (360/3 = 120\u00b0). Le sens de cette rotation importe peu : t.right(120) aurait aussi convenu.","title":"Question 3.2"},{"location":"python/instructions_conditionnelles/","text":"Instructions conditionnelles Les instructions conditionnelles permettent de s\u00e9lectionner le bloc d'instructions \u00e0 ex\u00e9cuter selon la valeur d'une expression bool\u00e9enne. L'instruction if La syntaxe de l'instruction if est : if expression : bloc_instructions_1 bloc_instructions_2 o\u00f9 expression a pour valeur True ou False . Il s'agit de l'expression de la clause if . Si expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, sinon, il est ignor\u00e9. Dans tous les cas, si le bloc bloc_instructions_2 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : l'expression de la clause if a pour valeur True nb = 17 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 34 est un nombre pair nb % 2 != 0 est une expression qui vaut True lorsque nb vaut 17. L'instruction nb = nb * 2 est ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 34. Exemple : l'expression de la clause if a pour valeur False nb = 18 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 18 est un nombre pair nb % 2 != 0 est une expression qui vaut False lorsque nb vaut 18. L'instruction nb = nb * 2 est ignor\u00e9e et la valeur de nb n'est pas modifi\u00e9e. L'instruction if \u2026 else La syntaxe de l'instruction if \u2026 else est : if expression : bloc_instructions_1 else : bloc_instructions_2 bloc_instructions_3 o\u00f9 expression a pour valeur True ou False . Lorsque expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_2 est ignor\u00e9. Lorsque expression a pour valeur False , le bloc bloc_instructions_1 est ignor\u00e9, et le bloc bloc_instructions_2 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , mais jamais les 2. Dans tous les cas, si le bloc bloc_instructions_3 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 5 if nb % 2 == 0 : print ( nb , \"est un nombre pair\" ) else : print ( nb , \"est un nombre impair\" ) 5 est un nombre impair nb % 2 == 0 est une expression qui vaut False lorsque nb vaut 5. L'instruction print(nb, \"est un nombre pair\") est ignor\u00e9e mais print(nb, \"est un nombre impair\") est ex\u00e9cut\u00e9e. L'instruction if \u2026 elif \u2026 else Lorsque l'on souhaite disposer de plus d'une alternative, l'instruction if \u2026 elif \u2026 else permet de conditionner l'ex\u00e9cution de plusieurs blocs d'instructions par la valeur de plusieurs expressions bool\u00e9ennes. elif est \u00e9quivalent \u00e0 else if . On peut ajouter autant de clauses elif que n\u00e9cessaires. La syntaxe de l'instruction if \u2026 elif \u2026 else est : if expression1 : bloc_instructions_1 elif expression2 : bloc_instructions_2 else : bloc_instructions_3 bloc_instructions_4 o\u00f9 expression1 et expression2 ont pour valeur True ou False . Lorsque expression1 a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et les blocs bloc_instructions_2 et bloc_instructions_3 sont ignor\u00e9s. Lorsque expression1 a pour valeur False : le bloc bloc_instructions_1 est ignor\u00e9, si expression2 a pour valeur True , le bloc bloc_instructions_2 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_3 est ignor\u00e9 ; si expression2 a pour valeur False , le bloc bloc_instructions_2 est ignor\u00e9, et le bloc bloc_instructions_3 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , soit le bloc bloc_instructions_3 , mais toujours un seul parmi les 3. Dans tous les cas, si le bloc bloc_instructions_4 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 15 if nb <= 10 : print ( nb , \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\" ) elif nb >= 20 : print ( nb , \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\" ) else : print ( nb , \"est strictement compris entre 10 et 20\" ) 15 est strictement compris entre 10 et 20 nb <= 10 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\") est ignor\u00e9e. nb >= 20 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\") est aussi ignor\u00e9e. L'instruction print(nb, \"est strictement compris entre 10 et 20\") est donc ex\u00e9cut\u00e9e.","title":"Instructions conditionnelles"},{"location":"python/instructions_conditionnelles/#instructions-conditionnelles","text":"Les instructions conditionnelles permettent de s\u00e9lectionner le bloc d'instructions \u00e0 ex\u00e9cuter selon la valeur d'une expression bool\u00e9enne.","title":"Instructions conditionnelles"},{"location":"python/instructions_conditionnelles/#linstruction-if","text":"La syntaxe de l'instruction if est : if expression : bloc_instructions_1 bloc_instructions_2 o\u00f9 expression a pour valeur True ou False . Il s'agit de l'expression de la clause if . Si expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, sinon, il est ignor\u00e9. Dans tous les cas, si le bloc bloc_instructions_2 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : l'expression de la clause if a pour valeur True nb = 17 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 34 est un nombre pair nb % 2 != 0 est une expression qui vaut True lorsque nb vaut 17. L'instruction nb = nb * 2 est ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 34. Exemple : l'expression de la clause if a pour valeur False nb = 18 if nb % 2 != 0 : nb = nb * 2 print ( nb , \"est un nombre pair\" ) 18 est un nombre pair nb % 2 != 0 est une expression qui vaut False lorsque nb vaut 18. L'instruction nb = nb * 2 est ignor\u00e9e et la valeur de nb n'est pas modifi\u00e9e.","title":"L'instruction if"},{"location":"python/instructions_conditionnelles/#linstruction-if-else","text":"La syntaxe de l'instruction if \u2026 else est : if expression : bloc_instructions_1 else : bloc_instructions_2 bloc_instructions_3 o\u00f9 expression a pour valeur True ou False . Lorsque expression a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_2 est ignor\u00e9. Lorsque expression a pour valeur False , le bloc bloc_instructions_1 est ignor\u00e9, et le bloc bloc_instructions_2 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , mais jamais les 2. Dans tous les cas, si le bloc bloc_instructions_3 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 5 if nb % 2 == 0 : print ( nb , \"est un nombre pair\" ) else : print ( nb , \"est un nombre impair\" ) 5 est un nombre impair nb % 2 == 0 est une expression qui vaut False lorsque nb vaut 5. L'instruction print(nb, \"est un nombre pair\") est ignor\u00e9e mais print(nb, \"est un nombre impair\") est ex\u00e9cut\u00e9e.","title":"L'instruction if \u2026 else"},{"location":"python/instructions_conditionnelles/#linstruction-if-elif-else","text":"Lorsque l'on souhaite disposer de plus d'une alternative, l'instruction if \u2026 elif \u2026 else permet de conditionner l'ex\u00e9cution de plusieurs blocs d'instructions par la valeur de plusieurs expressions bool\u00e9ennes. elif est \u00e9quivalent \u00e0 else if . On peut ajouter autant de clauses elif que n\u00e9cessaires. La syntaxe de l'instruction if \u2026 elif \u2026 else est : if expression1 : bloc_instructions_1 elif expression2 : bloc_instructions_2 else : bloc_instructions_3 bloc_instructions_4 o\u00f9 expression1 et expression2 ont pour valeur True ou False . Lorsque expression1 a pour valeur True , le bloc bloc_instructions_1 est ex\u00e9cut\u00e9, et les blocs bloc_instructions_2 et bloc_instructions_3 sont ignor\u00e9s. Lorsque expression1 a pour valeur False : le bloc bloc_instructions_1 est ignor\u00e9, si expression2 a pour valeur True , le bloc bloc_instructions_2 est ex\u00e9cut\u00e9, et le bloc bloc_instructions_3 est ignor\u00e9 ; si expression2 a pour valeur False , le bloc bloc_instructions_2 est ignor\u00e9, et le bloc bloc_instructions_3 est ex\u00e9cut\u00e9. On ex\u00e9cute donc soit le bloc bloc_instructions_1 , soit le bloc bloc_instructions_2 , soit le bloc bloc_instructions_3 , mais toujours un seul parmi les 3. Dans tous les cas, si le bloc bloc_instructions_4 existe, il est ex\u00e9cut\u00e9 ensuite. Exemple : nb = 15 if nb <= 10 : print ( nb , \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\" ) elif nb >= 20 : print ( nb , \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\" ) else : print ( nb , \"est strictement compris entre 10 et 20\" ) 15 est strictement compris entre 10 et 20 nb <= 10 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est inf\u00e9rieur ou \u00e9gal \u00e0 10\") est ignor\u00e9e. nb >= 20 est une expression qui vaut False lorsque nb vaut 15. L'instruction print(nb, \"est sup\u00e9rieur ou \u00e9gal \u00e0 20\") est aussi ignor\u00e9e. L'instruction print(nb, \"est strictement compris entre 10 et 20\") est donc ex\u00e9cut\u00e9e.","title":"L'instruction if \u2026 elif \u2026 else"},{"location":"python/instructions_conditionnelles_questions/","text":"Questions : instructions conditionnelles Question 1 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 else : nb = nb * 2 print ( nb ) Propositions de r\u00e9ponses 15 30 75 150 Solution 15 30 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30. Question 2 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 elif nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 30 45 75 150 Solution 30 45 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'expression de la clause elif , nb % 5 == 0 , a pour valeur True quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30. Question 3 Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 12 if nb % 2 == 0 : nb = nb * 5 if nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 24 36 60 120 Solution 24 36 60 120 Arguments L'expression de la clause du premier if , nb % 2 == 0 , a pour valeur True quand nb vaut 12. L'instruction nb = nb * 5 est donc ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 60. L'expression de la clause du second if , nb % 5 == 0 , a pour valeur True quand nb vaut 60. L'instruction nb = nb * 2 , est donc aussi ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 120. Cet exemple montre qu'il faut attentivement distinguer les instructions if \u2026 elif des instructions if successives.","title":"Questions"},{"location":"python/instructions_conditionnelles_questions/#questions-instructions-conditionnelles","text":"","title":"Questions : instructions conditionnelles"},{"location":"python/instructions_conditionnelles_questions/#question-1","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 else : nb = nb * 2 print ( nb ) Propositions de r\u00e9ponses 15 30 75 150 Solution 15 30 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30.","title":"Question 1"},{"location":"python/instructions_conditionnelles_questions/#question-2","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 15 if nb % 2 == 0 : nb = nb * 5 elif nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 30 45 75 150 Solution 30 45 75 150 Arguments L'expression de la clause if , nb % 2 == 0 , a pour valeur False quand nb vaut 15. L'expression de la clause elif , nb % 5 == 0 , a pour valeur True quand nb vaut 15. L'instruction ex\u00e9cut\u00e9e est donc nb = nb * 2 , ce qui affecte \u00e0 nb la valeur 30.","title":"Question 2"},{"location":"python/instructions_conditionnelles_questions/#question-3","text":"Question Apr\u00e8s ex\u00e9cution du programme suivant, quelle serait la valeur affich\u00e9e ? nb = 12 if nb % 2 == 0 : nb = nb * 5 if nb % 5 == 0 : nb = nb * 2 else : nb = nb * 3 print ( nb ) Propositions de r\u00e9ponses 24 36 60 120 Solution 24 36 60 120 Arguments L'expression de la clause du premier if , nb % 2 == 0 , a pour valeur True quand nb vaut 12. L'instruction nb = nb * 5 est donc ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 60. L'expression de la clause du second if , nb % 5 == 0 , a pour valeur True quand nb vaut 60. L'instruction nb = nb * 2 , est donc aussi ex\u00e9cut\u00e9e, ce qui affecte \u00e0 nb la valeur 120. Cet exemple montre qu'il faut attentivement distinguer les instructions if \u2026 elif des instructions if successives.","title":"Question 3"},{"location":"python/operateurs/","text":"Op\u00e9rateurs Les op\u00e9rateurs sont des symboles ou des mots r\u00e9serv\u00e9s, utilis\u00e9s pour r\u00e9aliser des op\u00e9rations entre des op\u00e9randes . Un op\u00e9rande est une variable, un litt\u00e9ral ou bien une expression. Une expression est une suite valide d'op\u00e9rateurs et d'op\u00e9randes. Op\u00e9rateurs arithm\u00e9tiques Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs num\u00e9riques est envisag\u00e9 ici. + Addition L'expression a + b a pour valeur la somme des deux op\u00e9randes a et b . a = 10 b = 3 a + b 13 - Soustraction L'expression a - b a pour valeur la diff\u00e9rence des deux op\u00e9randes a et b . a = 10 b = 3 a - b 7 * Multiplication L'expression a * b a pour valeur le produit des deux op\u00e9randes a et b . a = 10 b = 3 a * b 30 / Division L'expression a / b a pour valeur le quotient d\u00e9cimal dans la division de a par b . a = 10 b = 3 a / b 3.3333333333333335 % Modulo L'expression a % b a pour valeur le reste dans la division enti\u00e8re de a par b . a = 10 b = 3 a % b 1 // Division enti\u00e8re L'expression a // b a pour valeur le quotient dans la division enti\u00e8re de a par b . a = 10 b = 3 a // b 3 ** Exposant L'expression a ** b a pour valeur a exposant b : a b . a = 10 b = 3 a ** b 1000 Op\u00e9rateurs de comparaison Les op\u00e9rateurs de comparaison (ou relationnels) sont utilis\u00e9s pour comparer les valeurs de deux op\u00e9randes. L'expression s'\u00e9crit sous la forme d'une relation (de comparaison) : elle vaut True si les valeurs des op\u00e9randes v\u00e9rifient la relation et False sinon. == signifie \"est \u00e9gal \u00e0 \". Exemple : 2 * 3 == 5 vaut False != signifie \"n'est pas \u00e9gal \u00e0 \". Exemple : 2 * 3 != 5 vaut True > signifie \"est sup\u00e9rieur \u00e0 \". Exemple : 2 * 3 > 5 vaut True >= signifie \"est sup\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 >= 5 vaut True < signifie \"est inf\u00e9rieur \u00e0 \". Exemple : 2 * 3 < 5 vaut False <= signifie \"est inf\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 < 5 vaut False Op\u00e9rateurs logiques Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs bool\u00e9ennes est envisag\u00e9 ici. and ET logique L'expression a and b vaut True si (et seulement si) les deux op\u00e9randes a et b valent True . Exemple : 2 * 3 > 5 and 2 + 3 == 5 vaut True or OU logique L'expression a or b vaut True si (et seulement si) au moins l'un des deux op\u00e9randes a et b vaut True . Exemple : 2 * 3 < 5 and 2 + 3 == 5 vaut True not NON logique (op\u00e9rateur unaire 1 ) L'expression not a vaut True si a vaut False ; elle vaut False sinon. Exemple : not (2 * 3 < 5) vaut True Op\u00e9rateurs binaires Les op\u00e9rateurs binaires (ou bit \u00e0 bit) appliquent des op\u00e9rateurs logiques sur les bits de l'\u00e9criture binaire des op\u00e9randes. & Et bit \u00e0 bit a & b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un ET logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a & b 160 # soit 1010 0000 en binaire | Ou bit \u00e0 bit a | b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a | b 250 # soit 1111 1010 en binaire ^ Ou exclusif bit \u00e0 bit (xor) a ^ b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU exclusif (XOR) entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a ^ b 90 # soit 0101 1010 en binaire ~ Inversion bit \u00e0 bit (op\u00e9rateur unaire 1 ) ~ a : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un NON sur les bits de l'\u00e9criture binaire de a . Exemple : a = 240 # soit 1111 0000 en binaire ~ a 15 # soit 0000 1111 en binaire >> D\u00e9calage bit \u00e0 bit droite a >> b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la droite. Exemple : a = 48 # soit 0011 0000 en binaire a >> 2 12 # soit 0000 1100 en binaire << D\u00e9calage bit \u00e0 bit gauche a << b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la gauche. Exemple : a = 48 # soit 0011 0000 en binaire a << 2 192 # soit 1100 0000 en binaire Op\u00e9rateurs d'affectation Les op\u00e9rateurs d\u2019affectation sont utilis\u00e9s pour attribuer une valeur \u00e0 une variable. La variable est l'op\u00e9rande de gauche. La valeur est l'op\u00e9rande de droite : il est \u00e9valu\u00e9 avant l'affectation. En dehors de l'affectation \u00e0 l'aide du symbole = , les autres op\u00e9rateurs, dits d'affectation augment\u00e9e, combinent une op\u00e9ration arithm\u00e9rique ou binaire et une affectation de valeur \u00e0 une variable, pr\u00e9alablement initialis\u00e9e. = Op\u00e9rateur d'affectation Exemples : x = 2 : affecte \u00e0 x la valeur 2 . x = 2*3 + 5 : affecte \u00e0 x la valeur 11 . x = y : affecte \u00e0 x la valeur de y (qui doit avoir \u00e9t\u00e9 initialis\u00e9e pr\u00e9alablement) += Exemple : x += 2 : augmente la valeur de x de 2 . \u00c9quivalent \u00e0 x = x + 2 -= Exemple : x -= 2 : diminue la valeur de x de 2 . \u00c9quivalent \u00e0 x = x - 2 *= Exemple : x *= 2 : multiplie la valeur de x par 2 . \u00c9quivalent \u00e0 x = x * 2 /= Exemple : x /= 2 : divise la valeur de x par 2 . \u00c9quivalent \u00e0 x = x / 2 %= Exemple : x %= 2 : remplace x par le reste de la division de la valeur de x par 2 . \u00c9quivalent \u00e0 x = x % 2 //= Exemple : x //= 2 : divise la valeur de x par 2 (quotient entier). \u00c9quivalent \u00e0 x = x // 2 **= Exemple : x **= 2 : \u00e9l\u00e8ve x \u00e0 la puissance 2 . \u00c9quivalent \u00e0 x = x ** 2 &= Exemple : x &= 2 \u00c9quivalent \u00e0 x = x & 2 |= Exemple : x |= 2 \u00c9quivalent \u00e0 x = x | 2 ^= Exemple : x ^= 2 \u00c9quivalent \u00e0 x = x ^ 2 >>= Exemple : x >>= 2 \u00c9quivalent \u00e0 x = x >> 2 <<= Exemple : x <<= 2 \u00c9quivalent \u00e0 x = x << 2 Op\u00e9rateurs sp\u00e9ciaux Le langage Python offre des types d'op\u00e9rateurs sp\u00e9ciaux, tels que l'op\u00e9rateur d'identit\u00e9 ou l'op\u00e9rateur d'appartenance. Op\u00e9rateur d'identit\u00e9 is et is not sont les op\u00e9rateurs d'identit\u00e9 en Python. Ils permettent de v\u00e9rifier si deux valeurs (ou variables) r\u00e9f\u00e9rencent (ou non) le m\u00eame emplacement m\u00e9moire. Deux variables de m\u00eame valeur ne sont pas n\u00e9cessairement identiques. is a is b vaut True si les op\u00e9randes a et b r\u00e9f\u00e9rencent le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = tableau1 tableau1 is tableau2 True is not a is not b vaut True si les op\u00e9randes a et b ne r\u00e9f\u00e9rencent pas le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = [ 1 , 2 , 3 ] tableau1 is not tableau2 True Op\u00e9rateur d'appartenance in et not in sont les op\u00e9rateurs d'appartenance en Python. Ils sont utilis\u00e9s pour v\u00e9rifier si une valeur est pr\u00e9sente (ou non) dans une s\u00e9quence (cha\u00eene, liste, tuple, set et dictionnaire). in a in b vaut True si l'op\u00e9rande a se trouve dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 2 a in tableau True not in a not in b vaut True si l'op\u00e9rande a ne se trouve pas dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 4 a not in tableau True op\u00e9rateur ne n\u00e9cessitant qu'un op\u00e9rande \u21a9 \u21a9","title":"Op\u00e9rateurs"},{"location":"python/operateurs/#operateurs","text":"Les op\u00e9rateurs sont des symboles ou des mots r\u00e9serv\u00e9s, utilis\u00e9s pour r\u00e9aliser des op\u00e9rations entre des op\u00e9randes . Un op\u00e9rande est une variable, un litt\u00e9ral ou bien une expression. Une expression est une suite valide d'op\u00e9rateurs et d'op\u00e9randes.","title":"Op\u00e9rateurs"},{"location":"python/operateurs/#operateurs-arithmetiques","text":"Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs num\u00e9riques est envisag\u00e9 ici. + Addition L'expression a + b a pour valeur la somme des deux op\u00e9randes a et b . a = 10 b = 3 a + b 13 - Soustraction L'expression a - b a pour valeur la diff\u00e9rence des deux op\u00e9randes a et b . a = 10 b = 3 a - b 7 * Multiplication L'expression a * b a pour valeur le produit des deux op\u00e9randes a et b . a = 10 b = 3 a * b 30 / Division L'expression a / b a pour valeur le quotient d\u00e9cimal dans la division de a par b . a = 10 b = 3 a / b 3.3333333333333335 % Modulo L'expression a % b a pour valeur le reste dans la division enti\u00e8re de a par b . a = 10 b = 3 a % b 1 // Division enti\u00e8re L'expression a // b a pour valeur le quotient dans la division enti\u00e8re de a par b . a = 10 b = 3 a // b 3 ** Exposant L'expression a ** b a pour valeur a exposant b : a b . a = 10 b = 3 a ** b 1000","title":"Op\u00e9rateurs arithm\u00e9tiques"},{"location":"python/operateurs/#operateurs-de-comparaison","text":"Les op\u00e9rateurs de comparaison (ou relationnels) sont utilis\u00e9s pour comparer les valeurs de deux op\u00e9randes. L'expression s'\u00e9crit sous la forme d'une relation (de comparaison) : elle vaut True si les valeurs des op\u00e9randes v\u00e9rifient la relation et False sinon. == signifie \"est \u00e9gal \u00e0 \". Exemple : 2 * 3 == 5 vaut False != signifie \"n'est pas \u00e9gal \u00e0 \". Exemple : 2 * 3 != 5 vaut True > signifie \"est sup\u00e9rieur \u00e0 \". Exemple : 2 * 3 > 5 vaut True >= signifie \"est sup\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 >= 5 vaut True < signifie \"est inf\u00e9rieur \u00e0 \". Exemple : 2 * 3 < 5 vaut False <= signifie \"est inf\u00e9rieur ou \u00e9gal \u00e0 \". Exemple : 2 * 3 < 5 vaut False","title":"Op\u00e9rateurs de comparaison"},{"location":"python/operateurs/#operateurs-logiques","text":"Remarque Seul le cas d'op\u00e9randes \u00e0 valeurs bool\u00e9ennes est envisag\u00e9 ici. and ET logique L'expression a and b vaut True si (et seulement si) les deux op\u00e9randes a et b valent True . Exemple : 2 * 3 > 5 and 2 + 3 == 5 vaut True or OU logique L'expression a or b vaut True si (et seulement si) au moins l'un des deux op\u00e9randes a et b vaut True . Exemple : 2 * 3 < 5 and 2 + 3 == 5 vaut True not NON logique (op\u00e9rateur unaire 1 ) L'expression not a vaut True si a vaut False ; elle vaut False sinon. Exemple : not (2 * 3 < 5) vaut True","title":"Op\u00e9rateurs logiques"},{"location":"python/operateurs/#operateurs-binaires","text":"Les op\u00e9rateurs binaires (ou bit \u00e0 bit) appliquent des op\u00e9rateurs logiques sur les bits de l'\u00e9criture binaire des op\u00e9randes. & Et bit \u00e0 bit a & b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un ET logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a & b 160 # soit 1010 0000 en binaire | Ou bit \u00e0 bit a | b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU logique entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a | b 250 # soit 1111 1010 en binaire ^ Ou exclusif bit \u00e0 bit (xor) a ^ b : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un OU exclusif (XOR) entre les bits de l'\u00e9criture binaire de a et b . Exemple : a = 240 # soit 1111 0000 en binaire b = 170 # soit 1010 1010 en binaire a ^ b 90 # soit 0101 1010 en binaire ~ Inversion bit \u00e0 bit (op\u00e9rateur unaire 1 ) ~ a : on d\u00e9termine le r\u00e9sultat bit \u00e0 bit \u00e0 l'aide d'un NON sur les bits de l'\u00e9criture binaire de a . Exemple : a = 240 # soit 1111 0000 en binaire ~ a 15 # soit 0000 1111 en binaire >> D\u00e9calage bit \u00e0 bit droite a >> b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la droite. Exemple : a = 48 # soit 0011 0000 en binaire a >> 2 12 # soit 0000 1100 en binaire << D\u00e9calage bit \u00e0 bit gauche a << b : on d\u00e9termine le r\u00e9sultat en d\u00e9calant les bits de l'\u00e9criture binaire de a de b rangs vers la gauche. Exemple : a = 48 # soit 0011 0000 en binaire a << 2 192 # soit 1100 0000 en binaire","title":"Op\u00e9rateurs binaires"},{"location":"python/operateurs/#operateurs-daffectation","text":"Les op\u00e9rateurs d\u2019affectation sont utilis\u00e9s pour attribuer une valeur \u00e0 une variable. La variable est l'op\u00e9rande de gauche. La valeur est l'op\u00e9rande de droite : il est \u00e9valu\u00e9 avant l'affectation. En dehors de l'affectation \u00e0 l'aide du symbole = , les autres op\u00e9rateurs, dits d'affectation augment\u00e9e, combinent une op\u00e9ration arithm\u00e9rique ou binaire et une affectation de valeur \u00e0 une variable, pr\u00e9alablement initialis\u00e9e. = Op\u00e9rateur d'affectation Exemples : x = 2 : affecte \u00e0 x la valeur 2 . x = 2*3 + 5 : affecte \u00e0 x la valeur 11 . x = y : affecte \u00e0 x la valeur de y (qui doit avoir \u00e9t\u00e9 initialis\u00e9e pr\u00e9alablement) += Exemple : x += 2 : augmente la valeur de x de 2 . \u00c9quivalent \u00e0 x = x + 2 -= Exemple : x -= 2 : diminue la valeur de x de 2 . \u00c9quivalent \u00e0 x = x - 2 *= Exemple : x *= 2 : multiplie la valeur de x par 2 . \u00c9quivalent \u00e0 x = x * 2 /= Exemple : x /= 2 : divise la valeur de x par 2 . \u00c9quivalent \u00e0 x = x / 2 %= Exemple : x %= 2 : remplace x par le reste de la division de la valeur de x par 2 . \u00c9quivalent \u00e0 x = x % 2 //= Exemple : x //= 2 : divise la valeur de x par 2 (quotient entier). \u00c9quivalent \u00e0 x = x // 2 **= Exemple : x **= 2 : \u00e9l\u00e8ve x \u00e0 la puissance 2 . \u00c9quivalent \u00e0 x = x ** 2 &= Exemple : x &= 2 \u00c9quivalent \u00e0 x = x & 2 |= Exemple : x |= 2 \u00c9quivalent \u00e0 x = x | 2 ^= Exemple : x ^= 2 \u00c9quivalent \u00e0 x = x ^ 2 >>= Exemple : x >>= 2 \u00c9quivalent \u00e0 x = x >> 2 <<= Exemple : x <<= 2 \u00c9quivalent \u00e0 x = x << 2","title":"Op\u00e9rateurs d'affectation"},{"location":"python/operateurs/#operateurs-speciaux","text":"Le langage Python offre des types d'op\u00e9rateurs sp\u00e9ciaux, tels que l'op\u00e9rateur d'identit\u00e9 ou l'op\u00e9rateur d'appartenance.","title":"Op\u00e9rateurs sp\u00e9ciaux"},{"location":"python/operateurs/#operateur-didentite","text":"is et is not sont les op\u00e9rateurs d'identit\u00e9 en Python. Ils permettent de v\u00e9rifier si deux valeurs (ou variables) r\u00e9f\u00e9rencent (ou non) le m\u00eame emplacement m\u00e9moire. Deux variables de m\u00eame valeur ne sont pas n\u00e9cessairement identiques. is a is b vaut True si les op\u00e9randes a et b r\u00e9f\u00e9rencent le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = tableau1 tableau1 is tableau2 True is not a is not b vaut True si les op\u00e9randes a et b ne r\u00e9f\u00e9rencent pas le m\u00eame objet. Exemple : tableau1 = [ 1 , 2 , 3 ] tableau2 = [ 1 , 2 , 3 ] tableau1 is not tableau2 True","title":"Op\u00e9rateur d'identit\u00e9"},{"location":"python/operateurs/#operateur-dappartenance","text":"in et not in sont les op\u00e9rateurs d'appartenance en Python. Ils sont utilis\u00e9s pour v\u00e9rifier si une valeur est pr\u00e9sente (ou non) dans une s\u00e9quence (cha\u00eene, liste, tuple, set et dictionnaire). in a in b vaut True si l'op\u00e9rande a se trouve dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 2 a in tableau True not in a not in b vaut True si l'op\u00e9rande a ne se trouve pas dans la s\u00e9quence b . Exemple : tableau = [ 1 , 2 , 3 ] a = 4 a not in tableau True op\u00e9rateur ne n\u00e9cessitant qu'un op\u00e9rande \u21a9 \u21a9","title":"Op\u00e9rateur d'appartenance"},{"location":"python/pep8/","text":"Bonnes pratiques en programmation python \u00c9crire un texte dans une langue n\u00e9cessite le respect de r\u00e8gles typographiques concernant notamment l'usage des majuscules, des espaces, de la ponctuation, des paragraphes, etc. Il en est souvent de m\u00eame pour les langages , comme les langages de programmation. Des propositions d'am\u00e9liorations concernant le langage Python sont r\u00e9guli\u00e8rement publi\u00e9es : les Python Enhancement Proposal (PEP). L'une de ces propositions, la PEP 8 : Style Guide for Python Code , consiste en un nombre important de recommandations sur la syntaxe Python. Seules quelques-unes sont pr\u00e9sent\u00e9es ici. 1. Mise en page Longueur des lignes : une ligne doit contenir 79 caract\u00e8res au maximum. Indentation : les blocs d'instructions sont \u00e0 indenter de 4 espaces. 2. R\u00e8gles de nommage Les noms de variable, fonction ou classe ne doivent pas contenir d'accent. Les caract\u00e8res autoris\u00e9s sont les lettres, les chiffres et le tiret bas : _ Variables et fonctions Les noms de variables et de fonctions sont \u00e0 \u00e9crire avec des lettres minuscules et le tiret bas. Constantes Les noms des constantes sont \u00e0 \u00e9crire avec des lettres capitales et le tiret bas. Classes Les noms des classes sont \u00e0 \u00e9crire avec des lettres minuscules avec majuscules en d\u00e9but de mot. Exemples Variables compteur mon_tableau Fonctions jouer () racine_carree ( x ) Constantes CLE NB_POINTS Classes MaClasse MaSuperClasse Info Le style recommand\u00e9 pour nommer les variables et les fonctions en Python est appel\u00e9 snake_case . Le style recommand\u00e9 pour nommer les classes en Python est appel\u00e9 CamelCase . 3. Espaces Les espaces suivent la syntaxe anglo-saxonne et non fran\u00e7aise. Ainsi les caract\u00e8res ; , : et , s'\u00e9crivent avec un espace apr\u00e8s mais pas d'espace avant. Autour des op\u00e9rateurs Il est recommand\u00e9 de toujours entourer les op\u00e9rateurs suivants ( = , += , -= , *= , /= , == , != , >= , not , in , and , or , etc.) d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Les op\u00e9rateurs suivants ( + , - , * , / ) sont \u00e0 entourer en r\u00e8gle g\u00e9n\u00e9rale d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Lorsqu'une expression comporte des op\u00e9rations de diff\u00e9rentes priorit\u00e9s, on peut r\u00e9server les espaces \u00e0 l'op\u00e9rateur de plus faible priorit\u00e9. Exemples compteur = 0 compteur = compteur + 1 compteur += 1 x = 2 * x + 1 Autour des parenth\u00e8ses Il n'y a pas d'espace : apr\u00e8s les parenth\u00e8ses, accolades et crochets ouvrants ; avant les parenth\u00e8ses, accolades et crochets fermants ; juste avant la parenth\u00e8se ouvrante d'une fonction ou le crochet ouvrant d'une liste ou d'un dictionnaire. Exemples ma_fonction ( x ) mon_dictionnaire = { \"valeur\" : 42 , \"type\" : \"r\u00e9ponse\" } mon_tableau = ( 'a' , 'ab' , 'ac' ) mon_tableau [ 0 ] mon_dictionnaire [ \"valeur\" ] 4. Docstrings Une docstring (\u00ab cha\u00eene de documentation \u00bb en fran\u00e7ais) est un texte qui documente un \u00e9l\u00e9ment du code comme par exemple les fonctions. Elle est situ\u00e9e en d\u00e9but de d\u00e9finition, indent\u00e9e comme le code, et se compose de trois guillemets ouvrants, puis du commentaire r\u00e9dig\u00e9 sous forme de phrases compl\u00e8tes et enfin de trois guillements fermants. Toutes les fonctions et classes devraient disposer d'une docstring . Exemples def est_premier ( nombre ): \"\"\" nombre est un entier est_premier(nombre) vaut True si nombre est premier, et False sinon \"\"\" ...","title":"Bonnes pratiques"},{"location":"python/pep8/#bonnes-pratiques-en-programmation-python","text":"\u00c9crire un texte dans une langue n\u00e9cessite le respect de r\u00e8gles typographiques concernant notamment l'usage des majuscules, des espaces, de la ponctuation, des paragraphes, etc. Il en est souvent de m\u00eame pour les langages , comme les langages de programmation. Des propositions d'am\u00e9liorations concernant le langage Python sont r\u00e9guli\u00e8rement publi\u00e9es : les Python Enhancement Proposal (PEP). L'une de ces propositions, la PEP 8 : Style Guide for Python Code , consiste en un nombre important de recommandations sur la syntaxe Python. Seules quelques-unes sont pr\u00e9sent\u00e9es ici.","title":"Bonnes pratiques en programmation python"},{"location":"python/pep8/#1-mise-en-page","text":"Longueur des lignes : une ligne doit contenir 79 caract\u00e8res au maximum. Indentation : les blocs d'instructions sont \u00e0 indenter de 4 espaces.","title":"1. Mise en page"},{"location":"python/pep8/#2-regles-de-nommage","text":"Les noms de variable, fonction ou classe ne doivent pas contenir d'accent. Les caract\u00e8res autoris\u00e9s sont les lettres, les chiffres et le tiret bas : _","title":"2. R\u00e8gles de nommage"},{"location":"python/pep8/#variables-et-fonctions","text":"Les noms de variables et de fonctions sont \u00e0 \u00e9crire avec des lettres minuscules et le tiret bas.","title":"Variables et fonctions"},{"location":"python/pep8/#constantes","text":"Les noms des constantes sont \u00e0 \u00e9crire avec des lettres capitales et le tiret bas.","title":"Constantes"},{"location":"python/pep8/#classes","text":"Les noms des classes sont \u00e0 \u00e9crire avec des lettres minuscules avec majuscules en d\u00e9but de mot. Exemples Variables compteur mon_tableau Fonctions jouer () racine_carree ( x ) Constantes CLE NB_POINTS Classes MaClasse MaSuperClasse Info Le style recommand\u00e9 pour nommer les variables et les fonctions en Python est appel\u00e9 snake_case . Le style recommand\u00e9 pour nommer les classes en Python est appel\u00e9 CamelCase .","title":"Classes"},{"location":"python/pep8/#3-espaces","text":"Les espaces suivent la syntaxe anglo-saxonne et non fran\u00e7aise. Ainsi les caract\u00e8res ; , : et , s'\u00e9crivent avec un espace apr\u00e8s mais pas d'espace avant.","title":"3. Espaces"},{"location":"python/pep8/#autour-des-operateurs","text":"Il est recommand\u00e9 de toujours entourer les op\u00e9rateurs suivants ( = , += , -= , *= , /= , == , != , >= , not , in , and , or , etc.) d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Les op\u00e9rateurs suivants ( + , - , * , / ) sont \u00e0 entourer en r\u00e8gle g\u00e9n\u00e9rale d'un espace avant et d'un espace apr\u00e8s l'op\u00e9rateur. Lorsqu'une expression comporte des op\u00e9rations de diff\u00e9rentes priorit\u00e9s, on peut r\u00e9server les espaces \u00e0 l'op\u00e9rateur de plus faible priorit\u00e9. Exemples compteur = 0 compteur = compteur + 1 compteur += 1 x = 2 * x + 1","title":"Autour des op\u00e9rateurs"},{"location":"python/pep8/#autour-des-parentheses","text":"Il n'y a pas d'espace : apr\u00e8s les parenth\u00e8ses, accolades et crochets ouvrants ; avant les parenth\u00e8ses, accolades et crochets fermants ; juste avant la parenth\u00e8se ouvrante d'une fonction ou le crochet ouvrant d'une liste ou d'un dictionnaire. Exemples ma_fonction ( x ) mon_dictionnaire = { \"valeur\" : 42 , \"type\" : \"r\u00e9ponse\" } mon_tableau = ( 'a' , 'ab' , 'ac' ) mon_tableau [ 0 ] mon_dictionnaire [ \"valeur\" ]","title":"Autour des parenth\u00e8ses"},{"location":"python/pep8/#4-docstrings","text":"Une docstring (\u00ab cha\u00eene de documentation \u00bb en fran\u00e7ais) est un texte qui documente un \u00e9l\u00e9ment du code comme par exemple les fonctions. Elle est situ\u00e9e en d\u00e9but de d\u00e9finition, indent\u00e9e comme le code, et se compose de trois guillemets ouvrants, puis du commentaire r\u00e9dig\u00e9 sous forme de phrases compl\u00e8tes et enfin de trois guillements fermants. Toutes les fonctions et classes devraient disposer d'une docstring . Exemples def est_premier ( nombre ): \"\"\" nombre est un entier est_premier(nombre) vaut True si nombre est premier, et False sinon \"\"\" ...","title":"4. Docstrings"},{"location":"snt/snt/","text":"bient\u00f4t","title":"Snt"}]}